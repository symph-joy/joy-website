[{"pathname":"INIT@/joy/advanced-features/custom-app","ssgData":[{"type":"__INIT_MODEL","state":{"noop":{},"reactAppInitManager":{},"layoutModel":{"collapsed":true,"isMobile":false},"docsModel":{"loadingCurrentDoc":false,"docMenus":[],"titleTrees":[],"result":[],"openKeys":[],"snippets":{},"defaultOpenKeys":[]}}}]},{"pathname":"/","ssgData":[{"type":"reactAppInitManager/__SET_STATE","state":{"/":{"pathname":"/","index":false,"initStatic":2}}}]},{"pathname":"/joy","ssgData":[{"type":"docsModel/__SET_STATE","state":{"docMenus":[{"title":"介绍","path":"/joy/01-start","file":"docs/joy/01-start","children":[{"title":"@symph/joy","path":"/joy/start/introduce","file":"docs/joy/01-start/01-introduce.md","hasMenu":false,"mdContent":"# @symph/joy\n\n官网：[https://lnlfps.github.io/symph-joy](https://lnlfps.github.io/symph-joy)\n\n@symph/joy 让我们轻松的进行前端应用开发，零配置可用，简单清晰的业务和数据管理模块，已集成大量最佳实践的优化方案，即使你才刚接触 React，也可以轻松创建高可用、可维护的前端应用。\n\n> 该项目已在生产环境大量使用，如有任何疑问、使用帮助、bug 反馈、特性讨论，请和我们联系(邮件：lnlfps@gmail.com; QQ 群：929743297)，或者到 github 创建 issue，欢迎加入。\n\n## 特征\n\n- 零配置可用，优化的默认配置，快速开发，已集成 react、redux、react-router4 和 ES6、7 语法支持等\n- 支持服务端渲染，在业务组件内部获取渲染数据，组件内聚更高，便于维护\n- MVC 架构，模块化设计，简化 redux 的学习和使用\n- 依赖自动注入，专注组件内部实现，依赖关系更明确，方便调用\n- 支持`@`装饰器将普通 Class 申明为 Controller 或 Model 等，不侵入业务代码\n- 支持 react hook 模式开发函数式组件，轻松链接 Model 管理业务流程\n- 全局支持 async 语法，复杂的业务逻辑也能轻松找到解决方案\n- 支持静态版本导出，脱离 Node.js 运行，也可单独导出静态页面\n- 内置网络请求代理服务，解决跨域和服务中转问题，前后端分离开发畅通无阻\n- 支持插件化配置，便于功能扩展\n\n\n## 联系我们\n\nGithub Issue:  https://github.com/symph-joy/symph-joy/issues   \n邮件：lnlfps@gmail.com   \nQQ 群：929743297\n","htmlContent":"\n                <h1 id=\"symph%2Fjoy\">\n                  @symph/joy\n                </h1><p>官网：<a href=\"https://lnlfps.github.io/symph-joy\">https://lnlfps.github.io/symph-joy</a></p>\n<p>@symph/joy 让我们轻松的进行前端应用开发，零配置可用，简单清晰的业务和数据管理模块，已集成大量最佳实践的优化方案，即使你才刚接触 React，也可以轻松创建高可用、可维护的前端应用。</p>\n<blockquote>\n<p>该项目已在生产环境大量使用，如有任何疑问、使用帮助、bug 反馈、特性讨论，请和我们联系(邮件：<a href=\"mailto:&#108;&#110;&#x6c;&#x66;&#x70;&#x73;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;\">&#108;&#110;&#x6c;&#x66;&#x70;&#x73;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a>; QQ 群：929743297)，或者到 github 创建 issue，欢迎加入。</p>\n</blockquote>\n\n                <h2 id=\"%E7%89%B9%E5%BE%81\">\n                  特征\n                </h2><ul>\n<li>零配置可用，优化的默认配置，快速开发，已集成 react、redux、react-router4 和 ES6、7 语法支持等</li>\n<li>支持服务端渲染，在业务组件内部获取渲染数据，组件内聚更高，便于维护</li>\n<li>MVC 架构，模块化设计，简化 redux 的学习和使用</li>\n<li>依赖自动注入，专注组件内部实现，依赖关系更明确，方便调用</li>\n<li>支持<code>@</code>装饰器将普通 Class 申明为 Controller 或 Model 等，不侵入业务代码</li>\n<li>支持 react hook 模式开发函数式组件，轻松链接 Model 管理业务流程</li>\n<li>全局支持 async 语法，复杂的业务逻辑也能轻松找到解决方案</li>\n<li>支持静态版本导出，脱离 Node.js 运行，也可单独导出静态页面</li>\n<li>内置网络请求代理服务，解决跨域和服务中转问题，前后端分离开发畅通无阻</li>\n<li>支持插件化配置，便于功能扩展</li>\n</ul>\n\n                <h2 id=\"%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC\">\n                  联系我们\n                </h2><p>Github Issue:  <a href=\"https://github.com/symph-joy/symph-joy/issues\">https://github.com/symph-joy/symph-joy/issues</a><br>邮件：<a href=\"mailto:&#108;&#x6e;&#108;&#102;&#112;&#115;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;\">&#108;&#x6e;&#108;&#102;&#112;&#115;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a><br>QQ 群：929743297</p>\n","anchor":[{"type":"heading","raw":"## 特征\n\n","depth":2,"text":"特征","tokens":[{"type":"text","raw":"特征","text":"特征"}],"id":"#%E7%89%B9%E5%BE%81"},{"type":"heading","raw":"## 联系我们\n\n","depth":2,"text":"联系我们","tokens":[{"type":"text","raw":"联系我们","text":"联系我们"}],"id":"#%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC"}]},{"title":"快速开始","path":"/joy/start/quick-started","file":"docs/joy/01-start/02-quick-started.md","hasMenu":false,"mdContent":"# 快速开始\n\nJoy 支持 React、Node 或者前后端混合应用开发，这里以一个简单的 React 应用为例，介绍如何快速开始开发。\n\n## 环境准备\n\n- node 建议 12 或以上版本，推荐使用 nvm 来管理 node 版本。\n\n- 推荐使用 yarn 管理依赖，国内使用 [阿里 npm 源](https://npmmirror.com/) registry: https://registry.npm.taobao.org\n\n```shell\n# 安装 yarn\n$ npm i yarn -g\n# 手动设置`registry`地址为国内源\n$ yarn config set registry https://registry.npm.taobao.org\n# 查看源\n$ yarn config get registry\n\n# 或者使用 tyarn\n$ npm i yarn tyarn -g\n# 后面文档里的 yarn 换成 tyarn\n$ tyarn -v\n```\n\n## 创建目录\n\n创建应用根目录\n\n```shell\n$ mkdir myapp && cd myapp\n```\n\n创建应用内目录和文件，目录结构如下：\n\n```shell\nmyapp\n  src  # 源代码目录\n    pages  # 约定React路由目录\n      index.tsx  # 第一个页面\n  package.json\n```\n\n- 在 package.json 内声明应用名和依赖：\n\n```json\n{\n  \"name\": \"myapp\",\n  \"version\": \"v1.0.0\",\n  \"scripts\": {\n    \"dev\": \"joy dev\",\n    \"export\": \"joy build&&joy export\"\n  },\n  \"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n    \"@symph/joy\": \"^2.0.0\"\n  }\n}\n```\n\n- 创建第一个路由页面`index.tsx`, Joy 同时支持 ES6 和 Typescript 语法，如果使用 ES6，创建 JS 文件`index.jsx`，添加页面展现内容:\n\n```tsx\n// src/pages/index.tsx\nimport React from \"react\";\nimport { ReactController, BaseReactController } from \"@symph/react\";\n\n@ReactController()\nexport default class Index extends BaseReactController {\n  renderView() {\n    return <p>Hello Joy!</p>;\n  }\n}\n```\n\n## 安装依赖\n\n```shell\n$ yarn install\n```\n\n## 启动开发服务器\n\n```shell\n$ yarn dev\n```\n\n当命令行输出`ready - started server on http://localhost:3000`时，开发服务器启动成功，打开浏览器输入地址 `http://localhost:3000`，即可看到我们的第一个页面`Hello Joy!`。\n若此时修改页面内容`Hello Joy!`为`Hello MyApp`，然后保存文件，浏览器界面将自动更新为新内容。\n\n## 部署发布\n\n### 构建\n\n```shell\n$ yarn export\n```\n\n构建产物默认生成到 ./out 下，目录结构类似于：\n\n```shell\n./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n```\n\n### 本地验证\n\n使用`http-server`启动本地静态文件服务器\n\n```shell\n# 安装 http-server\n$ npm i -g http-server\n\n# 启动服务器\n$ http-server ./out\n```\n\n在浏览器上打开地址：[http://127.0.0.1:8080](http://127.0.0.1:8080), 正常情况下应该是和`yarn dev`开发运行时是一致的。\n\n### 部署\n\n本地验证完成后，将`out`目录部署到服务器上即可。\n","htmlContent":"\n                <h1 id=\"%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\">\n                  快速开始\n                </h1><p>Joy 支持 React、Node 或者前后端混合应用开发，这里以一个简单的 React 应用为例，介绍如何快速开始开发。</p>\n\n                <h2 id=\"%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\">\n                  环境准备\n                </h2><ul>\n<li><p>node 建议 12 或以上版本，推荐使用 nvm 来管理 node 版本。</p>\n</li>\n<li><p>推荐使用 yarn 管理依赖，国内使用 <a href=\"https://npmmirror.com/\">阿里 npm 源</a> registry: <a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a></p>\n</li>\n</ul>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">安装 yarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i yarn -g</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">手动设置`registry`地址为国内源</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">查看源</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn config get registry</span>\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">或者使用 tyarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i yarn tyarn -g</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">后面文档里的 yarn 换成 tyarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">tyarn -v</span>\n</code></pre>\n\n                <h2 id=\"%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95\">\n                  创建目录\n                </h2><p>创建应用根目录</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> myapp &amp;&amp; <span class=\"hljs-built_in\">cd</span> myapp</span>\n</code></pre>\n<p>创建应用内目录和文件，目录结构如下：</p>\n<pre><code class=\"hljs language-shell\">myapp\n  src  # 源代码目录\n    pages  # 约定React路由目录\n      index.tsx  # 第一个页面\n  package.json\n</code></pre>\n<ul>\n<li>在 package.json 内声明应用名和依赖：</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;myapp&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;v1.0.0&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy dev&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;export&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy build&amp;&amp;joy export&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;react&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;react-dom&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;@symph/joy&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^2.0.0&quot;</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<ul>\n<li>创建第一个路由页面<code>index.tsx</code>, Joy 同时支持 ES6 和 Typescript 语法，如果使用 ES6，创建 JS 文件<code>index.jsx</code>，添加页面展现内容:</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/pages/index.tsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Index</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello Joy!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n\n                <h2 id=\"%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\">\n                  安装依赖\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn install</span>\n</code></pre>\n\n                <h2 id=\"%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\">\n                  启动开发服务器\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn dev</span>\n</code></pre>\n<p>当命令行输出<code>ready - started server on http://localhost:3000</code>时，开发服务器启动成功，打开浏览器输入地址 <code>http://localhost:3000</code>，即可看到我们的第一个页面<code>Hello Joy!</code>。\n若此时修改页面内容<code>Hello Joy!</code>为<code>Hello MyApp</code>，然后保存文件，浏览器界面将自动更新为新内容。</p>\n\n                <h2 id=\"%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83\">\n                  部署发布\n                </h2>\n                <h3 id=\"%E6%9E%84%E5%BB%BA\">\n                  构建\n                </h3><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn <span class=\"hljs-built_in\">export</span></span>\n</code></pre>\n<p>构建产物默认生成到 ./out 下，目录结构类似于：</p>\n<pre><code class=\"hljs language-shell\">./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n</code></pre>\n\n                <h3 id=\"%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81\">\n                  本地验证\n                </h3><p>使用<code>http-server</code>启动本地静态文件服务器</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">安装 http-server</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i -g http-server</span>\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">启动服务器</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">http-server ./out</span>\n</code></pre>\n<p>在浏览器上打开地址：<a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>, 正常情况下应该是和<code>yarn dev</code>开发运行时是一致的。</p>\n\n                <h3 id=\"%E9%83%A8%E7%BD%B2\">\n                  部署\n                </h3><p>本地验证完成后，将<code>out</code>目录部署到服务器上即可。</p>\n","anchor":[{"type":"heading","raw":"## 环境准备\n\n","depth":2,"text":"环境准备","tokens":[{"type":"text","raw":"环境准备","text":"环境准备"}],"id":"#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"},{"type":"heading","raw":"## 创建目录\n\n","depth":2,"text":"创建目录","tokens":[{"type":"text","raw":"创建目录","text":"创建目录"}],"id":"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"## 安装依赖\n\n","depth":2,"text":"安装依赖","tokens":[{"type":"text","raw":"安装依赖","text":"安装依赖"}],"id":"#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"},{"type":"heading","raw":"## 启动开发服务器\n\n","depth":2,"text":"启动开发服务器","tokens":[{"type":"text","raw":"启动开发服务器","text":"启动开发服务器"}],"id":"#%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"},{"type":"heading","raw":"## 部署发布\n\n","depth":2,"text":"部署发布","tokens":[{"type":"text","raw":"部署发布","text":"部署发布"}],"id":"#%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83","children":[{"type":"heading","raw":"### 构建\n\n","depth":3,"text":"构建","tokens":[{"type":"text","raw":"构建","text":"构建"}],"id":"#%E6%9E%84%E5%BB%BA"},{"type":"heading","raw":"### 本地验证\n\n","depth":3,"text":"本地验证","tokens":[{"type":"text","raw":"本地验证","text":"本地验证"}],"id":"#%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81"},{"type":"heading","raw":"### 部署\n\n","depth":3,"text":"部署","tokens":[{"type":"text","raw":"部署","text":"部署"}],"id":"#%E9%83%A8%E7%BD%B2"}]}]}]},{"title":"基础使用","path":"/joy/02-basic","file":"docs/joy/02-basic","children":[{"title":"目录结构","path":"/joy/basic/dir-tree","file":"docs/joy/02-basic/02-dir-tree.md","hasMenu":false,"mdContent":"# 目录结构\n\n## 约定目录结构\n\nJoy 支持 React 和 Node 以及两者的混合应用，下面列举各种应用类型常用的约定目录结构。\n\n### React 应用\n\n```shell\n    myapp\n        src # 源代码目录\n            pages    # React文件约定路由目录\n            models    # ReactModel目录\n            components  # React组件\n            server  # 可选，server端目录\n        config  # 配置目录\n            config.ts  # 配置文件\n        public  # 静态公共目录\n            logo.png  # 静态文件\n        package.json\n```\n\n### Node 应用 或者 前后端混合应用\n\n```shell\nmyapp\n    src # 源代码目录\n        server  # 服务端代码\n            controllers\n            services\n        client  # 可选，客户端代码\n            pages    # 约定React路由目录\n            models    # ReactModel目录\n            components  # React组件\n    config  # 配置目录\n        config.ts  # 配置文件\n    public  # 静态公共目录\n        logo.png  # 静态文件\n    package.json\n```\n\n## 目录说明\n\n### .joy 目录\n\nJoy 在运行时自动生成的目录，是 Joy 必须的，但可以随时清除，Joy 在下次运行时重新生成该目录。\n日常开发时，我们不用去关注和修改里面的文件。\n里面主要包含的文件有：\n\n- 用于代码扫描分析的临时文件，以及分析后的产出物。\n- webpack 构建的缓存、日志物。\n- Joy 应用运行加载的源文件，这些文件是编译打包后的源文件。\n\n### out 目录\n\n运行`joy export` 命令的默认输出目录，存放 React 导出后的静态文件，部署该目录到静态文件服务器即可，例如 Nginx 。\n\n### .env\n\n[dotenv](https://github.com/motdotla/dotenv) 环境变量配置文件。\n例如：\n\n```shell\nport=8888\nhost=localhost\n```\n\n### server 目录\n\n服务端相关代码，如果不需要服务端提供后端服务，可以没有该目录。\n\n### client 目录\n\nReact 客户端应用相关的代码，该目录可选：\n\n- `client`这级目录可以省略，直接在`src`下创建 React 的源代码文件，例如`src/pages/index.tsx`。\n- 如果应用只提供 Api 服务，不需要前端 React 界面，可以没有该目录。\n\n### client/pages 或者 pages 目录\n\nReact 约定文件路由目录，具体使用方法，请查看路由相关章节。\n","htmlContent":"\n                <h1 id=\"%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">\n                  目录结构\n                </h1>\n                <h2 id=\"%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">\n                  约定目录结构\n                </h2><p>Joy 支持 React 和 Node 以及两者的混合应用，下面列举各种应用类型常用的约定目录结构。</p>\n\n                <h3 id=\"react-%E5%BA%94%E7%94%A8\">\n                  React 应用\n                </h3><pre><code class=\"hljs language-shell\">    myapp\n        src # 源代码目录\n            pages    # React文件约定路由目录\n            models    # ReactModel目录\n            components  # React组件\n            server  # 可选，server端目录\n        config  # 配置目录\n            config.ts  # 配置文件\n        public  # 静态公共目录\n            logo.png  # 静态文件\n        package.json\n</code></pre>\n\n                <h3 id=\"node-%E5%BA%94%E7%94%A8-%E6%88%96%E8%80%85-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8\">\n                  Node 应用 或者 前后端混合应用\n                </h3><pre><code class=\"hljs language-shell\">myapp\n    src # 源代码目录\n        server  # 服务端代码\n            controllers\n            services\n        client  # 可选，客户端代码\n            pages    # 约定React路由目录\n            models    # ReactModel目录\n            components  # React组件\n    config  # 配置目录\n        config.ts  # 配置文件\n    public  # 静态公共目录\n        logo.png  # 静态文件\n    package.json\n</code></pre>\n\n                <h2 id=\"%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E\">\n                  目录说明\n                </h2>\n                <h3 id=\"joy-%E7%9B%AE%E5%BD%95\">\n                  .joy 目录\n                </h3><p>Joy 在运行时自动生成的目录，是 Joy 必须的，但可以随时清除，Joy 在下次运行时重新生成该目录。\n日常开发时，我们不用去关注和修改里面的文件。\n里面主要包含的文件有：</p>\n<ul>\n<li>用于代码扫描分析的临时文件，以及分析后的产出物。</li>\n<li>webpack 构建的缓存、日志物。</li>\n<li>Joy 应用运行加载的源文件，这些文件是编译打包后的源文件。</li>\n</ul>\n\n                <h3 id=\"out-%E7%9B%AE%E5%BD%95\">\n                  out 目录\n                </h3><p>运行<code>joy export</code> 命令的默认输出目录，存放 React 导出后的静态文件，部署该目录到静态文件服务器即可，例如 Nginx 。</p>\n\n                <h3 id=\"env\">\n                  .env\n                </h3><p><a href=\"https://github.com/motdotla/dotenv\">dotenv</a> 环境变量配置文件。\n例如：</p>\n<pre><code class=\"hljs language-shell\">port=8888\nhost=localhost\n</code></pre>\n\n                <h3 id=\"server-%E7%9B%AE%E5%BD%95\">\n                  server 目录\n                </h3><p>服务端相关代码，如果不需要服务端提供后端服务，可以没有该目录。</p>\n\n                <h3 id=\"client-%E7%9B%AE%E5%BD%95\">\n                  client 目录\n                </h3><p>React 客户端应用相关的代码，该目录可选：</p>\n<ul>\n<li><code>client</code>这级目录可以省略，直接在<code>src</code>下创建 React 的源代码文件，例如<code>src/pages/index.tsx</code>。</li>\n<li>如果应用只提供 Api 服务，不需要前端 React 界面，可以没有该目录。</li>\n</ul>\n\n                <h3 id=\"clientpages-%E6%88%96%E8%80%85-pages-%E7%9B%AE%E5%BD%95\">\n                  client/pages 或者 pages 目录\n                </h3><p>React 约定文件路由目录，具体使用方法，请查看路由相关章节。</p>\n","anchor":[{"type":"heading","raw":"## 约定目录结构\n\n","depth":2,"text":"约定目录结构","tokens":[{"type":"text","raw":"约定目录结构","text":"约定目录结构"}],"id":"#%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84","children":[{"type":"heading","raw":"### React 应用\n\n","depth":3,"text":"React 应用","tokens":[{"type":"text","raw":"React 应用","text":"React 应用"}],"id":"#react-%E5%BA%94%E7%94%A8"},{"type":"heading","raw":"### Node 应用 或者 前后端混合应用\n\n","depth":3,"text":"Node 应用 或者 前后端混合应用","tokens":[{"type":"text","raw":"Node 应用 或者 前后端混合应用","text":"Node 应用 或者 前后端混合应用"}],"id":"#node-%E5%BA%94%E7%94%A8-%E6%88%96%E8%80%85-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8"}]},{"type":"heading","raw":"## 目录说明\n\n","depth":2,"text":"目录说明","tokens":[{"type":"text","raw":"目录说明","text":"目录说明"}],"id":"#%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E","children":[{"type":"heading","raw":"### .joy 目录\n\n","depth":3,"text":".joy 目录","tokens":[{"type":"text","raw":".joy 目录","text":".joy 目录"}],"id":"#joy-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### out 目录\n\n","depth":3,"text":"out 目录","tokens":[{"type":"text","raw":"out 目录","text":"out 目录"}],"id":"#out-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### .env\n\n","depth":3,"text":".env","tokens":[{"type":"text","raw":".env","text":".env"}],"id":"#env"},{"type":"heading","raw":"### server 目录\n\n","depth":3,"text":"server 目录","tokens":[{"type":"text","raw":"server 目录","text":"server 目录"}],"id":"#server-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### client 目录\n\n","depth":3,"text":"client 目录","tokens":[{"type":"text","raw":"client 目录","text":"client 目录"}],"id":"#client-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### client/pages 或者 pages 目录\n\n","depth":3,"text":"client/pages 或者 pages 目录","tokens":[{"type":"text","raw":"client/pages 或者 pages 目录","text":"client/pages 或者 pages 目录"}],"id":"#clientpages-%E6%88%96%E8%80%85-pages-%E7%9B%AE%E5%BD%95"}]}]},{"title":"React 路由","path":"/joy/basic/react-router","file":"docs/joy/02-basic/04-react-router.md","hasMenu":false,"mdContent":"# React 路由\n\nJoy React 应用是单页面应用(SPA)，单页面应用是加载单个 HTML 页面并在用户与应用程序交互时动态的更新该页面，而更新工作就由路由模块来完成，不同的页面由不同的的组件构成，页面切换也就是组件的切换。\n\n> 路由模块底层封装自 [react reactRouterService](https://reactrouter.com/)，其核心概念和用法可以兼容，我们可以直接采用 react reactRouterService 官方文档中描述的方法来定义路由。\n\n## 路由组件\n\n使用`@ReactRoute`装饰器将`ReactController`申明为一个路由组件，路由组件在 Joy 启动时将被自动扫描和加载。\n即创建`src/client/pages/hello.tsx`文件，启动`joy dev`，浏览`http://localhost:300/hello` 即可访问到我们的页面。\n\n```tsx\n// src/client/pages/hello.tsx\n\nimport React from \"react\";\nimport { ReactController, BaseReactController, ReactRoute } from \"@symph/react\";\n\n@ReactRoute({ path: \"/hello\" })\n@ReactController()\nexport default class HelloController extends BaseReactController {\n  renderView() {\n    return <div data-testid=\"hello\">Hello</div>;\n  }\n}\n```\n\n等效于以下路由配置：\n\n```js\n[{ exact: true, path: \"/hello\", componentName: \"helloController\", componentModule: \"src/client/pages/hello.tsx\" }]``;\n```\n\n### 路由组件参数\n\n#### path\n\nType: `string`\n\n能匹配本组件的路由路径，其配置方法需满足 [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 规则。\n\n#### exact\n\nType: `boolean | undefined`, Default：`true`\n\n是否严格匹配路由路径，即路由和\n","htmlContent":"\n                <h1 id=\"react-%E8%B7%AF%E7%94%B1\">\n                  React 路由\n                </h1><p>Joy React 应用是单页面应用(SPA)，单页面应用是加载单个 HTML 页面并在用户与应用程序交互时动态的更新该页面，而更新工作就由路由模块来完成，不同的页面由不同的的组件构成，页面切换也就是组件的切换。</p>\n<blockquote>\n<p>路由模块底层封装自 <a href=\"https://reactrouter.com/\">react reactRouterService</a>，其核心概念和用法可以兼容，我们可以直接采用 react reactRouterService 官方文档中描述的方法来定义路由。</p>\n</blockquote>\n\n                <h2 id=\"%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6\">\n                  路由组件\n                </h2><p>使用<code>@ReactRoute</code>装饰器将<code>ReactController</code>申明为一个路由组件，路由组件在 Joy 启动时将被自动扫描和加载。\n即创建<code>src/client/pages/hello.tsx</code>文件，启动<code>joy dev</code>，浏览<code>http://localhost:300/hello</code> 即可访问到我们的页面。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/client/pages/hello.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/hello&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-testid</span>=<span class=\"hljs-string\">&quot;hello&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<p>等效于以下路由配置：</p>\n<pre><code class=\"hljs language-js\">[{ <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/hello&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;helloController&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-string\">&quot;src/client/pages/hello.tsx&quot;</span> }]<span class=\"hljs-string\">``</span>;\n</code></pre>\n\n                <h3 id=\"%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0\">\n                  路由组件参数\n                </h3>\n                <h4 id=\"path\">\n                  path\n                </h4><p>Type: <code>string</code></p>\n<p>能匹配本组件的路由路径，其配置方法需满足 <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 规则。</p>\n\n                <h4 id=\"exact\">\n                  exact\n                </h4><p>Type: <code>boolean | undefined</code>, Default：<code>true</code></p>\n<p>是否严格匹配路由路径，即路由和</p>\n","anchor":[{"type":"heading","raw":"## 路由组件\n\n","depth":2,"text":"路由组件","tokens":[{"type":"text","raw":"路由组件","text":"路由组件"}],"id":"#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6","children":[{"type":"heading","raw":"### 路由组件参数\n\n","depth":3,"text":"路由组件参数","tokens":[{"type":"text","raw":"路由组件参数","text":"路由组件参数"}],"id":"#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0"}]}]},{"title":"路由","path":"/joy/basic/fs-router","file":"docs/joy/02-basic/05-fs-router.md","hasMenu":false,"mdContent":"# 路由\n\n## 约定式路由\n\n约定式路由也叫文件路由，不需要手写路由配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。\n\n约定路由的存放目录`src/client/pages`或者`src/pages`，如果`src/client/pages`存在，就不会再分析`src/pages`中的路由了。\n例如：\n\n```shell\nmyapp\n  src\n    client\n      pages  # 约定路由根目录\n        index.tsx  # 首页\n        about.tsx  # 关于页面\n```\n\n等效于以下路由配置：\n\n```js\n[\n  { exact: true, path: \"/\", componentName: \"index\", componentModule: \"src/client/pages/index\" },\n  { exact: true, path: \"/\", componentName: \"about\", componentModule: require(\"src/client/pages/about\") },\n];\n```\n","htmlContent":"\n                <h1 id=\"%E8%B7%AF%E7%94%B1\">\n                  路由\n                </h1>\n                <h2 id=\"%E7%BA%A6%E5%AE%9A%E5%BC%8F%E8%B7%AF%E7%94%B1\">\n                  约定式路由\n                </h2><p>约定式路由也叫文件路由，不需要手写路由配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p>\n<p>约定路由的存放目录<code>src/client/pages</code>或者<code>src/pages</code>，如果<code>src/client/pages</code>存在，就不会再分析<code>src/pages</code>中的路由了。\n例如：</p>\n<pre><code class=\"hljs language-shell\">myapp\n  src\n    client\n      pages  # 约定路由根目录\n        index.tsx  # 首页\n        about.tsx  # 关于页面\n</code></pre>\n<p>等效于以下路由配置：</p>\n<pre><code class=\"hljs language-js\">[\n  { <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;index&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-string\">&quot;src/client/pages/index&quot;</span> },\n  { <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;about&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;src/client/pages/about&quot;</span>) },\n];\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 约定式路由\n\n","depth":2,"text":"约定式路由","tokens":[{"type":"text","raw":"约定式路由","text":"约定式路由"}],"id":"#%E7%BA%A6%E5%AE%9A%E5%BC%8F%E8%B7%AF%E7%94%B1"}]},{"title":"JOY 配置","path":"/joy/basic/joy-config","file":"docs/joy/02-basic/joy-config.md","hasMenu":false,"mdContent":"# JOY 配置\n\n## basePath\n\n类型：`string` 默认值：`\"\"`\n\n发布 Joy 应用到子路径下时，使用`basePath`设置子路径名称。 例如我们开发了一个文档应用，现将它发布到`/docs`子路径下，例如`www.mydomian.com/docs`。\n\n```typescript\n// config/config.production.ts\n// 只配置 production 环境\nexport default {\n  basePath: \"/docs\",\n};\n```\n\n> 注意：该配置值在构建编译时设置，会打包到客户端的运行包中，如果修改该值，需要重新编译。\n\n## assetPrefix\n\n类型：string，默认:`\"\"`\n\n在浏览器上运行时，加载应用资源的路径前缀。一般是在生产环境，将打包好的静态资源部署到不同的服务器（CDN，静态文件服务器）上时配置该值，而开发调试环境无需配置。 例如图片默认路径是`${basePath}/static/logo.png`，假如我们将资源部署到 CDN 上，图片的加载路径变为 CDN 的地址`https://cdn.mydomain.com/myapp/static/logo.png` ,此时我们更改`assetPrefix`为 CDN 的地址：\n\n```typescript\n// config/config.production.ts\n\nexport default {\n  assetPrefix: \"https://cdn.mydomain.com/myapp\",\n};\n```\n\n## distDir\n\n类型：`string`，默认: `\".joy\"`\n\n编译阶段输出的临时目录，你也可以设置自定义的目录名称。\n","htmlContent":"\n                <h1 id=\"joy-%E9%85%8D%E7%BD%AE\">\n                  JOY 配置\n                </h1>\n                <h2 id=\"basepath\">\n                  basePath\n                </h2><p>类型：<code>string</code> 默认值：<code>&quot;&quot;</code></p>\n<p>发布 Joy 应用到子路径下时，使用<code>basePath</code>设置子路径名称。 例如我们开发了一个文档应用，现将它发布到<code>/docs</code>子路径下，例如<code>www.mydomian.com/docs</code>。</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// config/config.production.ts</span>\n<span class=\"hljs-comment\">// 只配置 production 环境</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">basePath</span>: <span class=\"hljs-string\">&quot;/docs&quot;</span>,\n};\n</code></pre>\n<blockquote>\n<p>注意：该配置值在构建编译时设置，会打包到客户端的运行包中，如果修改该值，需要重新编译。</p>\n</blockquote>\n\n                <h2 id=\"assetprefix\">\n                  assetPrefix\n                </h2><p>类型：string，默认:<code>&quot;&quot;</code></p>\n<p>在浏览器上运行时，加载应用资源的路径前缀。一般是在生产环境，将打包好的静态资源部署到不同的服务器（CDN，静态文件服务器）上时配置该值，而开发调试环境无需配置。 例如图片默认路径是<code>${basePath}/static/logo.png</code>，假如我们将资源部署到 CDN 上，图片的加载路径变为 CDN 的地址<code>https://cdn.mydomain.com/myapp/static/logo.png</code> ,此时我们更改<code>assetPrefix</code>为 CDN 的地址：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// config/config.production.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">assetPrefix</span>: <span class=\"hljs-string\">&quot;https://cdn.mydomain.com/myapp&quot;</span>,\n};\n</code></pre>\n\n                <h2 id=\"distdir\">\n                  distDir\n                </h2><p>类型：<code>string</code>，默认: <code>&quot;.joy&quot;</code></p>\n<p>编译阶段输出的临时目录，你也可以设置自定义的目录名称。</p>\n","anchor":[{"type":"heading","raw":"## basePath\n\n","depth":2,"text":"basePath","tokens":[{"type":"text","raw":"basePath","text":"basePath"}],"id":"#basepath"},{"type":"heading","raw":"## assetPrefix\n\n","depth":2,"text":"assetPrefix","tokens":[{"type":"text","raw":"assetPrefix","text":"assetPrefix"}],"id":"#assetprefix"},{"type":"heading","raw":"## distDir\n\n","depth":2,"text":"distDir","tokens":[{"type":"text","raw":"distDir","text":"distDir"}],"id":"#distdir"}]},{"title":"React 开发","path":"/joy/basic/react-dev","file":"docs/joy/02-basic/react-dev.md","hasMenu":false,"mdContent":"# React 开发\n\n[开始React开发](/react/start/introduce)\n","htmlContent":"\n                <h1 id=\"react-%E5%BC%80%E5%8F%91\">\n                  React 开发\n                </h1><p><a href=\"/react/start/introduce\">开始React开发</a></p>\n","anchor":[]},{"title":"CSS 样式","path":"/joy/basic/style-css","file":"docs/joy/02-basic/style-css.md","hasMenu":false,"mdContent":"# CSS 样式\n\n## 应用全局样式\n\nJoy 中约定在 `src/global.css`（或`global.less` `global.sass` ）中定义全局样式，应用启动时会自动加载该样式。\n\n比如我们给应用统一设置全局样式，或者覆盖组件样式，新建文件 `src/global.css`:\n\n```css\nbody {\n  font-family: BlinkMacSystemFont, PingFang SC, Microsoft YaHei, sans-serif;\n  font-size: 14px;\n  padding: 20px 20px 60px;\n}\n\n.addButton {\n  width: 60px;\n}\n```\n\n## CSS 模块导入\n\nJoy 会对导入的 CSS 文件自动识别是否使用 CSS Modules 导入.\n\n### CSS Modules 导入\n\n[CSS Modules](https://github.com/css-modules/css-modules) 会将 css 文件内的 class 名称生成唯一的标识，从而避免不同 css 模块类相同 class 名称的冲突。 通常使用 CSS Modules 来定义组件样式，而不用担心和组件间以及全局样式的冲突。\n\n```js\n// CSS Modules\nimport styles from \"./foo.css\";\n\nexport function Button() {\n  return <button className={styles.btnAdd}>Add</button>;\n}\n```\n\n在 CSS Modules 中，也可以通过`:global { }`包裹方式，临时插入全局类样式，被包裹中的代码中定义的 CSS 类名，将不会被 CSS Modules 处理，直接输出到页面。\n例如我们自定义 header 中的菜单组件样式：\n\n```less\n// main-layout.less\n.appHeader {\n  height: 64px;\n\n  :global {\n    .ant-menu {\n      // ant-menu 是 antd <Menu /> 组件中的常量类名。\n      border: 0;\n    }\n  }\n}\n```\n\n### 全局样式导入\n\n非 CSS Modules 方式导入，css 文件内定义的类样式为全局样式，将会控制页面中所有满足条件的 DOM 元素。\n\n```js\n// 非 CSS Modules\nimport \"./foo.css\";\n\nexport function Button() {\n  return <button className=\"btnAdd\">New</button>;\n}\n\n// 非 CSS Modules, bar.css内定义的样式为全局样式，将会控制页面中所有满足条件的DOM元素。\nimport \"./bar.css\";\n```\n\n## 使用 LESS\n\nJoy 原生支持 Less，使用 `.less` 后缀名定义 Less 文件。在使用 Less 之前，需要先安装 [less](https://github.com/less/less.js):\n\n```bash\nnpm install less\n```\n\n### 自定义 LESS 配置\n\n在 `joy.config.js` 的 `lessOptions` 字段中定义 Less 的自定义配置, 具体可配置项参考 [less-loader](https://webpack.js.org/loaders/less-loader/) 的配置。\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  lessOptions: {\n    strictMath: true,\n  },\n};\n```\n\n## 使用 Sass\n\nJoy 原生支持 Sass，使用 `.scss` 或 `.sass` 后缀名定义 Sass 文件，在使用 Sass 之前，需要先安装 [sass](https://github.com/sass/sass) :\n\n```bash\nnpm install sass\n```\n\n> Sass 支持 2 种语法格式定义来样式，`.scss`文件使用[SCSS 语法](https://sass-lang.com/documentation/syntax#scss) ，`.sass`文件使用 [Indented Syntax (\"Sass\")](https://sass-lang.com/documentation/syntax#the-indented-syntax) 语法。\n> 如果你不确定使用哪种语法，可首先采用`.scss`，它是 CSS 的扩展，可使用 CSS 的全部语法，不需要学习新的 Indented Syntax 缩进语法。\n\n### 自定义 Sass 配置\n\n在 `joy.config.js` 的 `sassOptions` 字段中定义 Sass 的自定义配置, 具体可配置项参考 [sass-loader](https://webpack.js.org/loaders/sass-loader/) 的配置。\n\n```js\nconst path = require(\"path\");\n\nmodule.exports = {\n  sassOptions: {\n    additionalData: \"$env: \" + process.env.NODE_ENV + \";\",\n    indentWidth: 4,\n    includePaths: [\"/absolute/path/a\", \"/absolute/path/b\"],\n  },\n};\n```\n\n### Sass 变量\n\nJoy 支持 Sass 变量从 CSS Module 文件中导出。比如导出`primaryColor`变量：\n\n```scss\n/* index-scss-variables.scss */\n$primary-color: #ff0000;\n\n:export {\n  primaryColor: $primary-color;\n}\n```\n\n```tsx\n// index-scss-variables.js\nimport variables from \"../index-scss-variables.scss\";\n\nexport default function MyApp({ Component, pageProps }) {\n  return <div style={{ color: variables.primaryColor }}>Hello</div>;\n}\n```\n\n## todo\n\n- 自定义 PostCss https://nextjs.org/docs/advanced-features/customizing-postcss-config\n","htmlContent":"\n                <h1 id=\"css-%E6%A0%B7%E5%BC%8F\">\n                  CSS 样式\n                </h1>\n                <h2 id=\"%E5%BA%94%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F\">\n                  应用全局样式\n                </h2><p>Joy 中约定在 <code>src/global.css</code>（或<code>global.less</code> <code>global.sass</code> ）中定义全局样式，应用启动时会自动加载该样式。</p>\n<p>比如我们给应用统一设置全局样式，或者覆盖组件样式，新建文件 <code>src/global.css</code>:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">font-family</span>: BlinkMacSystemFont, PingFang SC, Microsoft YaHei, sans-serif;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;\n  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">60px</span>;\n}\n\n<span class=\"hljs-selector-class\">.addButton</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;\n}\n</code></pre>\n\n                <h2 id=\"css-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5\">\n                  CSS 模块导入\n                </h2><p>Joy 会对导入的 CSS 文件自动识别是否使用 CSS Modules 导入.</p>\n\n                <h3 id=\"css-modules-%E5%AF%BC%E5%85%A5\">\n                  CSS Modules 导入\n                </h3><p><a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a> 会将 css 文件内的 class 名称生成唯一的标识，从而避免不同 css 模块类相同 class 名称的冲突。 通常使用 CSS Modules 来定义组件样式，而不用担心和组件间以及全局样式的冲突。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CSS Modules</span>\n<span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./foo.css&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{styles.btnAdd}</span>&gt;</span>Add<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p>在 CSS Modules 中，也可以通过<code>:global { }</code>包裹方式，临时插入全局类样式，被包裹中的代码中定义的 CSS 类名，将不会被 CSS Modules 处理，直接输出到页面。\n例如我们自定义 header 中的菜单组件样式：</p>\n<pre><code class=\"hljs language-less\"><span class=\"hljs-comment\">// main-layout.less</span>\n<span class=\"hljs-selector-class\">.appHeader</span> {\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">64px</span>;\n\n  :<span class=\"hljs-selector-tag\">global</span> {\n    <span class=\"hljs-selector-class\">.ant-menu</span> {\n      <span class=\"hljs-comment\">// ant-menu 是 antd &lt;Menu /&gt; 组件中的常量类名。</span>\n      <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">0</span>;\n    }\n  }\n}\n</code></pre>\n\n                <h3 id=\"%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5\">\n                  全局样式导入\n                </h3><p>非 CSS Modules 方式导入，css 文件内定义的类样式为全局样式，将会控制页面中所有满足条件的 DOM 元素。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 非 CSS Modules</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./foo.css&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;btnAdd&quot;</span>&gt;</span>New<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;\n}\n\n<span class=\"hljs-comment\">// 非 CSS Modules, bar.css内定义的样式为全局样式，将会控制页面中所有满足条件的DOM元素。</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./bar.css&quot;</span>;\n</code></pre>\n\n                <h2 id=\"%E4%BD%BF%E7%94%A8-less\">\n                  使用 LESS\n                </h2><p>Joy 原生支持 Less，使用 <code>.less</code> 后缀名定义 Less 文件。在使用 Less 之前，需要先安装 <a href=\"https://github.com/less/less.js\">less</a>:</p>\n<pre><code class=\"hljs language-bash\">npm install less\n</code></pre>\n\n                <h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-less-%E9%85%8D%E7%BD%AE\">\n                  自定义 LESS 配置\n                </h3><p>在 <code>joy.config.js</code> 的 <code>lessOptions</code> 字段中定义 Less 的自定义配置, 具体可配置项参考 <a href=\"https://webpack.js.org/loaders/less-loader/\">less-loader</a> 的配置。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">lessOptions</span>: {\n    <span class=\"hljs-attr\">strictMath</span>: <span class=\"hljs-literal\">true</span>,\n  },\n};\n</code></pre>\n\n                <h2 id=\"%E4%BD%BF%E7%94%A8-sass\">\n                  使用 Sass\n                </h2><p>Joy 原生支持 Sass，使用 <code>.scss</code> 或 <code>.sass</code> 后缀名定义 Sass 文件，在使用 Sass 之前，需要先安装 <a href=\"https://github.com/sass/sass\">sass</a> :</p>\n<pre><code class=\"hljs language-bash\">npm install sass\n</code></pre>\n<blockquote>\n<p>Sass 支持 2 种语法格式定义来样式，<code>.scss</code>文件使用<a href=\"https://sass-lang.com/documentation/syntax#scss\">SCSS 语法</a> ，<code>.sass</code>文件使用 <a href=\"https://sass-lang.com/documentation/syntax#the-indented-syntax\">Indented Syntax (&quot;Sass&quot;)</a> 语法。\n如果你不确定使用哪种语法，可首先采用<code>.scss</code>，它是 CSS 的扩展，可使用 CSS 的全部语法，不需要学习新的 Indented Syntax 缩进语法。</p>\n</blockquote>\n\n                <h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-sass-%E9%85%8D%E7%BD%AE\">\n                  自定义 Sass 配置\n                </h3><p>在 <code>joy.config.js</code> 的 <code>sassOptions</code> 字段中定义 Sass 的自定义配置, 具体可配置项参考 <a href=\"https://webpack.js.org/loaders/sass-loader/\">sass-loader</a> 的配置。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">sassOptions</span>: {\n    <span class=\"hljs-attr\">additionalData</span>: <span class=\"hljs-string\">&quot;$env: &quot;</span> + process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> + <span class=\"hljs-string\">&quot;;&quot;</span>,\n    <span class=\"hljs-attr\">indentWidth</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">includePaths</span>: [<span class=\"hljs-string\">&quot;/absolute/path/a&quot;</span>, <span class=\"hljs-string\">&quot;/absolute/path/b&quot;</span>],\n  },\n};\n</code></pre>\n\n                <h3 id=\"sass-%E5%8F%98%E9%87%8F\">\n                  Sass 变量\n                </h3><p>Joy 支持 Sass 变量从 CSS Module 文件中导出。比如导出<code>primaryColor</code>变量：</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-comment\">/* index-scss-variables.scss */</span>\n<span class=\"hljs-variable\">$primary-color</span>: <span class=\"hljs-number\">#ff0000</span>;\n\n:export {\n  primaryColor: <span class=\"hljs-variable\">$primary-color</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// index-scss-variables.js</span>\n<span class=\"hljs-keyword\">import</span> variables <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../index-scss-variables.scss&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyApp</span>(<span class=\"hljs-params\">{ Component, pageProps }</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">variables.primaryColor</span> }}&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n}\n</code></pre>\n\n                <h2 id=\"todo\">\n                  todo\n                </h2><ul>\n<li>自定义 PostCss <a href=\"https://nextjs.org/docs/advanced-features/customizing-postcss-config\">https://nextjs.org/docs/advanced-features/customizing-postcss-config</a></li>\n</ul>\n","anchor":[{"type":"heading","raw":"## 应用全局样式\n\n","depth":2,"text":"应用全局样式","tokens":[{"type":"text","raw":"应用全局样式","text":"应用全局样式"}],"id":"#%E5%BA%94%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F"},{"type":"heading","raw":"## CSS 模块导入\n\n","depth":2,"text":"CSS 模块导入","tokens":[{"type":"text","raw":"CSS 模块导入","text":"CSS 模块导入"}],"id":"#css-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5","children":[{"type":"heading","raw":"### CSS Modules 导入\n\n","depth":3,"text":"CSS Modules 导入","tokens":[{"type":"text","raw":"CSS Modules 导入","text":"CSS Modules 导入"}],"id":"#css-modules-%E5%AF%BC%E5%85%A5"},{"type":"heading","raw":"### 全局样式导入\n\n","depth":3,"text":"全局样式导入","tokens":[{"type":"text","raw":"全局样式导入","text":"全局样式导入"}],"id":"#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5"}]},{"type":"heading","raw":"## 使用 LESS\n\n","depth":2,"text":"使用 LESS","tokens":[{"type":"text","raw":"使用 LESS","text":"使用 LESS"}],"id":"#%E4%BD%BF%E7%94%A8-less","children":[{"type":"heading","raw":"### 自定义 LESS 配置\n\n","depth":3,"text":"自定义 LESS 配置","tokens":[{"type":"text","raw":"自定义 LESS 配置","text":"自定义 LESS 配置"}],"id":"#%E8%87%AA%E5%AE%9A%E4%B9%89-less-%E9%85%8D%E7%BD%AE"}]},{"type":"heading","raw":"## 使用 Sass\n\n","depth":2,"text":"使用 Sass","tokens":[{"type":"text","raw":"使用 Sass","text":"使用 Sass"}],"id":"#%E4%BD%BF%E7%94%A8-sass","children":[{"type":"heading","raw":"### 自定义 Sass 配置\n\n","depth":3,"text":"自定义 Sass 配置","tokens":[{"type":"text","raw":"自定义 Sass 配置","text":"自定义 Sass 配置"}],"id":"#%E8%87%AA%E5%AE%9A%E4%B9%89-sass-%E9%85%8D%E7%BD%AE"},{"type":"heading","raw":"### Sass 变量\n\n","depth":3,"text":"Sass 变量","tokens":[{"type":"text","raw":"Sass 变量","text":"Sass 变量"}],"id":"#sass-%E5%8F%98%E9%87%8F"}]},{"type":"heading","raw":"## todo\n\n","depth":2,"text":"todo","tokens":[{"type":"text","raw":"todo","text":"todo"}],"id":"#todo"}]}]},{"title":"高级使用","path":"/joy/03-advanced-features","file":"docs/joy/03-advanced-features","children":[{"title":"自定义 App","path":"/joy/advanced-features/custom-app","file":"docs/joy/03-advanced-features/custom-app.md","hasMenu":false,"mdContent":"# 自定义 App\n\nJoy 使用`App`来包装和初始化整个界面，我们可以自定它来控制页面的初始化，例如：\n\n- 添加所有页面共有的布局。\n- 捕获渲染错误，使用`componentDidCatch`。\n- 修改路由或者路由的渲染方式。\n- 添加全局样式。\n\n我们开始覆盖默认的`App`， 创建文件`./src/pages/_app.tsx`，修改其内容：\n\n```tsx\nimport React from \"react\";\nimport { IReactApplication, ReactRouterService, RouteSwitch } from \"@symph/react\";\nimport { ReactAppProps } from \"@symph/joy\";\n\nexport default class App extends React.Component<ReactAppProps, any> {\n  protected reactRouterService: ReactRouterService;\n  constructor(props: ReactAppProps, context?: any) {\n    super(props, context);\n    const appContext = props.appContext;\n    this.reactRouterService = appContext.getSync<ReactRouterService>(\"reactRouterService\");\n  }\n  render() {\n    const routes = this.reactRouterService.getRoutes() || [];\n    return <RouteSwitch routes={routes} extraProps={{}} />;\n  }\n}\n```\n\n`App` 的`props`中包含了`IReactApplication`实例，我们可以通过它获取到整个 React 应用的业务组件，例如上面例子中的`reactRouterService`路由组件。\n`render()`中使用的`RouteSwitch`组件来渲染应用中注册的路由，包括文件约定路由。\n\n## 注意事项：\n\n- 如果你的应用正在开发模式下运行中，首次添加`./src/pages/_app.js`文件，需要重新启动开发服务器。\n- `App`在服务端和浏览器上都会被渲染，所以不能在这里使用`Node.js`特有的 API。\n","htmlContent":"\n                <h1 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-app\">\n                  自定义 App\n                </h1><p>Joy 使用<code>App</code>来包装和初始化整个界面，我们可以自定它来控制页面的初始化，例如：</p>\n<ul>\n<li>添加所有页面共有的布局。</li>\n<li>捕获渲染错误，使用<code>componentDidCatch</code>。</li>\n<li>修改路由或者路由的渲染方式。</li>\n<li>添加全局样式。</li>\n</ul>\n<p>我们开始覆盖默认的<code>App</code>， 创建文件<code>./src/pages/_app.tsx</code>，修改其内容：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { IReactApplication, <span class=\"hljs-title class_\">ReactRouterService</span>, <span class=\"hljs-title class_\">RouteSwitch</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactAppProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span>&lt;<span class=\"hljs-title class_\">ReactAppProps</span>, <span class=\"hljs-built_in\">any</span>&gt; {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-attr\">reactRouterService</span>: <span class=\"hljs-title class_\">ReactRouterService</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props: ReactAppProps, context?: <span class=\"hljs-built_in\">any</span></span>) {\n    <span class=\"hljs-variable language_\">super</span>(props, context);\n    <span class=\"hljs-keyword\">const</span> appContext = props.<span class=\"hljs-property\">appContext</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reactRouterService</span> = appContext.<span class=\"hljs-property\">getSync</span>&lt;<span class=\"hljs-title class_\">ReactRouterService</span>&gt;(<span class=\"hljs-string\">&quot;reactRouterService&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> routes = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reactRouterService</span>.<span class=\"hljs-title function_\">getRoutes</span>() || [];\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RouteSwitch</span> <span class=\"hljs-attr\">routes</span>=<span class=\"hljs-string\">{routes}</span> <span class=\"hljs-attr\">extraProps</span>=<span class=\"hljs-string\">{{}}</span> /&gt;</span></span>;\n  }\n}\n</code></pre>\n<p><code>App</code> 的<code>props</code>中包含了<code>IReactApplication</code>实例，我们可以通过它获取到整个 React 应用的业务组件，例如上面例子中的<code>reactRouterService</code>路由组件。\n<code>render()</code>中使用的<code>RouteSwitch</code>组件来渲染应用中注册的路由，包括文件约定路由。</p>\n\n                <h2 id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A\">\n                  注意事项：\n                </h2><ul>\n<li>如果你的应用正在开发模式下运行中，首次添加<code>./src/pages/_app.js</code>文件，需要重新启动开发服务器。</li>\n<li><code>App</code>在服务端和浏览器上都会被渲染，所以不能在这里使用<code>Node.js</code>特有的 API。</li>\n</ul>\n","anchor":[{"type":"heading","raw":"## 注意事项：\n\n","depth":2,"text":"注意事项：","tokens":[{"type":"text","raw":"注意事项：","text":"注意事项："}],"id":"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"}]},{"title":"自定义 Document","path":"/joy/advanced-features/custom-document","file":"docs/joy/03-advanced-features/custom-document.md","hasMenu":false,"mdContent":"# 自定义 Document\n\n`Document` React 组件用于生成页面的`<html>`和`<body>`标签， Joy 会根据应用内的组件和样式，自动生成必须的 js 和 css 标签，保证页面 html 能够正常被加载。\n我们可以通过自定义`Document`在`<html>`加入自定义的扩展`<head>`、`<link>`或者`<sciprt>`。\n\n覆盖默认的`Document`，创建文件`./src/pages/_document.tsx`并修改`Document`如下：\n\n```tsx\nimport React from \"react\";\nimport Document, { Html, Head, Main, JoyScript, DocumentContext } from \"@symph/joy/document\";\n\nexport default class MyDocument extends Document<any> {\n  static async getInitialProps(ctx: DocumentContext) {\n    const initialProps = await Document.getInitialProps(ctx);\n    return { ...initialProps };\n  }\n\n  render() {\n    return (\n      <Html>\n        <Head></Head>\n        <body>\n          <Main />\n          <JoyScript />\n        </body>\n      </Html>\n    );\n  }\n}\n```\n\n> 上面示例中的`MyDocument`，等效于 Joy 默认的`Document`，未加入自定义的内容，如果不需要`getInitialProps`或者`render`方法，可以删除掉。\n\n`Html`、`Head`、`Main`和`JoyScript`是页面必须的，在自定义的`Document`类中，不要删除它们和更改顺序。\n但它们支持一些自定义的属性，例如：\n\n```tsx\n<Html lang=\"en\">\n```\n\n这里的`<Head />`不同于`@symph/joy/react`中的`Head`组件，这里的`<Head />`用于定义在所有页面中共有的`<head>`元素，而其它的，例如`<title>`标签，建议在页面组件中使用`@symph/joy/react`中的`Head`组件来定义。\n\n`getInitialProps`方法返回`Document`组件的初始 props，参数`ctx: DocumentContext`具有以下属性：\n\n- `pathname`：`string`，当前渲染的页面路径。\n- `query`： `object`， url 中的请求参数被解析后的对象。\n- `req`：[`IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage), 触发当前渲染的请求对象。\n- `res`：[`ServerResponse`](https://nodejs.org/api/http.html#http_class_http_serverresponse), 触发当前渲染的请求的响应对象。\n- `err` ：Error, 在渲染阶段出现的异常。\n- `renderPage`: `functin` 将`App`渲染为 html 字符串，返回值`{html, head}`在服务端渲染时。\n\n## 注意事项\n\n- `Document`只在服务端被渲染，事件处理并不会触发执行，例如`onClick`事件。同理 React 的部分生命周期也不会执行，例如`onComponentDidMount`。\n- 在`<Main/>`之外的 React 组件并不会被浏览器初始化，所以不要在这里添加任何业务逻辑。如果需要给整个应用添加统一的组件，可以在根布局组件中添加，或者`App`中添加。\n","htmlContent":"\n                <h1 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-document\">\n                  自定义 Document\n                </h1><p><code>Document</code> React 组件用于生成页面的<code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>标签， Joy 会根据应用内的组件和样式，自动生成必须的 js 和 css 标签，保证页面 html 能够正常被加载。\n我们可以通过自定义<code>Document</code>在<code>&lt;html&gt;</code>加入自定义的扩展<code>&lt;head&gt;</code>、<code>&lt;link&gt;</code>或者<code>&lt;sciprt&gt;</code>。</p>\n<p>覆盖默认的<code>Document</code>，创建文件<code>./src/pages/_document.tsx</code>并修改<code>Document</code>如下：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Document</span>, { <span class=\"hljs-title class_\">Html</span>, <span class=\"hljs-title class_\">Head</span>, <span class=\"hljs-title class_\">Main</span>, <span class=\"hljs-title class_\">JoyScript</span>, <span class=\"hljs-title class_\">DocumentContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/document&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDocument</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Document</span>&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getInitialProps</span>(<span class=\"hljs-params\">ctx: DocumentContext</span>) {\n    <span class=\"hljs-keyword\">const</span> initialProps = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Document</span>.<span class=\"hljs-title function_\">getInitialProps</span>(ctx);\n    <span class=\"hljs-keyword\">return</span> { ...initialProps };\n  }\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Html</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Main</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">JoyScript</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Html</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<blockquote>\n<p>上面示例中的<code>MyDocument</code>，等效于 Joy 默认的<code>Document</code>，未加入自定义的内容，如果不需要<code>getInitialProps</code>或者<code>render</code>方法，可以删除掉。</p>\n</blockquote>\n<p><code>Html</code>、<code>Head</code>、<code>Main</code>和<code>JoyScript</code>是页面必须的，在自定义的<code>Document</code>类中，不要删除它们和更改顺序。\n但它们支持一些自定义的属性，例如：</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Html</span> lang=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;\n</code></pre>\n<p>这里的<code>&lt;Head /&gt;</code>不同于<code>@symph/joy/react</code>中的<code>Head</code>组件，这里的<code>&lt;Head /&gt;</code>用于定义在所有页面中共有的<code>&lt;head&gt;</code>元素，而其它的，例如<code>&lt;title&gt;</code>标签，建议在页面组件中使用<code>@symph/joy/react</code>中的<code>Head</code>组件来定义。</p>\n<p><code>getInitialProps</code>方法返回<code>Document</code>组件的初始 props，参数<code>ctx: DocumentContext</code>具有以下属性：</p>\n<ul>\n<li><code>pathname</code>：<code>string</code>，当前渲染的页面路径。</li>\n<li><code>query</code>： <code>object</code>， url 中的请求参数被解析后的对象。</li>\n<li><code>req</code>：<a href=\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\"><code>IncomingMessage</code></a>, 触发当前渲染的请求对象。</li>\n<li><code>res</code>：<a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\"><code>ServerResponse</code></a>, 触发当前渲染的请求的响应对象。</li>\n<li><code>err</code> ：Error, 在渲染阶段出现的异常。</li>\n<li><code>renderPage</code>: <code>functin</code> 将<code>App</code>渲染为 html 字符串，返回值<code>{html, head}</code>在服务端渲染时。</li>\n</ul>\n\n                <h2 id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">\n                  注意事项\n                </h2><ul>\n<li><code>Document</code>只在服务端被渲染，事件处理并不会触发执行，例如<code>onClick</code>事件。同理 React 的部分生命周期也不会执行，例如<code>onComponentDidMount</code>。</li>\n<li>在<code>&lt;Main/&gt;</code>之外的 React 组件并不会被浏览器初始化，所以不要在这里添加任何业务逻辑。如果需要给整个应用添加统一的组件，可以在根布局组件中添加，或者<code>App</code>中添加。</li>\n</ul>\n","anchor":[{"type":"heading","raw":"## 注意事项\n\n","depth":2,"text":"注意事项","tokens":[{"type":"text","raw":"注意事项","text":"注意事项"}],"id":"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"}]}]}],"defaultOpenKeys":["/docs/joy/01-start","/docs/joy/02-basic","/docs/joy/03-advanced-features"]}},{"type":"reactAppInitManager/__SET_STATE","state":{"/joy":{"pathname":"/joy","index":false,"initStatic":2}}}]},{"pathname":"/joy/advanced-features/custom-app","ssgData":[{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadCurrentDocErr":{"code":404,"message":"文档不存在。"},"loadingCurrentDoc":false}},{"type":"reactAppInitManager/__SET_STATE","state":{"/joy/advanced-features/custom-app":{"pathname":"/joy/advanced-features/custom-app","index":false,"initStatic":2}}}]}]