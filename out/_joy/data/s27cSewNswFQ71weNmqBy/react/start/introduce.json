[{"pathname":"INIT@/react/start/introduce","ssgData":[{"type":"__INIT_MODEL","state":{"noop":{},"reactAppInitManager":{},"layoutModel":{"collapsed":true,"isMobile":false},"docsModel":{"loadingCurrentDoc":false,"docMenus":[],"titleTrees":[],"result":[],"openKeys":[],"snippets":{},"defaultOpenKeys":[]}}}]},{"pathname":"/","ssgData":[{"type":"reactAppInitManager/__SET_STATE","state":{"/":{"pathname":"/","index":false,"initStatic":2}}}]},{"pathname":"/react","ssgData":[{"type":"docsModel/__SET_STATE","state":{"docMenus":[{"title":"介绍","path":"/react/01-start","file":"docs/react/01-start","children":[{"title":"@symph/react","path":"/react/start/introduce","file":"docs/react/01-start/01-introduce.md","hasMenu":false,"mdContent":"# @symph/react\n\nReact 应用框架\n\n","htmlContent":"\n                <h1 id=\"symph%2Freact\">\n                  @symph/react\n                </h1><p>React 应用框架</p>\n","anchor":[]},{"title":"快速开始","path":"/react/start/quick-started","file":"docs/react/01-start/02-quick-started.md","hasMenu":false,"mdContent":"# 快速开始\n\nJoy 支持 React、Node 或者前后端混合应用开发，这里以一个简单的 React 应用为例，介绍如何快速开始开发。\n\n## 环境准备\n\n- node 建议 12 或以上版本，推荐使用 nvm 来管理 node 版本。\n\n- 推荐使用 yarn 管理依赖，国内使用 [阿里 npm 源](https://npmmirror.com/) registry: https://registry.npm.taobao.org\n\n```shell\n# 安装 yarn\n$ npm i yarn -g\n# 手动设置`registry`地址为国内源\n$ yarn config set registry https://registry.npm.taobao.org\n# 查看源\n$ yarn config get registry\n\n# 或者使用 tyarn\n$ npm i yarn tyarn -g\n# 后面文档里的 yarn 换成 tyarn\n$ tyarn -v\n```\n\n## 创建目录\n\n创建应用根目录\n\n```shell\n$ mkdir myapp && cd myapp\n```\n\n创建应用内目录和文件，目录结构如下：\n\n```shell\nmyapp\n  src  # 源代码目录\n    pages  # 约定React路由目录\n      index.tsx  # 第一个页面\n  package.json\n```\n\n- 在 package.json 内声明应用名和依赖：\n\n```json\n{\n  \"name\": \"myapp\",\n  \"version\": \"v1.0.0\",\n  \"scripts\": {\n    \"dev\": \"joy dev\",\n    \"export\": \"joy build&&joy export\"\n  },\n  \"dependencies\": {\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n    \"@symph/joy\": \"^2.0.0\"\n  }\n}\n```\n\n- 创建第一个路由页面`index.tsx`, Joy 同时支持 ES6 和 Typescript 语法，如果使用 ES6，创建 JS 文件`index.jsx`，添加页面展现内容:\n\n```tsx\n// src/pages/index.tsx\nimport React from \"react\";\nimport { ReactController, BaseReactController } from \"@symph/react\";\n\n@ReactController()\nexport default class Index extends BaseReactController {\n  renderView() {\n    return <p>Hello Joy!</p>;\n  }\n}\n```\n\n## 安装依赖\n\n```shell\n$ yarn install\n```\n\n## 启动开发服务器\n\n```shell\n$ yarn dev\n```\n\n当命令行输出`ready - started server on http://localhost:3000`时，开发服务器启动成功，打开浏览器输入地址 `http://localhost:3000`，即可看到我们的第一个页面`Hello Joy!`。\n若此时修改页面内容`Hello Joy!`为`Hello MyApp`，然后保存文件，浏览器界面将自动更新为新内容。\n\n## 部署发布\n\n### 构建\n\n```shell\n$ yarn export\n```\n\n构建产物默认生成到 ./out 下，目录结构类似于：\n\n```shell\n./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n```\n\n### 本地验证\n\n使用`http-server`启动本地静态文件服务器\n\n```shell\n# 安装 http-server\n$ npm i -g http-server\n\n# 启动服务器\n$ http-server ./out\n```\n\n在浏览器上打开地址：[http://127.0.0.1:8080](http://127.0.0.1:8080), 正常情况下应该是和`yarn dev`开发运行时是一致的。\n\n### 部署\n\n本地验证完成后，将`out`目录部署到服务器上即可。\n","htmlContent":"\n                <h1 id=\"%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\">\n                  快速开始\n                </h1><p>Joy 支持 React、Node 或者前后端混合应用开发，这里以一个简单的 React 应用为例，介绍如何快速开始开发。</p>\n\n                <h2 id=\"%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\">\n                  环境准备\n                </h2><ul>\n<li><p>node 建议 12 或以上版本，推荐使用 nvm 来管理 node 版本。</p>\n</li>\n<li><p>推荐使用 yarn 管理依赖，国内使用 <a href=\"https://npmmirror.com/\">阿里 npm 源</a> registry: <a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a></p>\n</li>\n</ul>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">安装 yarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i yarn -g</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">手动设置`registry`地址为国内源</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">查看源</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn config get registry</span>\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">或者使用 tyarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i yarn tyarn -g</span>\n<span class=\"hljs-meta\"># </span><span class=\"language-bash\">后面文档里的 yarn 换成 tyarn</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">tyarn -v</span>\n</code></pre>\n\n                <h2 id=\"%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95\">\n                  创建目录\n                </h2><p>创建应用根目录</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> myapp &amp;&amp; <span class=\"hljs-built_in\">cd</span> myapp</span>\n</code></pre>\n<p>创建应用内目录和文件，目录结构如下：</p>\n<pre><code class=\"hljs language-shell\">myapp\n  src  # 源代码目录\n    pages  # 约定React路由目录\n      index.tsx  # 第一个页面\n  package.json\n</code></pre>\n<ul>\n<li>在 package.json 内声明应用名和依赖：</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;myapp&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;v1.0.0&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy dev&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;export&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy build&amp;&amp;joy export&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;react&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;react-dom&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;@symph/joy&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^2.0.0&quot;</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<ul>\n<li>创建第一个路由页面<code>index.tsx</code>, Joy 同时支持 ES6 和 Typescript 语法，如果使用 ES6，创建 JS 文件<code>index.jsx</code>，添加页面展现内容:</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/pages/index.tsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Index</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello Joy!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n\n                <h2 id=\"%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\">\n                  安装依赖\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn install</span>\n</code></pre>\n\n                <h2 id=\"%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\">\n                  启动开发服务器\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn dev</span>\n</code></pre>\n<p>当命令行输出<code>ready - started server on http://localhost:3000</code>时，开发服务器启动成功，打开浏览器输入地址 <code>http://localhost:3000</code>，即可看到我们的第一个页面<code>Hello Joy!</code>。\n若此时修改页面内容<code>Hello Joy!</code>为<code>Hello MyApp</code>，然后保存文件，浏览器界面将自动更新为新内容。</p>\n\n                <h2 id=\"%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83\">\n                  部署发布\n                </h2>\n                <h3 id=\"%E6%9E%84%E5%BB%BA\">\n                  构建\n                </h3><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\">$ </span><span class=\"language-bash\">yarn <span class=\"hljs-built_in\">export</span></span>\n</code></pre>\n<p>构建产物默认生成到 ./out 下，目录结构类似于：</p>\n<pre><code class=\"hljs language-shell\">./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n</code></pre>\n\n                <h3 id=\"%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81\">\n                  本地验证\n                </h3><p>使用<code>http-server</code>启动本地静态文件服务器</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta\"># </span><span class=\"language-bash\">安装 http-server</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">npm i -g http-server</span>\n<span class=\"hljs-meta\">\n# </span><span class=\"language-bash\">启动服务器</span>\n<span class=\"hljs-meta\">$ </span><span class=\"language-bash\">http-server ./out</span>\n</code></pre>\n<p>在浏览器上打开地址：<a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>, 正常情况下应该是和<code>yarn dev</code>开发运行时是一致的。</p>\n\n                <h3 id=\"%E9%83%A8%E7%BD%B2\">\n                  部署\n                </h3><p>本地验证完成后，将<code>out</code>目录部署到服务器上即可。</p>\n","anchor":[{"type":"heading","raw":"## 环境准备\n\n","depth":2,"text":"环境准备","tokens":[{"type":"text","raw":"环境准备","text":"环境准备"}],"id":"#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"},{"type":"heading","raw":"## 创建目录\n\n","depth":2,"text":"创建目录","tokens":[{"type":"text","raw":"创建目录","text":"创建目录"}],"id":"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"## 安装依赖\n\n","depth":2,"text":"安装依赖","tokens":[{"type":"text","raw":"安装依赖","text":"安装依赖"}],"id":"#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"},{"type":"heading","raw":"## 启动开发服务器\n\n","depth":2,"text":"启动开发服务器","tokens":[{"type":"text","raw":"启动开发服务器","text":"启动开发服务器"}],"id":"#%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"},{"type":"heading","raw":"## 部署发布\n\n","depth":2,"text":"部署发布","tokens":[{"type":"text","raw":"部署发布","text":"部署发布"}],"id":"#%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83","children":[{"type":"heading","raw":"### 构建\n\n","depth":3,"text":"构建","tokens":[{"type":"text","raw":"构建","text":"构建"}],"id":"#%E6%9E%84%E5%BB%BA"},{"type":"heading","raw":"### 本地验证\n\n","depth":3,"text":"本地验证","tokens":[{"type":"text","raw":"本地验证","text":"本地验证"}],"id":"#%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81"},{"type":"heading","raw":"### 部署\n\n","depth":3,"text":"部署","tokens":[{"type":"text","raw":"部署","text":"部署"}],"id":"#%E9%83%A8%E7%BD%B2"}]}]}]},{"title":"基础使用","path":"/react/02-basic","file":"docs/react/02-basic","children":[{"title":"React 路由","path":"/react/basic/react-router","file":"docs/react/02-basic/04-react-router.md","hasMenu":false,"mdContent":"# React 路由\n\nJoy React 应用是单页面应用(SPA)，单页面应用是加载单个 HTML 页面并在用户与应用程序交互时动态的更新该页面，而更新工作就由路由模块来完成，不同的页面由不同的的组件构成，页面切换也就是组件的切换。\n\n> 路由模块底层封装自 [react reactRouterService](https://reactrouter.com/)，其核心概念和用法可以兼容，我们可以直接采用 react reactRouterService 官方文档中描述的方法来定义路由。\n\n## 路由组件\n\n使用`@ReactRoute`装饰器将`ReactController`申明为一个路由组件，路由组件在 Joy 启动时将被自动扫描和加载。\n即创建`src/client/pages/hello.tsx`文件，启动`joy dev`，浏览`http://localhost:300/hello` 即可访问到我们的页面。\n\n```tsx\n// src/client/pages/hello.tsx\n\nimport React from \"react\";\nimport { ReactController, BaseReactController, ReactRoute } from \"@symph/react\";\n\n@ReactRoute({ path: \"/hello\" })\n@ReactController()\nexport default class HelloController extends BaseReactController {\n  renderView() {\n    return <div data-testid=\"hello\">Hello</div>;\n  }\n}\n```\n\n等效于以下路由配置：\n\n```js\n[{ exact: true, path: \"/hello\", componentName: \"helloController\", componentModule: \"src/client/pages/hello.tsx\" }]``;\n```\n\n### 路由组件参数\n\n#### path\n\nType: `string`\n\n能匹配本组件的路由路径，其配置方法需满足 [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 规则。\n\n#### exact\n\nType: `boolean | undefined`, Default：`true`\n\n是否严格匹配路由路径，即路由和\n","htmlContent":"\n                <h1 id=\"react-%E8%B7%AF%E7%94%B1\">\n                  React 路由\n                </h1><p>Joy React 应用是单页面应用(SPA)，单页面应用是加载单个 HTML 页面并在用户与应用程序交互时动态的更新该页面，而更新工作就由路由模块来完成，不同的页面由不同的的组件构成，页面切换也就是组件的切换。</p>\n<blockquote>\n<p>路由模块底层封装自 <a href=\"https://reactrouter.com/\">react reactRouterService</a>，其核心概念和用法可以兼容，我们可以直接采用 react reactRouterService 官方文档中描述的方法来定义路由。</p>\n</blockquote>\n\n                <h2 id=\"%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6\">\n                  路由组件\n                </h2><p>使用<code>@ReactRoute</code>装饰器将<code>ReactController</code>申明为一个路由组件，路由组件在 Joy 启动时将被自动扫描和加载。\n即创建<code>src/client/pages/hello.tsx</code>文件，启动<code>joy dev</code>，浏览<code>http://localhost:300/hello</code> 即可访问到我们的页面。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/client/pages/hello.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/hello&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-testid</span>=<span class=\"hljs-string\">&quot;hello&quot;</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<p>等效于以下路由配置：</p>\n<pre><code class=\"hljs language-js\">[{ <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/hello&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;helloController&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-string\">&quot;src/client/pages/hello.tsx&quot;</span> }]<span class=\"hljs-string\">``</span>;\n</code></pre>\n\n                <h3 id=\"%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0\">\n                  路由组件参数\n                </h3>\n                <h4 id=\"path\">\n                  path\n                </h4><p>Type: <code>string</code></p>\n<p>能匹配本组件的路由路径，其配置方法需满足 <a href=\"https://github.com/pillarjs/path-to-regexp\">path-to-regexp</a> 规则。</p>\n\n                <h4 id=\"exact\">\n                  exact\n                </h4><p>Type: <code>boolean | undefined</code>, Default：<code>true</code></p>\n<p>是否严格匹配路由路径，即路由和</p>\n","anchor":[{"type":"heading","raw":"## 路由组件\n\n","depth":2,"text":"路由组件","tokens":[{"type":"text","raw":"路由组件","text":"路由组件"}],"id":"#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6","children":[{"type":"heading","raw":"### 路由组件参数\n\n","depth":3,"text":"路由组件参数","tokens":[{"type":"text","raw":"路由组件参数","text":"路由组件参数"}],"id":"#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0"}]}]},{"title":"路由","path":"/react/basic/fs-router","file":"docs/react/02-basic/05-fs-router.md","hasMenu":false,"mdContent":"# 路由\n\n## 约定式路由\n\n约定式路由也叫文件路由，不需要手写路由配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。\n\n约定路由的存放目录`src/client/pages`或者`src/pages`，如果`src/client/pages`存在，就不会再分析`src/pages`中的路由了。\n例如：\n\n```shell\nmyapp\n  src\n    client\n      pages  # 约定路由根目录\n        index.tsx  # 首页\n        about.tsx  # 关于页面\n```\n\n等效于以下路由配置：\n\n```js\n[\n  { exact: true, path: \"/\", componentName: \"index\", componentModule: \"src/client/pages/index\" },\n  { exact: true, path: \"/\", componentName: \"about\", componentModule: require(\"src/client/pages/about\") },\n];\n```\n","htmlContent":"\n                <h1 id=\"%E8%B7%AF%E7%94%B1\">\n                  路由\n                </h1>\n                <h2 id=\"%E7%BA%A6%E5%AE%9A%E5%BC%8F%E8%B7%AF%E7%94%B1\">\n                  约定式路由\n                </h2><p>约定式路由也叫文件路由，不需要手写路由配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p>\n<p>约定路由的存放目录<code>src/client/pages</code>或者<code>src/pages</code>，如果<code>src/client/pages</code>存在，就不会再分析<code>src/pages</code>中的路由了。\n例如：</p>\n<pre><code class=\"hljs language-shell\">myapp\n  src\n    client\n      pages  # 约定路由根目录\n        index.tsx  # 首页\n        about.tsx  # 关于页面\n</code></pre>\n<p>等效于以下路由配置：</p>\n<pre><code class=\"hljs language-js\">[\n  { <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;index&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-string\">&quot;src/client/pages/index&quot;</span> },\n  { <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;about&quot;</span>, <span class=\"hljs-attr\">componentModule</span>: <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;src/client/pages/about&quot;</span>) },\n];\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 约定式路由\n\n","depth":2,"text":"约定式路由","tokens":[{"type":"text","raw":"约定式路由","text":"约定式路由"}],"id":"#%E7%BA%A6%E5%AE%9A%E5%BC%8F%E8%B7%AF%E7%94%B1"}]},{"title":"ReactController","path":"/react/basic/react-controller","file":"docs/react/02-basic/react-controller.md","hasMenu":false,"mdContent":"# ReactController\n\nReactController 类型的 IoC 组件有点 **特殊**，实例并非 ReactApplicationContext 容器所创建，而是 React 在渲染时，根据界面展示创建实例，然后由容器注入依赖项，界面销毁时，实例也将销毁，其生命周期和 React 类组件一样。\n所以在使用 ReactController 时组要注意：\n\n- 申明的依赖项，只能声明在属性上，不能在构造函数里。\n- 构造函数内不能使用其申明的属性依赖，因为属性依赖还未注入值，可考虑将初始化方法，移动到 `initialize` 方法内。\n\n## 作用：\n\n`ReactController` 负责关联 ReactModel 和 View，其主要职责有：\n\n- 申明依赖的 ReactModel， 绑定 Model 的状态数据到 View，状态发现变化后，自动刷新 View 界面。\n- 响应界面事件，调用 ReactModel 中的业务方法。\n- 展示其包含的 View 组件。\n\n这是一个简单的`ReactController`类：\n\n```tsx\nimport React, { ReactNode } from \"react\";\nimport { BaseReactController, ReactController, ReactRoute } from \"@symph/react\";\n\n@ReactRoute({ path: \"/hello\" })\n@ReactController()\nexport default class HelloController extends BaseReactController {\n  renderView(): ReactNode {\n    return <div id=\"msg\">Hello World!</div>;\n  }\n}\n```\n\n## 依赖 ReactModel\n\n使用依赖注入的方式，我们可以将 ReactModel 的实例注入到 ReactController 中，从而使用其方法和状态，注意：注入的方式只能是属性注入。\n\n### 绑定 Model 状态\n\n在渲染方法`renderView`中使用的状态，将自动和当前界面绑定，当状态发生变化后，界面将重新渲染。\n可以只一个 ReactModel 中的 **部分** 状态， 而其它 **未使用部分** 状态发现更新，界面不会重新渲染，这能明显减少 React 的重新渲染次数。\n在其它地方读取的状态，将不会和界面自动绑定，比如在 React 组件生命周期方法和事件处理方法中。\n\n例如：\n\n```ts\n@ReactModel()\nexport class UserModel extends BaseReactModel<{\n  userName: string;\n  phoneNumber: string;\n}> {\n  // 设置初始化状态\n  getInitState(): OrderModelState {\n    return {};\n  }\n\n  public updateUser({ userName, phoneNumber }) {\n    this.setState({ userName, phoneNumber });\n  }\n}\n```\n\n```tsx\n@ReactController()\nexport default class PhoneController extends BaseReactController {\n  @Inject()\n  private userModel: UserModel;\n\n  updatePhoneNumber = () => {\n    const { userName, phoneNumber } = this.userModel.state;\n    this.userModel.updateUser({ userName, phoneNumber: \"00000000\" });\n  };\n\n  renderView(): ReactNode {\n    // 只使用了 UserModel 中的 phoneNumber 属性，未使用 userName 属性\n    const { phoneNumber } = this.userModel.state;\n    return (\n      <div>\n        <span>Phone Number: {phoneNumber} </span>\n        <button onClick={this.updatePhoneNumber}>edit</button>\n      </div>\n    );\n  }\n}\n```\n\n上示例中:\n\n- 在`PhoneController`的渲染方法中，只使用了`UserModel`状态的`phoneNumber`属性，未使用`name`属性，所以只有当`phoneNumber`状态发现变化时，`PhoneController`才会触发重新渲染。\n- 在 `updatePhone` 中虽然 `userName` 和 `phoneNumber`都使用了，但不是在渲染阶段使用的，所以`userName`并不会和界面建立绑定关系。\n\n### 避免状态过期\n\nReactModel 中对应的状态是不可变的，每次更新状态，都会创建一个新的状态，所以每次获取的状态只能代表当前状态，在需要时应当重新获取新的状态。\n\n例如我们尝试给指定用户发送短信，但是发送之前，需要用户确认手机号是否正确，如果有误，可以改正后发送：\n\n```tsx\n@ReactController()\nexport default class PhoneController extends BaseReactController {\n  @Inject()\n  private userModel: UserModel;\n\n  sendMessage = async () => {\n    const user = this.userModel.state;\n    await this.confirmPhone(user); // 异步执行语句\n    // 错误: import! 不能直接再使用user.phoneNumber了，因为可能已经被用户修改了。\n    this.userModel.sendSMS({ phoneNumber: user.phoneNumber, smsContext: `Hello ${userName}!` });\n\n    // 正确：应该重新获取当前的状态。\n    const confirmedUser = this.userModel.state;\n    this.userModel.sendSMS({ phoneNumber: confirmedUser.phoneNumber, smsContext: `Hello ${userName}!` });\n  };\n\n  confirmPhone = async () => {\n    /********\n     * 在这里弹出用户信息确认框。\n     * 如果信息有误，用户可以立即编辑更新用户信息。\n     ******/\n  };\n\n  renderView(): ReactNode {\n    // 只使用了 UserModel 中的 phoneNumber 属性，未使用 userName 属性\n    const { phoneNumber } = this.userModel.state;\n    return (\n      <div>\n        <span>Phone Number: {phoneNumber} </span>\n        <button onClick={this.sendMessage}>Send Hell Message</button>\n      </div>\n    );\n  }\n}\n```\n","htmlContent":"\n                <h1 id=\"reactcontroller\">\n                  ReactController\n                </h1><p>ReactController 类型的 IoC 组件有点 <strong>特殊</strong>，实例并非 ReactApplicationContext 容器所创建，而是 React 在渲染时，根据界面展示创建实例，然后由容器注入依赖项，界面销毁时，实例也将销毁，其生命周期和 React 类组件一样。\n所以在使用 ReactController 时组要注意：</p>\n<ul>\n<li>申明的依赖项，只能声明在属性上，不能在构造函数里。</li>\n<li>构造函数内不能使用其申明的属性依赖，因为属性依赖还未注入值，可考虑将初始化方法，移动到 <code>initialize</code> 方法内。</li>\n</ul>\n\n                <h2 id=\"%E4%BD%9C%E7%94%A8%EF%BC%9A\">\n                  作用：\n                </h2><p><code>ReactController</code> 负责关联 ReactModel 和 View，其主要职责有：</p>\n<ul>\n<li>申明依赖的 ReactModel， 绑定 Model 的状态数据到 View，状态发现变化后，自动刷新 View 界面。</li>\n<li>响应界面事件，调用 ReactModel 中的业务方法。</li>\n<li>展示其包含的 View 组件。</li>\n</ul>\n<p>这是一个简单的<code>ReactController</code>类：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">ReactNode</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/hello&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;msg&quot;</span>&gt;</span>Hello World!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n\n                <h2 id=\"%E4%BE%9D%E8%B5%96-reactmodel\">\n                  依赖 ReactModel\n                </h2><p>使用依赖注入的方式，我们可以将 ReactModel 的实例注入到 ReactController 中，从而使用其方法和状态，注意：注入的方式只能是属性注入。</p>\n\n                <h3 id=\"%E7%BB%91%E5%AE%9A-model-%E7%8A%B6%E6%80%81\">\n                  绑定 Model 状态\n                </h3><p>在渲染方法<code>renderView</code>中使用的状态，将自动和当前界面绑定，当状态发生变化后，界面将重新渲染。\n可以只一个 ReactModel 中的 <strong>部分</strong> 状态， 而其它 <strong>未使用部分</strong> 状态发现更新，界面不会重新渲染，这能明显减少 React 的重新渲染次数。\n在其它地方读取的状态，将不会和界面自动绑定，比如在 React 组件生命周期方法和事件处理方法中。</p>\n<p>例如：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-meta\">@ReactModel</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactModel</span>&lt;{\n  <span class=\"hljs-attr\">userName</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">phoneNumber</span>: <span class=\"hljs-built_in\">string</span>;\n}&gt; {\n  <span class=\"hljs-comment\">// 设置初始化状态</span>\n  <span class=\"hljs-title function_\">getInitState</span>(): <span class=\"hljs-title class_\">OrderModelState</span> {\n    <span class=\"hljs-keyword\">return</span> {};\n  }\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">updateUser</span>(<span class=\"hljs-params\">{ userName, phoneNumber }</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>({ userName, phoneNumber });\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PhoneController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-meta\">@Inject</span>()\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">userModel</span>: <span class=\"hljs-title class_\">UserModel</span>;\n\n  updatePhoneNumber = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { userName, phoneNumber } = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-title function_\">updateUser</span>({ userName, <span class=\"hljs-attr\">phoneNumber</span>: <span class=\"hljs-string\">&quot;00000000&quot;</span> });\n  };\n\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-comment\">// 只使用了 UserModel 中的 phoneNumber 属性，未使用 userName 属性</span>\n    <span class=\"hljs-keyword\">const</span> { phoneNumber } = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Phone Number: {phoneNumber} <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.updatePhoneNumber}</span>&gt;</span>edit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>上示例中:</p>\n<ul>\n<li>在<code>PhoneController</code>的渲染方法中，只使用了<code>UserModel</code>状态的<code>phoneNumber</code>属性，未使用<code>name</code>属性，所以只有当<code>phoneNumber</code>状态发现变化时，<code>PhoneController</code>才会触发重新渲染。</li>\n<li>在 <code>updatePhone</code> 中虽然 <code>userName</code> 和 <code>phoneNumber</code>都使用了，但不是在渲染阶段使用的，所以<code>userName</code>并不会和界面建立绑定关系。</li>\n</ul>\n\n                <h3 id=\"%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E8%BF%87%E6%9C%9F\">\n                  避免状态过期\n                </h3><p>ReactModel 中对应的状态是不可变的，每次更新状态，都会创建一个新的状态，所以每次获取的状态只能代表当前状态，在需要时应当重新获取新的状态。</p>\n<p>例如我们尝试给指定用户发送短信，但是发送之前，需要用户确认手机号是否正确，如果有误，可以改正后发送：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PhoneController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-meta\">@Inject</span>()\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">userModel</span>: <span class=\"hljs-title class_\">UserModel</span>;\n\n  sendMessage = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">confirmPhone</span>(user); <span class=\"hljs-comment\">// 异步执行语句</span>\n    <span class=\"hljs-comment\">// 错误: import! 不能直接再使用user.phoneNumber了，因为可能已经被用户修改了。</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-title function_\">sendSMS</span>({ <span class=\"hljs-attr\">phoneNumber</span>: user.<span class=\"hljs-property\">phoneNumber</span>, <span class=\"hljs-attr\">smsContext</span>: <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${userName}</span>!`</span> });\n\n    <span class=\"hljs-comment\">// 正确：应该重新获取当前的状态。</span>\n    <span class=\"hljs-keyword\">const</span> confirmedUser = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-title function_\">sendSMS</span>({ <span class=\"hljs-attr\">phoneNumber</span>: confirmedUser.<span class=\"hljs-property\">phoneNumber</span>, <span class=\"hljs-attr\">smsContext</span>: <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${userName}</span>!`</span> });\n  };\n\n  confirmPhone = <span class=\"hljs-keyword\">async</span> () =&gt; {\n    <span class=\"hljs-comment\">/********\n     * 在这里弹出用户信息确认框。\n     * 如果信息有误，用户可以立即编辑更新用户信息。\n     ******/</span>\n  };\n\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-comment\">// 只使用了 UserModel 中的 phoneNumber 属性，未使用 userName 属性</span>\n    <span class=\"hljs-keyword\">const</span> { phoneNumber } = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">userModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Phone Number: {phoneNumber} <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{this.sendMessage}</span>&gt;</span>Send Hell Message<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 作用：\n\n","depth":2,"text":"作用：","tokens":[{"type":"text","raw":"作用：","text":"作用："}],"id":"#%E4%BD%9C%E7%94%A8%EF%BC%9A"},{"type":"heading","raw":"## 依赖 ReactModel\n\n","depth":2,"text":"依赖 ReactModel","tokens":[{"type":"text","raw":"依赖 ReactModel","text":"依赖 ReactModel"}],"id":"#%E4%BE%9D%E8%B5%96-reactmodel","children":[{"type":"heading","raw":"### 绑定 Model 状态\n\n","depth":3,"text":"绑定 Model 状态","tokens":[{"type":"text","raw":"绑定 Model 状态","text":"绑定 Model 状态"}],"id":"#%E7%BB%91%E5%AE%9A-model-%E7%8A%B6%E6%80%81"},{"type":"heading","raw":"### 避免状态过期\n\n","depth":3,"text":"避免状态过期","tokens":[{"type":"text","raw":"避免状态过期","text":"避免状态过期"}],"id":"#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E8%BF%87%E6%9C%9F"}]}]},{"title":"ReactModel","path":"/react/basic/react-model","file":"docs/react/02-basic/react-model.md","hasMenu":false,"mdContent":"# ReactModel\n\nReactModel 组件用于管理业务方法和维护业务数据状态。状态管理基于 [redux](https://redux.js.org/) 实现，秉承其单向不可变数据流，全局状态管理属性的特性。\n\n`ReactModel`是单例且按需加载和创建的，在应用运行期间，只有当前界面上使用到的`ReactModel`组件才会被创建，创建后的实例将一直在容器中存在，如果再次进入该界面，会直接使用之前的实例和其状态渲染。\n\n先看一个简单的购物车 Model 示例：\n\n```ts\nimport { BaseReactModel, ReactModel } from \"@symph/react\";\nimport { Inject } from \"@symph/core\";\n\ninterface Order {\n  id: string;\n  name: string;\n  price: number;\n}\n\ninterface OrderModelState {\n  orders: Order[];\n}\n\n@ReactModel()\nexport class OrderModel extends BaseReactModel<OrderModelState> {\n  // 设置初始化状态\n  getInitState(): OrderModelState {\n    return { orders: [] };\n  }\n\n  async fetchOrders() {\n    const resp = await this.fetchService.fetchApi(\"/orders\");\n    const orders = await resp.json();\n    this.setState({ orders }); // 更新状态\n  }\n}\n```\n\n`OrderModel`继承了`BaseReactModel`类，使用`@ReactModel(options)` 装饰器申明这个是一个 ReactModel，通过泛型指定了其管理的`state`的数据类型。\n\n## 设置初始状态 `getInitState`\n\n在`ReactModel`类中实现`getInitState`方法，其返回值即作为该 Model 的初始状态值。\n\n只有在 `ReactModel` 首次被创建时，才会向统一状态源中注册该 Model 的和其初始状态值。\n\n## 更新状态 `setState`\n\n在业务方法内部，调用父类提供的`protected setState(nextState: Partial<TState>): void`方法来更新当前 Model 状态。\n\n入参`nextState`可以是该 Model 状态的一部分值，最终和当前状态`merge`合并后形成新的状态，合并只是浅层合并，类似`Object.assign({}, nextState, curState)`, 和这和 React 类组件提供的`setState`方法类似。\n\n其访问属性为`protected`，意为着只能在本 Model 内部调用，不能在外部直接调用更改一个 Model 的状态，也不建议这样，这会导致 Model 的状态难以维护。\n\n## 读取状态 `state`\n\n在 Model 内部和外部可通过读取`public get state(): TState；`属性来获取 Model 的当前状态，这是一个`getter`方法申明的只读属性，每次读取该属性，都会重新从统一数据源中获取当前状态值。其实上 Model 实例并未正真保存状态数据，各个 Model 的状态统一在 Redux 的 `store`中管理，读取 Model 状态时，是实时从全局状态中获取属于当前 Model 的状态。\n\n## 避免状态过期\n\nReactModel 中对应的状态是不可变的，每次更新状态，都会创建一个新的状态，所以每次获取的状态只能代表当前状态，在需要时应当重新获取新的状态。\n如赋值语句`const user = userModel.state;`中的`user`只是当前的状态的快照，如果立即更改了`userModel`的状态，`user`变量并不会同步更新。\n\n```ts\nasync function checkState() {\n  let userState = userModel.state;\n  await updateUser(); // 假设在 updateUser 里异步更新了UserModel中的状态。\n  console.log(userState === userModel.state); // 输出： false\n\n  // 建议：在这里重新获取当前状态\n  userState = userModel.state;\n}\n```\n\n## 数据获取服务 ReactFetchService\n\n数据获取基本上是每个前端应用要做的事情，所以`@symph/joy`提供了开箱即用的数据获取服务类`ReactFetchService`, 在`ReactModel`中我们可以直接使用该服务。\n\n```ts\n@ReactModel()\nexport class UserModel extends BaseReactModel<{ user }> {\n  async fetchUser() {\n    // 使用 fetchService 发送请求，获取数据。\n    const resp = await this.fetchService.fetchApi(\"/user/me\");\n    const user = await resp.json();\n    this.setState(User);\n  }\n}\n```\n\n上例中，我们通过`this.fetchService.fetchApi`请求 API 接口数据，那它为我们提供了哪些能力呢？\n\n- 读取配置，生成完成的请求接口地址。\n- 提供请求和响应处理器，错误封装，并发及操时控制等。（待开发）\n- 区分服务端渲染和浏览器环境，两者的实现方式有所不同，所以在服务端渲染时`ReactModel`中注入的是 `ReactFetchServerService` 实例，在浏览器上运行时注入的是 `ReactFetchClientService`实例。\n  例如：在服务端渲染时有时并不能通过外网域名和端口来加载数据，得使用类似`http://localhost:${config.port}`的地址来获取当前服务启动的端口地址。\n\n### fetchApi\n\n`public fetchApi(path: string, init?: RequestInit): Promise<Response>;`\n\n该方法用于获取 API 数据，添加`apiPrefix`前缀。\n\n我们为了区分请求是为了获取界面还是加载数据，一般会给数据请求的路径上统一添加前缀来区分，默认为`/api`，前缀可在应用配置文件中通过`apiPrefix`定制更改，该方法帮我获取`apiPrefix`配置，拼接完整的 API 请求路径。\n\n例如： 当`apiPrefix: \"/blog-api\"`时，`fetchApi(\"/user/me\")`等效于：`fetch('/blog-api/user/me')`。\n\n### fetchModuleApi\n\n`public fetchModuleApi(moduleMount: string, path: string, init?: RequestInit): Promise<Response>;`\n\n获取挂载业务模块中提供的接口，`moduleMount`为其挂载点。\n\n> 通常情况下，我们并不直接使用该方法调用第三业务模块中提供的接口，而是依赖第三方模块提供的`ReactModel`或`Service`服务类，调用其方法获取处理后的数据，第三方模块内封装数据请求和数据处理逻辑。\n\n### 可挂载模块获取数据\n\n第三方可挂载业务模块在开发时，并不能预测它挂载到主应用时的名称是什么，所以`@symph/joy`提供了`ReactModuleFetchService`类，其提供`fetchModuleApi`方，在运行时自动获取本模块的挂载值，然后生成完整的请求路径。\n\n例如：当我们开发一个通用的用户管理模块，在其它应用挂载该模块在`users`路径下，那么`reactModuleFetchService.fetchModuleApi(\"/me\")`等效于 `fetch(\"/api/users/me\")`。\n","htmlContent":"\n                <h1 id=\"reactmodel\">\n                  ReactModel\n                </h1><p>ReactModel 组件用于管理业务方法和维护业务数据状态。状态管理基于 <a href=\"https://redux.js.org/\">redux</a> 实现，秉承其单向不可变数据流，全局状态管理属性的特性。</p>\n<p><code>ReactModel</code>是单例且按需加载和创建的，在应用运行期间，只有当前界面上使用到的<code>ReactModel</code>组件才会被创建，创建后的实例将一直在容器中存在，如果再次进入该界面，会直接使用之前的实例和其状态渲染。</p>\n<p>先看一个简单的购物车 Model 示例：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactModel</span>, <span class=\"hljs-title class_\">ReactModel</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Inject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Order</span> {\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">price</span>: <span class=\"hljs-built_in\">number</span>;\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">OrderModelState</span> {\n  <span class=\"hljs-attr\">orders</span>: <span class=\"hljs-title class_\">Order</span>[];\n}\n\n<span class=\"hljs-meta\">@ReactModel</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactModel</span>&lt;<span class=\"hljs-title class_\">OrderModelState</span>&gt; {\n  <span class=\"hljs-comment\">// 设置初始化状态</span>\n  <span class=\"hljs-title function_\">getInitState</span>(): <span class=\"hljs-title class_\">OrderModelState</span> {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">orders</span>: [] };\n  }\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchOrders</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fetchService</span>.<span class=\"hljs-title function_\">fetchApi</span>(<span class=\"hljs-string\">&quot;/orders&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> orders = <span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>({ orders }); <span class=\"hljs-comment\">// 更新状态</span>\n  }\n}\n</code></pre>\n<p><code>OrderModel</code>继承了<code>BaseReactModel</code>类，使用<code>@ReactModel(options)</code> 装饰器申明这个是一个 ReactModel，通过泛型指定了其管理的<code>state</code>的数据类型。</p>\n\n                <h2 id=\"%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81-getinitstate\">\n                  设置初始状态 <code>getInitState</code>\n                </h2><p>在<code>ReactModel</code>类中实现<code>getInitState</code>方法，其返回值即作为该 Model 的初始状态值。</p>\n<p>只有在 <code>ReactModel</code> 首次被创建时，才会向统一状态源中注册该 Model 的和其初始状态值。</p>\n\n                <h2 id=\"%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81-setstate\">\n                  更新状态 <code>setState</code>\n                </h2><p>在业务方法内部，调用父类提供的<code>protected setState(nextState: Partial&lt;TState&gt;): void</code>方法来更新当前 Model 状态。</p>\n<p>入参<code>nextState</code>可以是该 Model 状态的一部分值，最终和当前状态<code>merge</code>合并后形成新的状态，合并只是浅层合并，类似<code>Object.assign({}, nextState, curState)</code>, 和这和 React 类组件提供的<code>setState</code>方法类似。</p>\n<p>其访问属性为<code>protected</code>，意为着只能在本 Model 内部调用，不能在外部直接调用更改一个 Model 的状态，也不建议这样，这会导致 Model 的状态难以维护。</p>\n\n                <h2 id=\"%E8%AF%BB%E5%8F%96%E7%8A%B6%E6%80%81-state\">\n                  读取状态 <code>state</code>\n                </h2><p>在 Model 内部和外部可通过读取<code>public get state(): TState；</code>属性来获取 Model 的当前状态，这是一个<code>getter</code>方法申明的只读属性，每次读取该属性，都会重新从统一数据源中获取当前状态值。其实上 Model 实例并未正真保存状态数据，各个 Model 的状态统一在 Redux 的 <code>store</code>中管理，读取 Model 状态时，是实时从全局状态中获取属于当前 Model 的状态。</p>\n\n                <h2 id=\"%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E8%BF%87%E6%9C%9F\">\n                  避免状态过期\n                </h2><p>ReactModel 中对应的状态是不可变的，每次更新状态，都会创建一个新的状态，所以每次获取的状态只能代表当前状态，在需要时应当重新获取新的状态。\n如赋值语句<code>const user = userModel.state;</code>中的<code>user</code>只是当前的状态的快照，如果立即更改了<code>userModel</code>的状态，<code>user</code>变量并不会同步更新。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">checkState</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">let</span> userState = userModel.<span class=\"hljs-property\">state</span>;\n  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">updateUser</span>(); <span class=\"hljs-comment\">// 假设在 updateUser 里异步更新了UserModel中的状态。</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userState === userModel.<span class=\"hljs-property\">state</span>); <span class=\"hljs-comment\">// 输出： false</span>\n\n  <span class=\"hljs-comment\">// 建议：在这里重新获取当前状态</span>\n  userState = userModel.<span class=\"hljs-property\">state</span>;\n}\n</code></pre>\n\n                <h2 id=\"%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1-reactfetchservice\">\n                  数据获取服务 ReactFetchService\n                </h2><p>数据获取基本上是每个前端应用要做的事情，所以<code>@symph/joy</code>提供了开箱即用的数据获取服务类<code>ReactFetchService</code>, 在<code>ReactModel</code>中我们可以直接使用该服务。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-meta\">@ReactModel</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactModel</span>&lt;{ user }&gt; {\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchUser</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 使用 fetchService 发送请求，获取数据。</span>\n    <span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fetchService</span>.<span class=\"hljs-title function_\">fetchApi</span>(<span class=\"hljs-string\">&quot;/user/me&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-title class_\">User</span>);\n  }\n}\n</code></pre>\n<p>上例中，我们通过<code>this.fetchService.fetchApi</code>请求 API 接口数据，那它为我们提供了哪些能力呢？</p>\n<ul>\n<li>读取配置，生成完成的请求接口地址。</li>\n<li>提供请求和响应处理器，错误封装，并发及操时控制等。（待开发）</li>\n<li>区分服务端渲染和浏览器环境，两者的实现方式有所不同，所以在服务端渲染时<code>ReactModel</code>中注入的是 <code>ReactFetchServerService</code> 实例，在浏览器上运行时注入的是 <code>ReactFetchClientService</code>实例。\n例如：在服务端渲染时有时并不能通过外网域名和端口来加载数据，得使用类似<code>http://localhost:${config.port}</code>的地址来获取当前服务启动的端口地址。</li>\n</ul>\n\n                <h3 id=\"fetchapi\">\n                  fetchApi\n                </h3><p><code>public fetchApi(path: string, init?: RequestInit): Promise&lt;Response&gt;;</code></p>\n<p>该方法用于获取 API 数据，添加<code>apiPrefix</code>前缀。</p>\n<p>我们为了区分请求是为了获取界面还是加载数据，一般会给数据请求的路径上统一添加前缀来区分，默认为<code>/api</code>，前缀可在应用配置文件中通过<code>apiPrefix</code>定制更改，该方法帮我获取<code>apiPrefix</code>配置，拼接完整的 API 请求路径。</p>\n<p>例如： 当<code>apiPrefix: &quot;/blog-api&quot;</code>时，<code>fetchApi(&quot;/user/me&quot;)</code>等效于：<code>fetch(&#39;/blog-api/user/me&#39;)</code>。</p>\n\n                <h3 id=\"fetchmoduleapi\">\n                  fetchModuleApi\n                </h3><p><code>public fetchModuleApi(moduleMount: string, path: string, init?: RequestInit): Promise&lt;Response&gt;;</code></p>\n<p>获取挂载业务模块中提供的接口，<code>moduleMount</code>为其挂载点。</p>\n<blockquote>\n<p>通常情况下，我们并不直接使用该方法调用第三业务模块中提供的接口，而是依赖第三方模块提供的<code>ReactModel</code>或<code>Service</code>服务类，调用其方法获取处理后的数据，第三方模块内封装数据请求和数据处理逻辑。</p>\n</blockquote>\n\n                <h3 id=\"%E5%8F%AF%E6%8C%82%E8%BD%BD%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE\">\n                  可挂载模块获取数据\n                </h3><p>第三方可挂载业务模块在开发时，并不能预测它挂载到主应用时的名称是什么，所以<code>@symph/joy</code>提供了<code>ReactModuleFetchService</code>类，其提供<code>fetchModuleApi</code>方，在运行时自动获取本模块的挂载值，然后生成完整的请求路径。</p>\n<p>例如：当我们开发一个通用的用户管理模块，在其它应用挂载该模块在<code>users</code>路径下，那么<code>reactModuleFetchService.fetchModuleApi(&quot;/me&quot;)</code>等效于 <code>fetch(&quot;/api/users/me&quot;)</code>。</p>\n","anchor":[{"type":"heading","raw":"## 设置初始状态 `getInitState`\n\n","depth":2,"text":"设置初始状态 `getInitState`","tokens":[{"type":"text","raw":"设置初始状态 ","text":"设置初始状态 "},{"type":"codespan","raw":"`getInitState`","text":"getInitState"}],"id":"#%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81-%60getinitstate%60"},{"type":"heading","raw":"## 更新状态 `setState`\n\n","depth":2,"text":"更新状态 `setState`","tokens":[{"type":"text","raw":"更新状态 ","text":"更新状态 "},{"type":"codespan","raw":"`setState`","text":"setState"}],"id":"#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81-%60setstate%60"},{"type":"heading","raw":"## 读取状态 `state`\n\n","depth":2,"text":"读取状态 `state`","tokens":[{"type":"text","raw":"读取状态 ","text":"读取状态 "},{"type":"codespan","raw":"`state`","text":"state"}],"id":"#%E8%AF%BB%E5%8F%96%E7%8A%B6%E6%80%81-%60state%60"},{"type":"heading","raw":"## 避免状态过期\n\n","depth":2,"text":"避免状态过期","tokens":[{"type":"text","raw":"避免状态过期","text":"避免状态过期"}],"id":"#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E8%BF%87%E6%9C%9F"},{"type":"heading","raw":"## 数据获取服务 ReactFetchService\n\n","depth":2,"text":"数据获取服务 ReactFetchService","tokens":[{"type":"text","raw":"数据获取服务 ReactFetchService","text":"数据获取服务 ReactFetchService"}],"id":"#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1-reactfetchservice","children":[{"type":"heading","raw":"### fetchApi\n\n","depth":3,"text":"fetchApi","tokens":[{"type":"text","raw":"fetchApi","text":"fetchApi"}],"id":"#fetchapi"},{"type":"heading","raw":"### fetchModuleApi\n\n","depth":3,"text":"fetchModuleApi","tokens":[{"type":"text","raw":"fetchModuleApi","text":"fetchModuleApi"}],"id":"#fetchmoduleapi"},{"type":"heading","raw":"### 可挂载模块获取数据\n\n","depth":3,"text":"可挂载模块获取数据","tokens":[{"type":"text","raw":"可挂载模块获取数据","text":"可挂载模块获取数据"}],"id":"#%E5%8F%AF%E6%8C%82%E8%BD%BD%E6%A8%A1%E5%9D%97%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"}]}]},{"title":"React 组件简介","path":"/react/basic/react-mvc","file":"docs/react/02-basic/react-mvc.md","hasMenu":false,"mdContent":"# React 组件简介\n\n`@symph/react` 采用 MVC 架构来规范应用各组件的职责，内部状态集中管理和单向数量流动，使 React 专注于界面展示和交互动画，业务逻辑和状态交由 Model 层处理。\n\n## ReactModel\n\n管理业务行为和维护业务数据状态，外界可以通过`state`属性读取当前 Model 的状态，但 **不能** 直接修改状态，改变状态的唯一途径是调用业务方法，在业务方法内调用`setState(nextState)`方法更新状态。\n\n统一状态源，全局状态管理，即为各个 Model 的状态统一在 Redux 的 `store`中管理，同样遵循单向不可变数据流，Model 实例上并未正真保存状态数据，读取状态时，实时从全局状态中获取属于当前 Model 的状态。\n\n## ReactController\n\n负责关联 ReactModel 和 View，绑定 ReactModel 的状态数据到 View，响应用户操作，调用 ReactModel 中的业务操作方法，当状态发现变化后，自动刷新 View 界面。\n\n## View\n\n即 React 组件，使用 Model 中的数据来展示界面，且只负责界面样式展示。\n","htmlContent":"\n                <h1 id=\"react-%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B\">\n                  React 组件简介\n                </h1><p><code>@symph/react</code> 采用 MVC 架构来规范应用各组件的职责，内部状态集中管理和单向数量流动，使 React 专注于界面展示和交互动画，业务逻辑和状态交由 Model 层处理。</p>\n\n                <h2 id=\"reactmodel\">\n                  ReactModel\n                </h2><p>管理业务行为和维护业务数据状态，外界可以通过<code>state</code>属性读取当前 Model 的状态，但 <strong>不能</strong> 直接修改状态，改变状态的唯一途径是调用业务方法，在业务方法内调用<code>setState(nextState)</code>方法更新状态。</p>\n<p>统一状态源，全局状态管理，即为各个 Model 的状态统一在 Redux 的 <code>store</code>中管理，同样遵循单向不可变数据流，Model 实例上并未正真保存状态数据，读取状态时，实时从全局状态中获取属于当前 Model 的状态。</p>\n\n                <h2 id=\"reactcontroller\">\n                  ReactController\n                </h2><p>负责关联 ReactModel 和 View，绑定 ReactModel 的状态数据到 View，响应用户操作，调用 ReactModel 中的业务操作方法，当状态发现变化后，自动刷新 View 界面。</p>\n\n                <h2 id=\"view\">\n                  View\n                </h2><p>即 React 组件，使用 Model 中的数据来展示界面，且只负责界面样式展示。</p>\n","anchor":[{"type":"heading","raw":"## ReactModel\n\n","depth":2,"text":"ReactModel","tokens":[{"type":"text","raw":"ReactModel","text":"ReactModel"}],"id":"#reactmodel"},{"type":"heading","raw":"## ReactController\n\n","depth":2,"text":"ReactController","tokens":[{"type":"text","raw":"ReactController","text":"ReactController"}],"id":"#reactcontroller"},{"type":"heading","raw":"## View\n\n","depth":2,"text":"View","tokens":[{"type":"text","raw":"View","text":"View"}],"id":"#view"}]}]},{"title":"高级使用","path":"/react/03-advanced-features","file":"docs/react/03-advanced-features","children":[]}],"defaultOpenKeys":["/docs/react/01-start","/docs/react/02-basic","/docs/react/03-advanced-features"]}},{"type":"reactAppInitManager/__SET_STATE","state":{"/react":{"pathname":"/react","index":false,"initStatic":2}}}]},{"pathname":"/react/start/introduce","ssgData":[{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadCurrentDocErr":{"code":404,"message":"文档不存在。"},"loadingCurrentDoc":false}},{"type":"reactAppInitManager/__SET_STATE","state":{"/react/start/introduce":{"pathname":"/react/start/introduce","index":false,"initStatic":2}}}]}]