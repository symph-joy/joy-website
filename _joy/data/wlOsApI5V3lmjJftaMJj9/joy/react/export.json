[{"pathname":"INIT@/joy/react/export","ssgData":[{"type":"__INIT_MODEL","state":{"noop":{},"reactAppInitManager":{},"layoutModel":{"collapsed":true,"isMobile":false},"docsModel":{"loadingCurrentDoc":false,"docMenus":[],"titleTrees":[],"result":[],"openKeys":[],"snippets":{},"defaultOpenKeys":[]}}}]},{"pathname":"/","ssgData":[{"type":"reactAppInitManager/__SET_STATE","state":{"/":{"pathname":"/","index":false,"initStatic":2}}}]},{"pathname":"/joy","ssgData":[{"type":"docsModel/__SET_STATE","state":{"docMenus":[{"title":"介绍","path":"/joy/01-start","file":"docs/joy/01-start","children":[{"title":"@symph/joy","path":"/joy/start/introduce","file":"docs\\joy\\01-start\\01-introduce.md","hasMenu":false,"mdContent":"# @symph/joy\r\n\r\n@symph/joy 是 symph 架构体系中的应用层架构，集成了大量最佳实践的方案和研发工具，零配置可用，即使刚接触 React 或 Node 服务研发，也可以轻松快速的创建可靠的 JS/TS 应用。\r\n\r\n```mermaid\r\ngraph BT\r\n  Config(\"@symph/config\")\r\n  Core(\"@symph/core\")\r\n  React(\"@symph/react\")\r\n  Joy(\"@symph/joy\")\r\n  Server(\"@symph/server\")\r\n  Webpack(\"Webpack\")\r\n  Config --> React\r\n  Core --> React\r\n  React --> Joy\r\n  Config --> Server\r\n  Core --> Server\r\n  Server --> Joy\r\n  Webpack --> Joy\r\n```\r\n\r\n`@symph/core` IoC 核心，提供组件容器、注入器、全局 Hook 管理的能力。\r\n\r\n[`@symph/config`](/config/start/introduce) 应用配置管理，提供应用级的配置读取、验证、注入等。\r\n\r\n[`@symph/react`](/react/start/introduce) React 的 MVC 框架，可轻松开发大型复杂 React 单页面应用，提供 React MVC 基础组件，统一数据管理，单向数据绑定和路由等基础功能。\r\n\r\n[`@symph/server`](/react/start/introduce) 基于依赖注入和装饰器，类似 Spring MVC 的 Web 后端研发框架。\r\n\r\n[`@symph/joy`](/joy/start/introduce) 整合 @symph/server 和 @symph/react，server 提供业务服务，react 负责展示和交互，是集成开发调试、编译打包、服务运行等的全栈式工具。\r\n\r\n## 特征\r\n\r\n- 零配置可用，集成最佳实践配置，快速启动开发，提供研发全流程工具链。\r\n- 支持多端多类型应用开发：React、Electron、Server、Proxy Server 等。\r\n- 现代化面向对象和 IoC 设计原则，更能适应企业级迭代开发。\r\n- 默认支持和推荐使用 TypeScript，提供静态类型检查和高级语法特性。\r\n- Joy React 应用原生支持：全局状态管理、约定路由、懒加载、热更新、服务端渲染、预渲染、静态部署等。\r\n- Joy Node 应用原生支持：全局配置管理、MVC 组件、Middleware、Pipe、Guards、Fastify 集成等。\r\n- 子模块独立维护和使用，即可选择性单独使用 IoC 库，Config 配置管理、React 应用、Node 应用。\r\n- 插件化开发，便于定制功能和扩展能力。\r\n\r\n## 联系我们\r\n\r\n有任何疑问请联系我们！\r\n\r\nGithub Issue: https://github.com/symph-joy/symph-joy/issues  \r\n邮件：lnlfps@gmail.com  \r\nQQ 群：929743297\r\n","htmlContent":"\n                <h1 id=\"symph%2Fjoy\">\n                  @symph/joy\n                </h1><p>@symph/joy 是 symph 架构体系中的应用层架构，集成了大量最佳实践的方案和研发工具，零配置可用，即使刚接触 React 或 Node 服务研发，也可以轻松快速的创建可靠的 JS/TS 应用。</p>\n<pre><code class=\"hljs language-mermaid\">graph BT\n  Config(&quot;@symph/config&quot;)\n  Core(&quot;@symph/core&quot;)\n  React(&quot;@symph/react&quot;)\n  Joy(&quot;@symph/joy&quot;)\n  Server(&quot;@symph/server&quot;)\n  Webpack(&quot;Webpack&quot;)\n  Config --&gt; React\n  Core --&gt; React\n  React --&gt; Joy\n  Config --&gt; Server\n  Core --&gt; Server\n  Server --&gt; Joy\n  Webpack --&gt; Joy\n</code></pre>\n<p><code>@symph/core</code> IoC 核心，提供组件容器、注入器、全局 Hook 管理的能力。</p>\n<p><a href=\"/config/start/introduce\"><code>@symph/config</code></a> 应用配置管理，提供应用级的配置读取、验证、注入等。</p>\n<p><a href=\"/react/start/introduce\"><code>@symph/react</code></a> React 的 MVC 框架，可轻松开发大型复杂 React 单页面应用，提供 React MVC 基础组件，统一数据管理，单向数据绑定和路由等基础功能。</p>\n<p><a href=\"/react/start/introduce\"><code>@symph/server</code></a> 基于依赖注入和装饰器，类似 Spring MVC 的 Web 后端研发框架。</p>\n<p><a href=\"/joy/start/introduce\"><code>@symph/joy</code></a> 整合 @symph/server 和 @symph/react，server 提供业务服务，react 负责展示和交互，是集成开发调试、编译打包、服务运行等的全栈式工具。</p>\n\n                <h2 id=\"%E7%89%B9%E5%BE%81\">\n                  特征\n                </h2><ul>\n<li>零配置可用，集成最佳实践配置，快速启动开发，提供研发全流程工具链。</li>\n<li>支持多端多类型应用开发：React、Electron、Server、Proxy Server 等。</li>\n<li>现代化面向对象和 IoC 设计原则，更能适应企业级迭代开发。</li>\n<li>默认支持和推荐使用 TypeScript，提供静态类型检查和高级语法特性。</li>\n<li>Joy React 应用原生支持：全局状态管理、约定路由、懒加载、热更新、服务端渲染、预渲染、静态部署等。</li>\n<li>Joy Node 应用原生支持：全局配置管理、MVC 组件、Middleware、Pipe、Guards、Fastify 集成等。</li>\n<li>子模块独立维护和使用，即可选择性单独使用 IoC 库，Config 配置管理、React 应用、Node 应用。</li>\n<li>插件化开发，便于定制功能和扩展能力。</li>\n</ul>\n\n                <h2 id=\"%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC\">\n                  联系我们\n                </h2><p>有任何疑问请联系我们！</p>\n<p>Github Issue: <a href=\"https://github.com/symph-joy/symph-joy/issues\">https://github.com/symph-joy/symph-joy/issues</a><br>邮件：<a href=\"mailto:&#x6c;&#x6e;&#108;&#102;&#x70;&#x73;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;\">&#x6c;&#x6e;&#108;&#102;&#x70;&#x73;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a><br>QQ 群：929743297</p>\n","anchor":[{"type":"heading","raw":"## 特征\n\n","depth":2,"text":"特征","tokens":[{"type":"text","raw":"特征","text":"特征"}],"id":"#%E7%89%B9%E5%BE%81"},{"type":"heading","raw":"## 联系我们\n\n","depth":2,"text":"联系我们","tokens":[{"type":"text","raw":"联系我们","text":"联系我们"}],"id":"#%E8%81%94%E7%B3%BB%E6%88%91%E4%BB%AC"}]},{"title":"快速开始","path":"/joy/start/quick-started","file":"docs\\joy\\01-start\\02-quick-started.md","hasMenu":false,"mdContent":"# 快速开始\r\n\r\nJoy 支持 React、Node.js 或者前后端混合应用开发，这里以一个简单的包含前后端的`Hello World`应用为例，介绍如何快速开始开发。\r\n\r\n## 环境准备\r\n\r\n- node 必须 12.22.0 或以上版本，推荐使用 nvm 来管理 node 版本。\r\n\r\n- 推荐使用 yarn 管理依赖，国内使用 [阿里 npm 源](https://npmmirror.com/) registry: https://registry.npm.taobao.org\r\n\r\n```shell\r\n# 安装 yarn\r\n$ npm i yarn -g\r\n# 手动设置`registry`地址为国内源\r\n$ yarn config set registry https://registry.npm.taobao.org\r\n# 查看源\r\n$ yarn config get registry\r\n\r\n# 或者使用 tyarn\r\n$ npm i yarn tyarn -g\r\n# 后面文档里的 yarn 换成 tyarn\r\n$ tyarn -v\r\n```\r\n\r\n## 创建目录\r\n\r\n创建应用根目录\r\n\r\n```shell\r\n$ mkdir myapp && cd myapp\r\n```\r\n\r\n- 创建 package.json 文件， 申明应用名和依赖：\r\n\r\n```json\r\n{\r\n  \"name\": \"myapp\",\r\n  \"version\": \"v1.0.0\",\r\n  \"scripts\": {\r\n    \"dev\": \"joy dev\",\r\n    \"build\": \"joy build\",\r\n    \"start\": \"joy start\"\r\n  },\r\n  \"dependencies\": {\r\n    \"react\": \"^17.0.1\",\r\n    \"react-dom\": \"^17.0.1\",\r\n    \"@symph/joy\": \"^2.0.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/react\": \"^17.0.1\",\r\n    \"@types/react-dom\": \"^17.0.1\"\r\n  }\r\n}\r\n```\r\n\r\n## 安装依赖\r\n\r\n```shell\r\n$ yarn install\r\n```\r\n\r\n## 第一个页面\r\n\r\n### React 客户端\r\n\r\n#### 创建 Model\r\n\r\n创建文件 `src/client/model/hello.model.ts`, ReactModel 管理应用状态数据和封装业务方法。\r\n\r\n```ts\r\n// src/client/model/hello.model.ts\r\nimport { ReactModel, BaseReactModel } from \"@symph/react\";\r\nimport { Inject } from \"@symph/core\";\r\nimport { ReactFetchService } from \"@symph/joy\";\r\n\r\n@ReactModel()\r\nexport class HelloModel extends BaseReactModel<{\r\n  message: string;\r\n}> {\r\n  constructor(@Inject(\"joyFetchService\") private joyFetchService: ReactFetchService) {\r\n    super();\r\n  }\r\n\r\n  getInitState() {\r\n    return { message: \"Hello World!\" }; // Init model state\r\n  }\r\n\r\n  async fetchMessage() {\r\n    const resp = await this.joyFetchService.fetchApi(\"/hello\");\r\n    const message = await resp.text();\r\n    this.setState({ message }); // Update model state\r\n  }\r\n}\r\n```\r\n\r\n#### 创建页面\r\n\r\n- 创建第一个页面`src/client/pages/index.tsx`，页面 ReactController 负责展示 Model 中的状态，响应用户交互，触发业务流程。\r\n\r\n```tsx\r\n// src/client/pages/index.tsx\r\nimport React, { ReactNode } from \"react\";\r\nimport { BaseReactController, ReactController } from \"@symph/react\";\r\nimport { Inject } from \"@symph/core\";\r\nimport { HelloModel } from \"../model/hello.model\";\r\n\r\n@ReactController()\r\nexport default class IndexController extends BaseReactController {\r\n  @Inject()\r\n  helloModel: HelloModel;\r\n\r\n  renderView(): ReactNode {\r\n    const { message } = this.helloModel.state;\r\n    return (\r\n      <div>\r\n        <div id=\"message\">{message}</div>\r\n        <button id=\"btnUpdateMessage\" onClick={() => this.helloModel.fetchMessage()}>\r\n          Update Message\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### Server 服务端\r\n\r\n#### 创建 Api Controller\r\n\r\n创建文件 `server/controller/hello.controller.ts`, Server Controller 对外提供 HTTP 接口服务。\r\n\r\n```ts\r\n// server/controller/hello.controller.ts\r\nimport { Controller, Get } from \"@symph/server\";\r\n\r\n@Controller()\r\nexport class HelloController {\r\n  @Get(\"/hello\")\r\n  hello(): string {\r\n    return \"Hello Joy!\";\r\n  }\r\n}\r\n```\r\n\r\n服务启动后，可通过 `http://localhost:3000/api/hello` 访问该接口。\r\n\r\n## 启动开发服务器\r\n\r\n```shell\r\n$ yarn dev\r\n```\r\n\r\n当命令行输出`ready - started server on http://localhost:3000`时，开发服务器启动成功，打开浏览器输入地址 `http://localhost:3000`，即可看到我们的第一个页面`Hello Joy!`。\r\n\r\n> 热更新：此时可尝试修改页面内容，当保存后，浏览器界面将自动更新为新内容。\r\n\r\n## 部署发布\r\n\r\n### 构建\r\n\r\n```shell\r\n$ yarn run build\r\n```\r\n\r\n执行 `joy build` 命令将在 `.joy` 文件夹中构建出用于生产环境的应用程序。\r\n\r\n### 运行应用\r\n\r\n```shell\r\n$ yarn run start\r\n```\r\n\r\n构建完成后执行 `joy start`命令，将启动一个 Node.js 服务程序，该服务对外提供 HTTP API 接口服务，以及渲染 React 页面。\r\n\r\n### 导出静态HTML\r\n\r\n将React应用导出为静态HTML，可使其独立运行和部署。\r\n\r\n例如当我们开发一个单纯的React应用，业务接口由服务端团队提供，也不需要服务端渲染时，可以考虑将React应用导出，然后部署到Nginx静态资源服务器上。\r\n\r\n如果想将 `@symph/joy` 应用程序导出为静态 HTML，请参照 导出文档 中的说明进行操作。\r\n","htmlContent":"\n                <h1 id=\"%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B\">\n                  快速开始\n                </h1><p>Joy 支持 React、Node.js 或者前后端混合应用开发，这里以一个简单的包含前后端的<code>Hello World</code>应用为例，介绍如何快速开始开发。</p>\n\n                <h2 id=\"%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87\">\n                  环境准备\n                </h2><ul>\n<li><p>node 必须 12.22.0 或以上版本，推荐使用 nvm 来管理 node 版本。</p>\n</li>\n<li><p>推荐使用 yarn 管理依赖，国内使用 <a href=\"https://npmmirror.com/\">阿里 npm 源</a> registry: <a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a></p>\n</li>\n</ul>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装 yarn</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">npm i yarn -g</span>\n<span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">手动设置`registry`地址为国内源</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn config <span class=\"hljs-built_in\">set</span> registry https://registry.npm.taobao.org</span>\n<span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">查看源</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn config get registry</span>\n<span class=\"hljs-meta prompt_\">\n# </span><span class=\"language-bash\">或者使用 tyarn</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">npm i yarn tyarn -g</span>\n<span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">后面文档里的 yarn 换成 tyarn</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">tyarn -v</span>\n</code></pre>\n\n                <h2 id=\"%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95\">\n                  创建目录\n                </h2><p>创建应用根目录</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> myapp &amp;&amp; <span class=\"hljs-built_in\">cd</span> myapp</span>\n</code></pre>\n<ul>\n<li>创建 package.json 文件， 申明应用名和依赖：</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;myapp&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;v1.0.0&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;scripts&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;dev&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy dev&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;build&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy build&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;start&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;joy start&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;dependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;react&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;react-dom&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;@symph/joy&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^2.0.0&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;devDependencies&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;@types/react&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;@types/react-dom&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;^17.0.1&quot;</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n\n                <h2 id=\"%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\">\n                  安装依赖\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn install</span>\n</code></pre>\n\n                <h2 id=\"%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2\">\n                  第一个页面\n                </h2>\n                <h3 id=\"react-%E5%AE%A2%E6%88%B7%E7%AB%AF\">\n                  React 客户端\n                </h3>\n                <h4 id=\"%E5%88%9B%E5%BB%BA-model\">\n                  创建 Model\n                </h4><p>创建文件 <code>src/client/model/hello.model.ts</code>, ReactModel 管理应用状态数据和封装业务方法。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/client/model/hello.model.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactModel</span>, <span class=\"hljs-title class_\">BaseReactModel</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Inject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactFetchService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactModel</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactModel</span>&lt;{\n  <span class=\"hljs-attr\">message</span>: <span class=\"hljs-built_in\">string</span>;\n}&gt; {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-meta\">@Inject</span>(<span class=\"hljs-string\">&quot;joyFetchService&quot;</span>) <span class=\"hljs-keyword\">private</span> joyFetchService: ReactFetchService</span>) {\n    <span class=\"hljs-variable language_\">super</span>();\n  }\n\n  <span class=\"hljs-title function_\">getInitState</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&quot;Hello World!&quot;</span> }; <span class=\"hljs-comment\">// Init model state</span>\n  }\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchMessage</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> resp = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">joyFetchService</span>.<span class=\"hljs-title function_\">fetchApi</span>(<span class=\"hljs-string\">&quot;/hello&quot;</span>);\n    <span class=\"hljs-keyword\">const</span> message = <span class=\"hljs-keyword\">await</span> resp.<span class=\"hljs-title function_\">text</span>();\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>({ message }); <span class=\"hljs-comment\">// Update model state</span>\n  }\n}\n</code></pre>\n\n                <h4 id=\"%E5%88%9B%E5%BB%BA%E9%A1%B5%E9%9D%A2\">\n                  创建页面\n                </h4><ul>\n<li>创建第一个页面<code>src/client/pages/index.tsx</code>，页面 ReactController 负责展示 Model 中的状态，响应用户交互，触发业务流程。</li>\n</ul>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/client/pages/index.tsx</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">ReactNode</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Inject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HelloModel</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../model/hello.model&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IndexController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-meta\">@Inject</span>()\n  <span class=\"hljs-attr\">helloModel</span>: <span class=\"hljs-title class_\">HelloModel</span>;\n\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">const</span> { message } = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">helloModel</span>.<span class=\"hljs-property\">state</span>;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;message&quot;</span>&gt;</span>{message}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btnUpdateMessage&quot;</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{()</span> =&gt;</span> this.helloModel.fetchMessage()}&gt;\n          Update Message\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n                <h3 id=\"server-%E6%9C%8D%E5%8A%A1%E7%AB%AF\">\n                  Server 服务端\n                </h3>\n                <h4 id=\"%E5%88%9B%E5%BB%BA-api-controller\">\n                  创建 Api Controller\n                </h4><p>创建文件 <code>server/controller/hello.controller.ts</code>, Server Controller 对外提供 HTTP 接口服务。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// server/controller/hello.controller.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Controller</span>, <span class=\"hljs-title class_\">Get</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/server&quot;</span>;\n\n<span class=\"hljs-meta\">@Controller</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloController</span> {\n  <span class=\"hljs-meta\">@Get</span>(<span class=\"hljs-string\">&quot;/hello&quot;</span>)\n  <span class=\"hljs-title function_\">hello</span>(): <span class=\"hljs-built_in\">string</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Hello Joy!&quot;</span>;\n  }\n}\n</code></pre>\n<p>服务启动后，可通过 <code>http://localhost:3000/api/hello</code> 访问该接口。</p>\n\n                <h2 id=\"%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8\">\n                  启动开发服务器\n                </h2><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn dev</span>\n</code></pre>\n<p>当命令行输出<code>ready - started server on http://localhost:3000</code>时，开发服务器启动成功，打开浏览器输入地址 <code>http://localhost:3000</code>，即可看到我们的第一个页面<code>Hello Joy!</code>。</p>\n<blockquote>\n<p>热更新：此时可尝试修改页面内容，当保存后，浏览器界面将自动更新为新内容。</p>\n</blockquote>\n\n                <h2 id=\"%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83\">\n                  部署发布\n                </h2>\n                <h3 id=\"%E6%9E%84%E5%BB%BA\">\n                  构建\n                </h3><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn run build</span>\n</code></pre>\n<p>执行 <code>joy build</code> 命令将在 <code>.joy</code> 文件夹中构建出用于生产环境的应用程序。</p>\n\n                <h3 id=\"%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8\">\n                  运行应用\n                </h3><pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">yarn run start</span>\n</code></pre>\n<p>构建完成后执行 <code>joy start</code>命令，将启动一个 Node.js 服务程序，该服务对外提供 HTTP API 接口服务，以及渲染 React 页面。</p>\n\n                <h3 id=\"%E5%AF%BC%E5%87%BA%E9%9D%99%E6%80%81html\">\n                  导出静态HTML\n                </h3><p>将React应用导出为静态HTML，可使其独立运行和部署。</p>\n<p>例如当我们开发一个单纯的React应用，业务接口由服务端团队提供，也不需要服务端渲染时，可以考虑将React应用导出，然后部署到Nginx静态资源服务器上。</p>\n<p>如果想将 <code>@symph/joy</code> 应用程序导出为静态 HTML，请参照 导出文档 中的说明进行操作。</p>\n","anchor":[{"type":"heading","raw":"## 环境准备\n\n","depth":2,"text":"环境准备","tokens":[{"type":"text","raw":"环境准备","text":"环境准备"}],"id":"#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"},{"type":"heading","raw":"## 创建目录\n\n","depth":2,"text":"创建目录","tokens":[{"type":"text","raw":"创建目录","text":"创建目录"}],"id":"#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"## 安装依赖\n\n","depth":2,"text":"安装依赖","tokens":[{"type":"text","raw":"安装依赖","text":"安装依赖"}],"id":"#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"},{"type":"heading","raw":"## 第一个页面\n\n","depth":2,"text":"第一个页面","tokens":[{"type":"text","raw":"第一个页面","text":"第一个页面"}],"id":"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2","children":[{"type":"heading","raw":"### React 客户端\n\n","depth":3,"text":"React 客户端","tokens":[{"type":"text","raw":"React 客户端","text":"React 客户端"}],"id":"#react-%E5%AE%A2%E6%88%B7%E7%AB%AF","children":[{"type":"heading","raw":"#### 创建 Model\n\n","depth":4,"text":"创建 Model","tokens":[{"type":"text","raw":"创建 Model","text":"创建 Model"}],"id":"#%E5%88%9B%E5%BB%BA-model"},{"type":"heading","raw":"#### 创建页面\n\n","depth":4,"text":"创建页面","tokens":[{"type":"text","raw":"创建页面","text":"创建页面"}],"id":"#%E5%88%9B%E5%BB%BA%E9%A1%B5%E9%9D%A2"}]},{"type":"heading","raw":"### Server 服务端\n\n","depth":3,"text":"Server 服务端","tokens":[{"type":"text","raw":"Server 服务端","text":"Server 服务端"}],"id":"#server-%E6%9C%8D%E5%8A%A1%E7%AB%AF","children":[{"type":"heading","raw":"#### 创建 Api Controller\n\n","depth":4,"text":"创建 Api Controller","tokens":[{"type":"text","raw":"创建 Api Controller","text":"创建 Api Controller"}],"id":"#%E5%88%9B%E5%BB%BA-api-controller"}]}]},{"type":"heading","raw":"## 启动开发服务器\n\n","depth":2,"text":"启动开发服务器","tokens":[{"type":"text","raw":"启动开发服务器","text":"启动开发服务器"}],"id":"#%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"},{"type":"heading","raw":"## 部署发布\n\n","depth":2,"text":"部署发布","tokens":[{"type":"text","raw":"部署发布","text":"部署发布"}],"id":"#%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83","children":[{"type":"heading","raw":"### 构建\n\n","depth":3,"text":"构建","tokens":[{"type":"text","raw":"构建","text":"构建"}],"id":"#%E6%9E%84%E5%BB%BA"},{"type":"heading","raw":"### 运行应用\n\n","depth":3,"text":"运行应用","tokens":[{"type":"text","raw":"运行应用","text":"运行应用"}],"id":"#%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8"},{"type":"heading","raw":"### 导出静态HTML\n\n","depth":3,"text":"导出静态HTML","tokens":[{"type":"text","raw":"导出静态HTML","text":"导出静态HTML"}],"id":"#%E5%AF%BC%E5%87%BA%E9%9D%99%E6%80%81html"}]}]}]},{"title":"前端开发","path":"/joy/02-react","file":"docs/joy/02-react","children":[{"title":"React 开发","path":"/joy/react/react-dev","file":"docs\\joy\\02-react\\01-react-dev.md","hasMenu":false,"mdContent":"# React 开发\r\n\r\n\r\n> **重要提示**： `@symph/joy` 无缝集成 `@symph/react`库，在`@symph/react`的基础上提供了工程化相关的扩展功能。\r\n>\r\n> - 如需查看 React 应用基础开发文档，请跳转到 \"[@symph/react 文档](/react/start/introduce)\"。\r\n> - 查看 `@symph/joy` 提供的扩展功能，请继续查看后续章节。\r\n\r\n`@symph/joy` 在 `@symph/react` 基础之上，为 React 应用开发提供了部分额外能力：\r\n\r\n- 自动扫描和注册 `@symph/react` React MVC 组件\r\n- [React 约定路由](/joy/react/joy-fs-router)\r\n- 配置管理\r\n- 服务端渲染\r\n- 按需加载\r\n- 导入第三方模块\r\n- 热更新(Fast Refresh)\r\n- 静态导出\r\n- 编译打包\r\n","htmlContent":"\n                <h1 id=\"react-%E5%BC%80%E5%8F%91\">\n                  React 开发\n                </h1><blockquote>\n<p><strong>重要提示</strong>： <code>@symph/joy</code> 无缝集成 <code>@symph/react</code>库，在<code>@symph/react</code>的基础上提供了工程化相关的扩展功能。</p>\n<ul>\n<li>如需查看 React 应用基础开发文档，请跳转到 &quot;<a href=\"/react/start/introduce\">@symph/react 文档</a>&quot;。</li>\n<li>查看 <code>@symph/joy</code> 提供的扩展功能，请继续查看后续章节。</li>\n</ul>\n</blockquote>\n<p><code>@symph/joy</code> 在 <code>@symph/react</code> 基础之上，为 React 应用开发提供了部分额外能力：</p>\n<ul>\n<li>自动扫描和注册 <code>@symph/react</code> React MVC 组件</li>\n<li><a href=\"/joy/react/joy-fs-router\">React 约定路由</a></li>\n<li>配置管理</li>\n<li>服务端渲染</li>\n<li>按需加载</li>\n<li>导入第三方模块</li>\n<li>热更新(Fast Refresh)</li>\n<li>静态导出</li>\n<li>编译打包</li>\n</ul>\n","anchor":[]},{"title":"目录结构","path":"/joy/react/dir-tree","file":"docs\\joy\\02-react\\02-dir-tree.md","hasMenu":false,"mdContent":"# 目录结构\r\n\r\n## 约定目录结构\r\n\r\nJoy 支持 React 和 Node 以及两者的混合应用，下面列举各种应用类型常用的约定目录结构。\r\n\r\n### React 应用\r\n\r\n```text\r\nmyapp\r\n    src             // 源代码目录\r\n        pages       // React文件约定路由目录\r\n        models      // ReactModel目录\r\n        components  // React组件目录\r\n        server      // 可选，server端目录\r\n    config          // 配置目录\r\n        config.ts   // 配置文件\r\n    public          // 静态文件目录\r\n        logo.png    // 静态图片文件\r\n    package.json\r\n```\r\n\r\n### 前后端混合应用\r\n\r\n```text\r\nmyapp\r\n    src                 // 源代码目录\r\n        common:         // 前后端共享的代码，如类接口定义，通用处理方法等。\r\n        server          // 服务端代码\r\n            controllers\r\n            services\r\n        client          // 可选，客户端目录\r\n            pages       // 约定React路由目录\r\n            models      // ReactModel目录\r\n            components  // React组件目录\r\n    config              // 配置目录\r\n        config.ts       // 配置文件\r\n    public              // 静态文件目录\r\n        logo.png        // 静态图片文件\r\n    package.json\r\n```\r\n\r\n## 目录说明\r\n\r\n### src 目录\r\n\r\n源代码目录。\r\n\r\n### server 目录\r\n\r\n服务端相关代码，如果不需要服务端提供后端服务，可以没有该目录。\r\n\r\n### client 目录\r\n\r\nReact 客户端应用相关的代码，该目录可选：\r\n\r\n- `client`这级目录可以省略，直接在`src`下创建 React 的源代码文件，例如`src/pages/index.tsx`。\r\n- 如果应用只提供 Api 服务，不需要前端 React 界面，可以没有该目录。\r\n\r\n#### client/pages 或者 pages 目录\r\n\r\nReact 约定文件路由目录，具体使用方法，请查看 [路由](/joy/basic/joy-fs-router) 章节。\r\n\r\n### config 目录\r\n\r\n存放应用配置文件， 请转到 [配置管理](/joy/config/config-manage) 查看如何配置应用。\r\n\r\n### .env\r\n\r\n[dotenv](https://github.com/motdotla/dotenv) 环境变量配置文件。\r\n例如：\r\n\r\n```text\r\nport=8888\r\nhost=localhost\r\n```\r\n\r\n### public 目录\r\n\r\n存放静态资源文件，可直接通过 http 直接访问，例如文件 `/myapp/public/logo.png` 可通过 `http://localhost:3000/logo.png`访问。\r\n\r\n### .joy 目录\r\n\r\n`.joy` 目录是在运行时自动生成的目录，是 Joy 应用必须的，可以随时删除，在下次运行时重新生成该目录。\r\n日常开发时，我们不用去关注和修改里面的文件。\r\n里面主要包含的文件有：\r\n\r\n- 用于代码扫描分析的临时文件，以及分析后的产出物。\r\n- webpack 构建的缓存、日志物。\r\n- Joy 应用运行加载的源文件，这些文件是编译打包后的源文件。\r\n\r\n### out 目录\r\n\r\n运行`joy export` 命令的默认输出目录，存放 React 导出后的静态文件，部署该目录到静态文件服务器即可，例如 Nginx 。\r\n","htmlContent":"\n                <h1 id=\"%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">\n                  目录结构\n                </h1>\n                <h2 id=\"%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">\n                  约定目录结构\n                </h2><p>Joy 支持 React 和 Node 以及两者的混合应用，下面列举各种应用类型常用的约定目录结构。</p>\n\n                <h3 id=\"react-%E5%BA%94%E7%94%A8\">\n                  React 应用\n                </h3><pre><code class=\"hljs language-text\">myapp\n    src             // 源代码目录\n        pages       // React文件约定路由目录\n        models      // ReactModel目录\n        components  // React组件目录\n        server      // 可选，server端目录\n    config          // 配置目录\n        config.ts   // 配置文件\n    public          // 静态文件目录\n        logo.png    // 静态图片文件\n    package.json\n</code></pre>\n\n                <h3 id=\"%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8\">\n                  前后端混合应用\n                </h3><pre><code class=\"hljs language-text\">myapp\n    src                 // 源代码目录\n        common:         // 前后端共享的代码，如类接口定义，通用处理方法等。\n        server          // 服务端代码\n            controllers\n            services\n        client          // 可选，客户端目录\n            pages       // 约定React路由目录\n            models      // ReactModel目录\n            components  // React组件目录\n    config              // 配置目录\n        config.ts       // 配置文件\n    public              // 静态文件目录\n        logo.png        // 静态图片文件\n    package.json\n</code></pre>\n\n                <h2 id=\"%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E\">\n                  目录说明\n                </h2>\n                <h3 id=\"src-%E7%9B%AE%E5%BD%95\">\n                  src 目录\n                </h3><p>源代码目录。</p>\n\n                <h3 id=\"server-%E7%9B%AE%E5%BD%95\">\n                  server 目录\n                </h3><p>服务端相关代码，如果不需要服务端提供后端服务，可以没有该目录。</p>\n\n                <h3 id=\"client-%E7%9B%AE%E5%BD%95\">\n                  client 目录\n                </h3><p>React 客户端应用相关的代码，该目录可选：</p>\n<ul>\n<li><code>client</code>这级目录可以省略，直接在<code>src</code>下创建 React 的源代码文件，例如<code>src/pages/index.tsx</code>。</li>\n<li>如果应用只提供 Api 服务，不需要前端 React 界面，可以没有该目录。</li>\n</ul>\n\n                <h4 id=\"clientpages-%E6%88%96%E8%80%85-pages-%E7%9B%AE%E5%BD%95\">\n                  client/pages 或者 pages 目录\n                </h4><p>React 约定文件路由目录，具体使用方法，请查看 <a href=\"/joy/basic/joy-fs-router\">路由</a> 章节。</p>\n\n                <h3 id=\"config-%E7%9B%AE%E5%BD%95\">\n                  config 目录\n                </h3><p>存放应用配置文件， 请转到 <a href=\"/joy/config/config-manage\">配置管理</a> 查看如何配置应用。</p>\n\n                <h3 id=\"env\">\n                  .env\n                </h3><p><a href=\"https://github.com/motdotla/dotenv\">dotenv</a> 环境变量配置文件。\n例如：</p>\n<pre><code class=\"hljs language-text\">port=8888\nhost=localhost\n</code></pre>\n\n                <h3 id=\"public-%E7%9B%AE%E5%BD%95\">\n                  public 目录\n                </h3><p>存放静态资源文件，可直接通过 http 直接访问，例如文件 <code>/myapp/public/logo.png</code> 可通过 <code>http://localhost:3000/logo.png</code>访问。</p>\n\n                <h3 id=\"joy-%E7%9B%AE%E5%BD%95\">\n                  .joy 目录\n                </h3><p><code>.joy</code> 目录是在运行时自动生成的目录，是 Joy 应用必须的，可以随时删除，在下次运行时重新生成该目录。\n日常开发时，我们不用去关注和修改里面的文件。\n里面主要包含的文件有：</p>\n<ul>\n<li>用于代码扫描分析的临时文件，以及分析后的产出物。</li>\n<li>webpack 构建的缓存、日志物。</li>\n<li>Joy 应用运行加载的源文件，这些文件是编译打包后的源文件。</li>\n</ul>\n\n                <h3 id=\"out-%E7%9B%AE%E5%BD%95\">\n                  out 目录\n                </h3><p>运行<code>joy export</code> 命令的默认输出目录，存放 React 导出后的静态文件，部署该目录到静态文件服务器即可，例如 Nginx 。</p>\n","anchor":[{"type":"heading","raw":"## 约定目录结构\n\n","depth":2,"text":"约定目录结构","tokens":[{"type":"text","raw":"约定目录结构","text":"约定目录结构"}],"id":"#%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84","children":[{"type":"heading","raw":"### React 应用\n\n","depth":3,"text":"React 应用","tokens":[{"type":"text","raw":"React 应用","text":"React 应用"}],"id":"#react-%E5%BA%94%E7%94%A8"},{"type":"heading","raw":"### 前后端混合应用\n\n","depth":3,"text":"前后端混合应用","tokens":[{"type":"text","raw":"前后端混合应用","text":"前后端混合应用"}],"id":"#%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8"}]},{"type":"heading","raw":"## 目录说明\n\n","depth":2,"text":"目录说明","tokens":[{"type":"text","raw":"目录说明","text":"目录说明"}],"id":"#%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E","children":[{"type":"heading","raw":"### src 目录\n\n","depth":3,"text":"src 目录","tokens":[{"type":"text","raw":"src 目录","text":"src 目录"}],"id":"#src-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### server 目录\n\n","depth":3,"text":"server 目录","tokens":[{"type":"text","raw":"server 目录","text":"server 目录"}],"id":"#server-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### client 目录\n\n","depth":3,"text":"client 目录","tokens":[{"type":"text","raw":"client 目录","text":"client 目录"}],"id":"#client-%E7%9B%AE%E5%BD%95","children":[{"type":"heading","raw":"#### client/pages 或者 pages 目录\n\n","depth":4,"text":"client/pages 或者 pages 目录","tokens":[{"type":"text","raw":"client/pages 或者 pages 目录","text":"client/pages 或者 pages 目录"}],"id":"#clientpages-%E6%88%96%E8%80%85-pages-%E7%9B%AE%E5%BD%95"}]},{"type":"heading","raw":"### config 目录\n\n","depth":3,"text":"config 目录","tokens":[{"type":"text","raw":"config 目录","text":"config 目录"}],"id":"#config-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### .env\n\n","depth":3,"text":".env","tokens":[{"type":"text","raw":".env","text":".env"}],"id":"#env"},{"type":"heading","raw":"### public 目录\n\n","depth":3,"text":"public 目录","tokens":[{"type":"text","raw":"public 目录","text":"public 目录"}],"id":"#public-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### .joy 目录\n\n","depth":3,"text":".joy 目录","tokens":[{"type":"text","raw":".joy 目录","text":".joy 目录"}],"id":"#joy-%E7%9B%AE%E5%BD%95"},{"type":"heading","raw":"### out 目录\n\n","depth":3,"text":"out 目录","tokens":[{"type":"text","raw":"out 目录","text":"out 目录"}],"id":"#out-%E7%9B%AE%E5%BD%95"}]}]},{"title":"React 约定路由","path":"/joy/react/joy-fs-router","file":"docs\\joy\\02-react\\04-joy-fs-router.md","hasMenu":false,"mdContent":"# React 约定路由\r\n\r\n> 这篇文章只介绍如何使用约定路由，如需查看 `@symph/react` 路由的详细文档， 点击跳转到 [`@symph/react` React 路由](/react/basic/react-router)。\r\n\r\n约定式路由也称为文件路由，在约定目录下的文件，通过文件名称和子路径名，推测出路由信息，并自动注册为路由。\r\n\r\nJoy 约定存放在`src/client/pages`或者`src/pages`目录中的 ReactController 组件，将会自动注册为路由组件。注意：只有`src/client/pages` 不存在，才会使用`src/pages`目录。\r\n例如：\r\n\r\n```text\r\nsrc\r\n└── client\r\n    └── pages  # 约定路由根目录\r\n        ├── index.tsx  # 首页\r\n        └── about.tsx  # 关于页面\r\n    ```\r\n\r\n等效于以下路由配置：\r\n\r\n```js\r\n[\r\n  {\r\n    path: \"/\",\r\n    index: true,\r\n    componentName: \"index\",\r\n    componentModule: require(\"src/client/pages/index\"),\r\n  },\r\n  {\r\n    path: \"/about\",\r\n    componentName: \"about\",\r\n    componentModule: require(\"src/client/pages/about\"),\r\n  },\r\n];\r\n```\r\n\r\n需要注意的是，满足以下任意规则的文件不会被注册为路由：\r\n\r\n- 以 . 或 \\_ 开头的文件或目录\r\n- 以 test.ts、spec.ts、e2e.ts 结尾的测试文件（适用于 .js、.jsx 和 .tsx 文件）\r\n- components 和 component 目录\r\n- utils 和 util 目录\r\n\r\n如果在约定路由目录下，组件已被装饰器`@ReactRoute()`明确声明为路由组件，那么也不会再被当做文件路由组件。\r\n\r\n## 动态路由\r\n\r\n约定 `[]` 包裹的文件或文件夹为动态路由，例如：\r\n\r\n- src/client/pages/users/[id].tsx 会成为 `/users/:id`\r\n- src/client/pages/users/[id]/settings.tsx 会成为 `/users/:id/settings`\r\n\r\n## 缺省路由\r\n\r\n约定目录中的`index.tsx`(适用于.jsx 文件)命名的文件为目录下的缺省路由， 例如：\r\n\r\n- src/client/pages/index.tsx 会成为 `{path: \"/\", index: true}`。\r\n- src/client/pages/users/index.tsx 会成为 `{path: \"/user\", index: true}`。\r\n- src/client/pages/users/[id]/index.tsx 会成为 `{path: \"/users/:id\", index: true}`。\r\n\r\n## 嵌套路由\r\n\r\n约定目录下有 `_layout.tsx` 时会生成嵌套路由，目录下的其它路由将作为其子路由，`_layout.tsx` 作为父级路由，需要通过 `Outlet` 渲染子路由组件。\r\n\r\n例如以下目录结构：\r\n\r\n```text\r\n└── pages\r\n    └── users\r\n        ├── _layout.tsx\r\n        ├── index.tsx\r\n        └── list.tsx\r\n```\r\n\r\n会生成路由：\r\n\r\n```js\r\n[\r\n  {\r\n    path: \"/users\",\r\n    componentName: \"_layout\",\r\n    children: [\r\n      {\r\n        path: \"\",\r\n        index: true,\r\n        componentName: \"index\",\r\n      },\r\n      {\r\n        path: \"/list\",\r\n        componentName: \"list\",\r\n      },\r\n    ],\r\n  },\r\n];\r\n```\r\n\r\n## 全局 Layout\r\n\r\n约定 `src/client/pages/_layout.tsx` 为全局路由。\r\n\r\n我们可能需要针对不同的页面采用不同的布局，例如登录页面 `/login` 采用简单布局, 我们可以通过`location.pathname`来做区分，例如：\r\n\r\n```tsx\r\n// src/client/pages/_layout.tsx\r\n\r\nimport React from \"react\";\r\nimport { BaseReactController, ReactController } from \"@symph/react\";\r\nimport { Outlet } from \"@symph/react/router-dom\";\r\n\r\n@ReactController()\r\nexport default class MainLayout extends BaseReactController {\r\n  renderView(): React.ReactNode {\r\n    if (this.props.locaiton.pathname === \"/login\") {\r\n      return (\r\n        <SimpleLayout>\r\n          <Outlet />\r\n        </SimpleLayout>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <>\r\n        <Header />\r\n        <Outlet />\r\n        <Footer />\r\n      </>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n## 错误页面\r\n\r\n当在服务端或者浏览器运行时，出现未捕获的异常，导致应用无法正常继续运行，将显示错误页面，展示错误代码和错误提示信息。\r\n\r\n如果项目中没有自定义错误页面，会默认使用 `import { ErrorComponent } from \"@symph/joy/react\"`组件，我们也可以继承该默认错误组件，自定义错误界面。\r\n\r\n约定 `src/client/pages/_error.tsx` 为自定义错误页面，注意：错误组件是简单展示组件，只能使用`props`渲染界面。\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport { ErrorComponent } from \"@symph/joy/react\";\r\n\r\nexport default class MyError extends ErrorComponent {\r\n  renderView({ statusCode, title }: { statusCode: string; title: string }) {\r\n    return (\r\n      <>\r\n        <h1>My Custom Error Page</h1>\r\n        <p>\r\n          {statusCode}|{title}\r\n        </p>\r\n      </>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n## 404 页面\r\n\r\n`/404` 路由为特殊路由，渲染时如果未在注册的所有路由中匹配到页面，Joy 将渲染 404 组件。\r\n\r\n如果项目中没有自定义 404 页面，会使用默认的 `import { ErrorComponent } from \"@symph/joy/react\"` 组件。\r\n\r\n约定`src/client/pages/404.tsx` 为 `/404` 页面。\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport { BaseReactController, ReactController, ReactRoute } from \"@symph/react\";\r\n\r\n@ReactRoute({ path: \"/404\" })\r\n@ReactController()\r\nexport default class My404Page extends BaseReactController {\r\n  renderView() {\r\n    return <div id={\"title\"}>Custom 404</div>;\r\n  }\r\n}\r\n```\r\n","htmlContent":"\n                <h1 id=\"react-%E7%BA%A6%E5%AE%9A%E8%B7%AF%E7%94%B1\">\n                  React 约定路由\n                </h1><blockquote>\n<p>这篇文章只介绍如何使用约定路由，如需查看 <code>@symph/react</code> 路由的详细文档， 点击跳转到 <a href=\"/react/basic/react-router\"><code>@symph/react</code> React 路由</a>。</p>\n</blockquote>\n<p>约定式路由也称为文件路由，在约定目录下的文件，通过文件名称和子路径名，推测出路由信息，并自动注册为路由。</p>\n<p>Joy 约定存放在<code>src/client/pages</code>或者<code>src/pages</code>目录中的 ReactController 组件，将会自动注册为路由组件。注意：只有<code>src/client/pages</code> 不存在，才会使用<code>src/pages</code>目录。\n例如：</p>\n<pre><code class=\"hljs language-text\">src\n└── client\n    └── pages  # 约定路由根目录\n        ├── index.tsx  # 首页\n        └── about.tsx  # 关于页面\n    ```\n\n等效于以下路由配置：\n\n```js\n[\n  {\n    path: &quot;/&quot;,\n    index: true,\n    componentName: &quot;index&quot;,\n    componentModule: require(&quot;src/client/pages/index&quot;),\n  },\n  {\n    path: &quot;/about&quot;,\n    componentName: &quot;about&quot;,\n    componentModule: require(&quot;src/client/pages/about&quot;),\n  },\n];\n</code></pre>\n<p>需要注意的是，满足以下任意规则的文件不会被注册为路由：</p>\n<ul>\n<li>以 . 或 _ 开头的文件或目录</li>\n<li>以 test.ts、spec.ts、e2e.ts 结尾的测试文件（适用于 .js、.jsx 和 .tsx 文件）</li>\n<li>components 和 component 目录</li>\n<li>utils 和 util 目录</li>\n</ul>\n<p>如果在约定路由目录下，组件已被装饰器<code>@ReactRoute()</code>明确声明为路由组件，那么也不会再被当做文件路由组件。</p>\n\n                <h2 id=\"%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1\">\n                  动态路由\n                </h2><p>约定 <code>[]</code> 包裹的文件或文件夹为动态路由，例如：</p>\n<ul>\n<li>src/client/pages/users/[id].tsx 会成为 <code>/users/:id</code></li>\n<li>src/client/pages/users/[id]/settings.tsx 会成为 <code>/users/:id/settings</code></li>\n</ul>\n\n                <h2 id=\"%E7%BC%BA%E7%9C%81%E8%B7%AF%E7%94%B1\">\n                  缺省路由\n                </h2><p>约定目录中的<code>index.tsx</code>(适用于.jsx 文件)命名的文件为目录下的缺省路由， 例如：</p>\n<ul>\n<li>src/client/pages/index.tsx 会成为 <code>{path: &quot;/&quot;, index: true}</code>。</li>\n<li>src/client/pages/users/index.tsx 会成为 <code>{path: &quot;/user&quot;, index: true}</code>。</li>\n<li>src/client/pages/users/[id]/index.tsx 会成为 <code>{path: &quot;/users/:id&quot;, index: true}</code>。</li>\n</ul>\n\n                <h2 id=\"%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1\">\n                  嵌套路由\n                </h2><p>约定目录下有 <code>_layout.tsx</code> 时会生成嵌套路由，目录下的其它路由将作为其子路由，<code>_layout.tsx</code> 作为父级路由，需要通过 <code>Outlet</code> 渲染子路由组件。</p>\n<p>例如以下目录结构：</p>\n<pre><code class=\"hljs language-text\">└── pages\n    └── users\n        ├── _layout.tsx\n        ├── index.tsx\n        └── list.tsx\n</code></pre>\n<p>会生成路由：</p>\n<pre><code class=\"hljs language-js\">[\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/users&quot;</span>,\n    <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;_layout&quot;</span>,\n    <span class=\"hljs-attr\">children</span>: [\n      {\n        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;&quot;</span>,\n        <span class=\"hljs-attr\">index</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;index&quot;</span>,\n      },\n      {\n        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/list&quot;</span>,\n        <span class=\"hljs-attr\">componentName</span>: <span class=\"hljs-string\">&quot;list&quot;</span>,\n      },\n    ],\n  },\n];\n</code></pre>\n\n                <h2 id=\"%E5%85%A8%E5%B1%80-layout\">\n                  全局 Layout\n                </h2><p>约定 <code>src/client/pages/_layout.tsx</code> 为全局路由。</p>\n<p>我们可能需要针对不同的页面采用不同的布局，例如登录页面 <code>/login</code> 采用简单布局, 我们可以通过<code>location.pathname</code>来做区分，例如：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/client/pages/_layout.tsx</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Outlet</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react/router-dom&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainLayout</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-property\">ReactNode</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">locaiton</span>.<span class=\"hljs-property\">pathname</span> === <span class=\"hljs-string\">&quot;/login&quot;</span>) {\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">SimpleLayout</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">SimpleLayout</span>&gt;</span></span>\n      );\n    }\n\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Header</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Footer</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n                <h2 id=\"%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2\">\n                  错误页面\n                </h2><p>当在服务端或者浏览器运行时，出现未捕获的异常，导致应用无法正常继续运行，将显示错误页面，展示错误代码和错误提示信息。</p>\n<p>如果项目中没有自定义错误页面，会默认使用 <code>import { ErrorComponent } from &quot;@symph/joy/react&quot;</code>组件，我们也可以继承该默认错误组件，自定义错误界面。</p>\n<p>约定 <code>src/client/pages/_error.tsx</code> 为自定义错误页面，注意：错误组件是简单展示组件，只能使用<code>props</code>渲染界面。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ErrorComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">ErrorComponent</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\">{ statusCode, title }: { statusCode: <span class=\"hljs-built_in\">string</span>; title: <span class=\"hljs-built_in\">string</span> }</span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>My Custom Error Page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n          {statusCode}|{title}\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n\n                <h2 id=\"404-%E9%A1%B5%E9%9D%A2\">\n                  404 页面\n                </h2><p><code>/404</code> 路由为特殊路由，渲染时如果未在注册的所有路由中匹配到页面，Joy 将渲染 404 组件。</p>\n<p>如果项目中没有自定义 404 页面，会使用默认的 <code>import { ErrorComponent } from &quot;@symph/joy/react&quot;</code> 组件。</p>\n<p>约定<code>src/client/pages/404.tsx</code> 为 <code>/404</code> 页面。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/404&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">My404Page</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">{</span>&quot;<span class=\"hljs-attr\">title</span>&quot;}&gt;</span>Custom 404<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 动态路由\n\n","depth":2,"text":"动态路由","tokens":[{"type":"text","raw":"动态路由","text":"动态路由"}],"id":"#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"},{"type":"heading","raw":"## 缺省路由\n\n","depth":2,"text":"缺省路由","tokens":[{"type":"text","raw":"缺省路由","text":"缺省路由"}],"id":"#%E7%BC%BA%E7%9C%81%E8%B7%AF%E7%94%B1"},{"type":"heading","raw":"## 嵌套路由\n\n","depth":2,"text":"嵌套路由","tokens":[{"type":"text","raw":"嵌套路由","text":"嵌套路由"}],"id":"#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1"},{"type":"heading","raw":"## 全局 Layout\n\n","depth":2,"text":"全局 Layout","tokens":[{"type":"text","raw":"全局 Layout","text":"全局 Layout"}],"id":"#%E5%85%A8%E5%B1%80-layout"},{"type":"heading","raw":"## 错误页面\n\n","depth":2,"text":"错误页面","tokens":[{"type":"text","raw":"错误页面","text":"错误页面"}],"id":"#%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"},{"type":"heading","raw":"## 404 页面\n\n","depth":2,"text":"404 页面","tokens":[{"type":"text","raw":"404 页面","text":"404 页面"}],"id":"#404-%E9%A1%B5%E9%9D%A2"}]},{"title":"使用 CSS 样式","path":"/joy/react/style-css","file":"docs\\joy\\02-react\\05-style-css.md","hasMenu":false,"mdContent":"# 使用 CSS 样式\r\n\r\n## 应用全局样式\r\n\r\nJoy 中约定在 `src/global.css`（或`global.less` `global.sass` ）中定义全局样式，应用启动时会自动加载该样式。\r\n\r\n比如我们给应用统一设置全局样式，或者覆盖组件样式，新建文件 `src/global.css`:\r\n\r\n```css\r\nbody {\r\n  font-family: BlinkMacSystemFont, PingFang SC, Microsoft YaHei, sans-serif;\r\n  font-size: 14px;\r\n  padding: 20px 20px 60px;\r\n}\r\n\r\n.addButton {\r\n  width: 60px;\r\n}\r\n```\r\n\r\n## CSS 模块导入\r\n\r\nJoy 会对导入的 CSS 文件自动识别是否使用 CSS Modules 导入.\r\n\r\n### CSS Modules 导入\r\n\r\n[CSS Modules](https://github.com/css-modules/css-modules) 会将 css 文件内的 class 名称生成唯一的标识，从而避免不同 css 模块类相同 class 名称的冲突。 通常使用 CSS Modules 来定义组件样式，而不用担心和组件间以及全局样式的冲突。\r\n\r\n```js\r\n// CSS Modules\r\nimport styles from \"./foo.css\";\r\n\r\nexport function Button() {\r\n  return <button className={styles.btnAdd}>Add</button>;\r\n}\r\n```\r\n\r\n在 CSS Modules 中，也可以通过`:global { }`包裹方式，临时插入全局类样式，被包裹中的代码中定义的 CSS 类名，将不会被 CSS Modules 处理，直接输出到页面。\r\n例如我们自定义 header 中的菜单组件样式：\r\n\r\n```less\r\n// main-layout.less\r\n.appHeader {\r\n  height: 64px;\r\n\r\n  :global {\r\n    .ant-menu {\r\n      // ant-menu 是 antd <Menu /> 组件中的常量类名。\r\n      border: 0;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 全局样式导入\r\n\r\n非 CSS Modules 方式导入，css 文件内定义的类样式为全局样式，将会控制页面中所有满足条件的 DOM 元素。\r\n\r\n```js\r\n// 非 CSS Modules\r\nimport \"./foo.css\";\r\n\r\nexport function Button() {\r\n  return <button className=\"btnAdd\">New</button>;\r\n}\r\n\r\n// 非 CSS Modules, bar.css内定义的样式为全局样式，将会控制页面中所有满足条件的DOM元素。\r\nimport \"./bar.css\";\r\n```\r\n\r\n## 使用 LESS\r\n\r\nJoy 原生支持 Less，使用 `.less` 后缀名定义 Less 文件。在使用 Less 之前，需要先安装 [less](https://github.com/less/less.js):\r\n\r\n```bash\r\nnpm install less\r\n```\r\n\r\n### 自定义 LESS 配置\r\n\r\n在 `joy.config.js` 的 `lessOptions` 字段中定义 Less 的自定义配置, 具体可配置项参考 [less-loader](https://webpack.js.org/loaders/less-loader/) 的配置。\r\n\r\n```js\r\nconst path = require(\"path\");\r\n\r\nmodule.exports = {\r\n  lessOptions: {\r\n    strictMath: true,\r\n  },\r\n};\r\n```\r\n\r\n## 使用 Sass\r\n\r\nJoy 原生支持 Sass，使用 `.scss` 或 `.sass` 后缀名定义 Sass 文件，在使用 Sass 之前，需要先安装 [sass](https://github.com/sass/sass) :\r\n\r\n```bash\r\nnpm install sass\r\n```\r\n\r\n> Sass 支持 2 种语法格式定义来样式，`.scss`文件使用[SCSS 语法](https://sass-lang.com/documentation/syntax#scss) ，`.sass`文件使用 [Indented Syntax (\"Sass\")](https://sass-lang.com/documentation/syntax#the-indented-syntax) 语法。\r\n> 如果你不确定使用哪种语法，可首先采用`.scss`，它是 CSS 的扩展，可使用 CSS 的全部语法，不需要学习新的 Indented Syntax 缩进语法。\r\n\r\n### 自定义 Sass 配置\r\n\r\n在 `joy.config.js` 的 `sassOptions` 字段中定义 Sass 的自定义配置, 具体可配置项参考 [sass-loader](https://webpack.js.org/loaders/sass-loader/) 的配置。\r\n\r\n```js\r\nconst path = require(\"path\");\r\n\r\nmodule.exports = {\r\n  sassOptions: {\r\n    additionalData: \"$env: \" + process.env.NODE_ENV + \";\",\r\n    indentWidth: 4,\r\n    includePaths: [\"/absolute/path/a\", \"/absolute/path/b\"],\r\n  },\r\n};\r\n```\r\n\r\n### Sass 变量\r\n\r\nJoy 支持 Sass 变量从 CSS Module 文件中导出。比如导出`primaryColor`变量：\r\n\r\n```scss\r\n/* index-scss-variables.scss */\r\n$primary-color: #ff0000;\r\n\r\n:export {\r\n  primaryColor: $primary-color;\r\n}\r\n```\r\n\r\n```tsx\r\n// index-scss-variables.js\r\nimport variables from \"../index-scss-variables.scss\";\r\n\r\nexport default function MyApp({ Component, pageProps }) {\r\n  return <div style={{ color: variables.primaryColor }}>Hello</div>;\r\n}\r\n```\r\n\r\n## todo\r\n\r\n- 自定义 PostCss https://nextjs.org/docs/advanced-features/customizing-postcss-config\r\n","htmlContent":"\n                <h1 id=\"%E4%BD%BF%E7%94%A8-css-%E6%A0%B7%E5%BC%8F\">\n                  使用 CSS 样式\n                </h1>\n                <h2 id=\"%E5%BA%94%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F\">\n                  应用全局样式\n                </h2><p>Joy 中约定在 <code>src/global.css</code>（或<code>global.less</code> <code>global.sass</code> ）中定义全局样式，应用启动时会自动加载该样式。</p>\n<p>比如我们给应用统一设置全局样式，或者覆盖组件样式，新建文件 <code>src/global.css</code>:</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-selector-tag\">body</span> {\n  <span class=\"hljs-attribute\">font-family</span>: BlinkMacSystemFont, PingFang SC, Microsoft YaHei, sans-serif;\n  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;\n  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">60px</span>;\n}\n\n<span class=\"hljs-selector-class\">.addButton</span> {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">60px</span>;\n}\n</code></pre>\n\n                <h2 id=\"css-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5\">\n                  CSS 模块导入\n                </h2><p>Joy 会对导入的 CSS 文件自动识别是否使用 CSS Modules 导入.</p>\n\n                <h3 id=\"css-modules-%E5%AF%BC%E5%85%A5\">\n                  CSS Modules 导入\n                </h3><p><a href=\"https://github.com/css-modules/css-modules\">CSS Modules</a> 会将 css 文件内的 class 名称生成唯一的标识，从而避免不同 css 模块类相同 class 名称的冲突。 通常使用 CSS Modules 来定义组件样式，而不用担心和组件间以及全局样式的冲突。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CSS Modules</span>\n<span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./foo.css&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{styles.btnAdd}</span>&gt;</span>Add<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;\n}\n</code></pre>\n<p>在 CSS Modules 中，也可以通过<code>:global { }</code>包裹方式，临时插入全局类样式，被包裹中的代码中定义的 CSS 类名，将不会被 CSS Modules 处理，直接输出到页面。\n例如我们自定义 header 中的菜单组件样式：</p>\n<pre><code class=\"hljs language-less\"><span class=\"hljs-comment\">// main-layout.less</span>\n<span class=\"hljs-selector-class\">.appHeader</span> {\n  <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">64px</span>;\n\n  :<span class=\"hljs-selector-tag\">global</span> {\n    <span class=\"hljs-selector-class\">.ant-menu</span> {\n      <span class=\"hljs-comment\">// ant-menu 是 antd &lt;Menu /&gt; 组件中的常量类名。</span>\n      <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">0</span>;\n    }\n  }\n}\n</code></pre>\n\n                <h3 id=\"%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5\">\n                  全局样式导入\n                </h3><p>非 CSS Modules 方式导入，css 文件内定义的类样式为全局样式，将会控制页面中所有满足条件的 DOM 元素。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 非 CSS Modules</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./foo.css&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">&quot;btnAdd&quot;</span>&gt;</span>New<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>;\n}\n\n<span class=\"hljs-comment\">// 非 CSS Modules, bar.css内定义的样式为全局样式，将会控制页面中所有满足条件的DOM元素。</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;./bar.css&quot;</span>;\n</code></pre>\n\n                <h2 id=\"%E4%BD%BF%E7%94%A8-less\">\n                  使用 LESS\n                </h2><p>Joy 原生支持 Less，使用 <code>.less</code> 后缀名定义 Less 文件。在使用 Less 之前，需要先安装 <a href=\"https://github.com/less/less.js\">less</a>:</p>\n<pre><code class=\"hljs language-bash\">npm install less\n</code></pre>\n\n                <h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-less-%E9%85%8D%E7%BD%AE\">\n                  自定义 LESS 配置\n                </h3><p>在 <code>joy.config.js</code> 的 <code>lessOptions</code> 字段中定义 Less 的自定义配置, 具体可配置项参考 <a href=\"https://webpack.js.org/loaders/less-loader/\">less-loader</a> 的配置。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">lessOptions</span>: {\n    <span class=\"hljs-attr\">strictMath</span>: <span class=\"hljs-literal\">true</span>,\n  },\n};\n</code></pre>\n\n                <h2 id=\"%E4%BD%BF%E7%94%A8-sass\">\n                  使用 Sass\n                </h2><p>Joy 原生支持 Sass，使用 <code>.scss</code> 或 <code>.sass</code> 后缀名定义 Sass 文件，在使用 Sass 之前，需要先安装 <a href=\"https://github.com/sass/sass\">sass</a> :</p>\n<pre><code class=\"hljs language-bash\">npm install sass\n</code></pre>\n<blockquote>\n<p>Sass 支持 2 种语法格式定义来样式，<code>.scss</code>文件使用<a href=\"https://sass-lang.com/documentation/syntax#scss\">SCSS 语法</a> ，<code>.sass</code>文件使用 <a href=\"https://sass-lang.com/documentation/syntax#the-indented-syntax\">Indented Syntax (&quot;Sass&quot;)</a> 语法。\n如果你不确定使用哪种语法，可首先采用<code>.scss</code>，它是 CSS 的扩展，可使用 CSS 的全部语法，不需要学习新的 Indented Syntax 缩进语法。</p>\n</blockquote>\n\n                <h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-sass-%E9%85%8D%E7%BD%AE\">\n                  自定义 Sass 配置\n                </h3><p>在 <code>joy.config.js</code> 的 <code>sassOptions</code> 字段中定义 Sass 的自定义配置, 具体可配置项参考 <a href=\"https://webpack.js.org/loaders/sass-loader/\">sass-loader</a> 的配置。</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;path&quot;</span>);\n\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">sassOptions</span>: {\n    <span class=\"hljs-attr\">additionalData</span>: <span class=\"hljs-string\">&quot;$env: &quot;</span> + process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">NODE_ENV</span> + <span class=\"hljs-string\">&quot;;&quot;</span>,\n    <span class=\"hljs-attr\">indentWidth</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">includePaths</span>: [<span class=\"hljs-string\">&quot;/absolute/path/a&quot;</span>, <span class=\"hljs-string\">&quot;/absolute/path/b&quot;</span>],\n  },\n};\n</code></pre>\n\n                <h3 id=\"sass-%E5%8F%98%E9%87%8F\">\n                  Sass 变量\n                </h3><p>Joy 支持 Sass 变量从 CSS Module 文件中导出。比如导出<code>primaryColor</code>变量：</p>\n<pre><code class=\"hljs language-scss\"><span class=\"hljs-comment\">/* index-scss-variables.scss */</span>\n<span class=\"hljs-variable\">$primary-color</span>: <span class=\"hljs-number\">#ff0000</span>;\n\n:export {\n  primaryColor: <span class=\"hljs-variable\">$primary-color</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// index-scss-variables.js</span>\n<span class=\"hljs-keyword\">import</span> variables <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;../index-scss-variables.scss&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MyApp</span>(<span class=\"hljs-params\">{ Component, pageProps }</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">variables.primaryColor</span> }}&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n}\n</code></pre>\n\n                <h2 id=\"todo\">\n                  todo\n                </h2><ul>\n<li>自定义 PostCss <a href=\"https://nextjs.org/docs/advanced-features/customizing-postcss-config\">https://nextjs.org/docs/advanced-features/customizing-postcss-config</a></li>\n</ul>\n","anchor":[{"type":"heading","raw":"## 应用全局样式\n\n","depth":2,"text":"应用全局样式","tokens":[{"type":"text","raw":"应用全局样式","text":"应用全局样式"}],"id":"#%E5%BA%94%E7%94%A8%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F"},{"type":"heading","raw":"## CSS 模块导入\n\n","depth":2,"text":"CSS 模块导入","tokens":[{"type":"text","raw":"CSS 模块导入","text":"CSS 模块导入"}],"id":"#css-%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5","children":[{"type":"heading","raw":"### CSS Modules 导入\n\n","depth":3,"text":"CSS Modules 导入","tokens":[{"type":"text","raw":"CSS Modules 导入","text":"CSS Modules 导入"}],"id":"#css-modules-%E5%AF%BC%E5%85%A5"},{"type":"heading","raw":"### 全局样式导入\n\n","depth":3,"text":"全局样式导入","tokens":[{"type":"text","raw":"全局样式导入","text":"全局样式导入"}],"id":"#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E5%AF%BC%E5%85%A5"}]},{"type":"heading","raw":"## 使用 LESS\n\n","depth":2,"text":"使用 LESS","tokens":[{"type":"text","raw":"使用 LESS","text":"使用 LESS"}],"id":"#%E4%BD%BF%E7%94%A8-less","children":[{"type":"heading","raw":"### 自定义 LESS 配置\n\n","depth":3,"text":"自定义 LESS 配置","tokens":[{"type":"text","raw":"自定义 LESS 配置","text":"自定义 LESS 配置"}],"id":"#%E8%87%AA%E5%AE%9A%E4%B9%89-less-%E9%85%8D%E7%BD%AE"}]},{"type":"heading","raw":"## 使用 Sass\n\n","depth":2,"text":"使用 Sass","tokens":[{"type":"text","raw":"使用 Sass","text":"使用 Sass"}],"id":"#%E4%BD%BF%E7%94%A8-sass","children":[{"type":"heading","raw":"### 自定义 Sass 配置\n\n","depth":3,"text":"自定义 Sass 配置","tokens":[{"type":"text","raw":"自定义 Sass 配置","text":"自定义 Sass 配置"}],"id":"#%E8%87%AA%E5%AE%9A%E4%B9%89-sass-%E9%85%8D%E7%BD%AE"},{"type":"heading","raw":"### Sass 变量\n\n","depth":3,"text":"Sass 变量","tokens":[{"type":"text","raw":"Sass 变量","text":"Sass 变量"}],"id":"#sass-%E5%8F%98%E9%87%8F"}]},{"type":"heading","raw":"## todo\n\n","depth":2,"text":"todo","tokens":[{"type":"text","raw":"todo","text":"todo"}],"id":"#todo"}]},{"title":"使用图片","path":"/joy/react/use-image","file":"docs\\joy\\02-react\\06-use-image.md","hasMenu":false,"mdContent":"# 使用图片\r\n\r\n## 静态导入\r\n\r\nJoy 应用中可以直接静态导入图片模块， 支持的图片格式有: `png|jpg|jpeg|gif|webp|avif|ico|bmp|svg`。\r\n\r\n下面例子中，我们导入图片，并设置给 `img` 标签来展示图片:\r\n\r\n```tsx\r\nimport imgMe from \"./me.png\";\r\n// or const imgMe = require(\"./me.png\")\r\n\r\nfunction Avator() {\r\n  return <img src={imgMe.src} width={imgMe.width} height={imgMe.heigh} />;\r\n}\r\n```\r\n\r\n导入的变量类型为`StaticImageData`，包含加载地址和大小等信息：\r\n\r\n```ts\r\ninterface StaticImageData {\r\n  src: string;\r\n  width: number;\r\n  height: number;\r\n  blurDataURL?: string;\r\n}\r\n```\r\n\r\n- **src** Type: string, 图片加载在线地址，类似： `/_joy/static/media/xxxx.png`。\r\n- **width** Type: number, 图片的宽度，单位像素。\r\n- **height** Type: number, 图片的高度，单位像素。\r\n- **blurDataURL** Type: string, 图片预览图，默认为 `8 * 8`像素的缩略图，生产模式打包时值为 Base64 的 DataUrl， 开发模式时值为缩略的在线生成地址。\r\n\r\n## CSS 中使用图片\r\n\r\n```css\r\n.logo {\r\n  background: url(\"./logo.png\");\r\n}\r\n``` \r\n\r\n## 引用静态文件图片\r\n\r\nJoy 提供内建静态文件服务，将图片放入项目的`public`目录下，即可通过URL路径访问该图片。\r\n\r\n例如： 我们将图片放入 `public/logo.png` 路径下，在`img`标签里引用该图片。\r\n\r\n```tsx\r\n  return <img src=\"/logo.png\" />;\r\n```\r\n\r\n\r\n## Image 组件和图片优化\r\n\r\nJoy `Image` 组件是 HTML `<img>` 标签的扩展， 它集成了一系列的性能优化操作，为应用提供更好的用户体验。\r\n\r\n一些内建的优化操作有：\r\n\r\n- 提升加载性能： 在不同的设备上，自动加载适应屏幕尺寸的图片，并使用优化的图片格式，例如 `webp`。\r\n- 防止累积布局偏移：固定图片布局，防止图片在加载过程中导致界面布局跳动。\r\n- 加快页面加载：图片仅在它可见是才加载，在加载之前，也可展示模糊的缩略图。\r\n- 灵活提供图片资源：服务端实时的提供各种尺寸和格式的图片，即使图片存储在远程的服务器上。\r\n\r\n### 使用本地图片\r\n\r\n使用本地图片，首先使用相对地址导入图片，然后赋值给 `Image` 组件的`src`属性。 本地图片在导入时，Joy 会检查其高宽，自动设置 `width` 和 `height` 属性， 防止图片加载过程中布局跳动。\r\n\r\n```tsx\r\nimport Image from \"@symph/joy/react\";\r\nimport logoImg from \"./logo.png\";\r\n\r\nfunction Home() {\r\n  return (\r\n    <>\r\n      <h1>HomePage</h1>\r\n      <Image\r\n        src={logoImg}\r\n        alt=\"logo\"\r\n        // width={100} 未设置时，默认采用图片的宽度。\r\n        // height={100} 未设置时，默认采用图片的高度。\r\n        // blurDataURL=\"data:...\" 未设置时，默认使用原\r\n        //\r\n        // 始图片 8 * 8 的模糊缩略图。\r\n        // placeholder=\"blur\" // 默认使用模糊缩略图，或者设置为 empty 空白\r\n      />\r\n      <p>Welcome to my homepage!</p>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n### 使用远程图片\r\n\r\n使用远程图片和本地图片类似，只是 `src` 属性设置为远程图片的相对或绝对字符串 URL 地址。 因为在编译时 Joy 不能访问远程图片，所以不能得到图片的高宽，我们需要明确的手动指定图片的 `width` 和 `height` 属性。\r\n\r\n```tsx\r\nimport Image from \"@symph/joy/react\";\r\nimport logoImg from \"./logo.png\";\r\n\r\nfunction Home() {\r\n  return (\r\n    <>\r\n      <h1>HomePage</h1>\r\n      <Image\r\n        src=\"/logo.png\" // 图片的 URL 相对路径。\r\n        alt=\"logo\"\r\n        width={100}\r\n        height={100}\r\n      />\r\n      <p>Welcome to my homepage!</p>`\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n如果是外部域名，例如：`https://example1.com/logo.png` ，我们应该添加`domians`配置来设置安全域白名单，保护我们的应用程序不被恶意的用户破坏，不在这些域名内的图片，将拒绝提供图片优化服务。\r\n在 `joy.config.js`中设置 `domains`来指定安全域，例如：\r\n\r\n```js\r\nmodule.exports = {\r\n  images: {\r\n    domains: [\"example1.com\", \"example2.com\"],\r\n  },\r\n};\r\n```\r\n\r\n### 图片尺寸\r\n\r\n图片影响用户体验的最常见的场景是改不布局，如图片在加载过程中推动其它元素。这对用户来说是非常糟糕的体验，以至于产生了一个核心指标 [累积布局偏移 CLS](https://web.dev/cls/) 来量化用户经历意外布局偏移的频率。\r\n避免因图片加载导致布局偏移的方法是始终设置图片的大小，这让浏览器在加载之前为图片预留足够的空间。\r\n\r\n`Image` 组件是为了保证良好的性能结果而设计的，所以它会采用以下 3 中方式来确定图片大小，防止布局变化：\r\n\r\n1. 自动识别大小， 当采用静态导入的时候。\r\n2. 明确指定大小， 使用 `width` 和 `height` 属性明确设置图片大小。\r\n3. 隐式声明， 设置属性 `layout=\"fill\"`，使图片缩放适配其父元素大小。\r\n\r\n另外图片文件大小也是影响页面加载性能的重要因素之一，加载图片时，`Image` 组价计算出图片展示尺寸后，会从 `[16, 32, 48, 64, 96, 128, 256, 384, ...]`等尺寸规格中选取比当前展示尺寸大一号的图片版本，例如图片展示宽度为 `80px`，会加载`96px`规格的图片副本。\r\n并且副本图片会优先采用`webp`或者`avif`等压缩率和压缩质量较高的图片格式，进一步减小图片的文件大小。\r\n\r\n### 加载优先级\r\n\r\n我们应该为任何的 [最大内容绘制 LCP](https://web.dev/lcp) 的图片元素设置 `priority` 属性，从而让 Joy 优先加载图片（通过预加载标签和优先级属性实现 ），减少最大内容绘制耗时。\r\n\r\n通常最大内容绘制元素是页面可视区域内的大尺寸图片或者文本块，当使用 `joy dev` 开发模式运行应用时，如果一个最大内容绘制元素的`Image` 组件未设置 `priority`属性，将会在 console 里收到一条提示信息。\r\n\r\n### 内置图片优化服务\r\n\r\nJoy 内置图片优化服务，该服务可以优化 web 上的任何图像，然后从 Joy 的内置 web 服务器对外提供这些优化后图像。\r\n\r\n从以下几个优化面：\r\n\r\n- 根据界面布局大小，使用缩小版的图片。\r\n- 转换为压缩质量更高的图片格式，例如 `webp`。\r\n- 提供低质量的图片，提升加载速度。\r\n- 设置图片资源缓存，有效利用浏览器缓存。\r\n\r\n该服务对外提供 API GET 接口： `/_joy/image`， 接口参数：\r\n\r\n- `url`: `string` 必须，图片的下载地址，可以是本地相对或绝对路径，或者远程绝对路径。\r\n- `w`: `number` 必须，图片的宽度，等比缩放图片使宽度等于该值。\r\n- `q`: `number` 非必须，图片的压缩质量百分比，取 0 到 100 的整数，默认 75。\r\n- `mimeType`：隐藏参数，无需设置，通过请求 header 的`accept`自动获取，例如浏览器支持 `accept: image/webp`,将优先返回 `webp`格式，否则返回原图片格式。\r\n\r\n例如我们希望获取宽度 32px，压缩质量 75%、格式为`webp`的图片，完整的请求 URL 路径为：`http://localhost:3000/_joy/image/?url=%2Fexample.png&w=32&q=75`\r\n\r\n> 该服务内部默认使用 [`squoosh`](https://www.npmjs.com/package/@squoosh/lib) 库来加工图片，因为它安装起来很快，而且适合于开发环境。\r\n> 在生成环境中，建议替换为[`sharp`](https://www.npmjs.com/package/sharp)工具，在项目目录中运行 `yarn add sharp` 来安装 [`sharp`](https://www.npmjs.com/package/sharp)，安装成功后重启应用，会自动切换为 [`sharp`](https://www.npmjs.com/package/sharp)。\r\n> `sharp` 比 `squoosh` 能更快更高效的处理图片，由于 `sharp` 在安装时会下载其底层依赖`libvips`包，受网络环境的影响较大，安装很缓慢且容易失败，所以在开发环境使用安装更轻便的`squoosh`。\r\n\r\n### 图片加载器\r\n\r\n通过设置图片的 `loader` 属性指定加载器，图片加载器是一个方法，用于生成图片 URL 地址或者多尺寸的图片地址集合，地址集合将用于生成 `<img />`标签的`srcset`属性，从而为用户提供满足他们展示设备的大小图片。\r\n\r\nJoy 应用的默认加载器 ` default` 使用内置的图片优化服务 API。\r\n如果我们想直接从 CDN 或其它图像服务器上获取图片，可以用几行 JavaScript 实现一个新的加载器，使用一个 Joy 内置的加载器。\r\n\r\n下面示例展示如何使用 Imgix 服务商提供的图片服务，首先配置图片模块，设置全局的默认加载器为内置的 `imgix`，也可以不用全局配置，在`Image`组件内设置每个组件自己的加载器。\r\n\r\n```ts\r\n// joy.confing.js\r\nmodule.exports = {\r\n  images: {\r\n    loader: \"imgix\",\r\n    path: \"https://static.imgix.net\",\r\n  },\r\n};\r\n```\r\n\r\n在`Image`组件内定义图片路径和大小等信息：\r\n\r\n```tsx\r\n<Image src=\"/daisy.png\" width={300} qulity={75} />\r\n```\r\n\r\n上面的例子中，最终图片加载地址类似于：`https://static.imgix.net/daisy.png?auto=format&fit=max&w=300&q=75`\r\n\r\n### 图片样式\r\n\r\n`Image` 组件和标准的 `<img >`标签在样式设置上没有太大不同，下面是一些需要注意的指导建议：\r\n\r\n- 使用 `className` 来查询图片和定义样式，不应该依赖 DOM 结构， `Image` 组件是一个复合组件，里面使用 `<span>`标签包裹`<img>`标签，在某些情况下，我们并不能使用 DOM 结构精确的定位到图片。\r\n- 使用正确的布局模式，`Image` 组件提供了几种不同的布局模式来定义它在页面上的大小。\r\n- 当 `layout=\"fill\"` 时，其父元素的样式必须包含 `position: relative`。\r\n- 的 `layout=\"responsive\"` 时，其父元素样式必须包含 `display: block`。\r\n\r\n### Image 组件属性\r\n\r\n#### src\r\n\r\n属性名称：`src`，类型：`string|StaticImport`，默认值：`-`，必须：`true`\r\n\r\n必须是下列之一：\r\n\r\n- 静态导入`import`的图片对象。\r\n- 字符串，可以是一个绝对的外部 URL，也可以是一个内部路径，这取决于配置的`loader`。\r\n\r\n使用外部 URL，我们应该设置安全域（在应用配置里添加`images.domains`配置）.\r\n\r\n#### width\r\n\r\n属性名称：`width`，类型：`number`，默认值：`undefined`，必须：`false`\r\n\r\n图片的宽度，输入整数的像素值。\r\n必须设置该属性，除非是静态导入的图片或者`layout=\"fill\"`时。\r\n\r\n#### height\r\n\r\n属性名称：`height`，类型：`number`，默认值：`undefined`，必须：`false`\r\n\r\n图片的宽度，输入整数的像素值。\r\n必须设置该属性，除非是静态导入的图片或者`layout=\"fill\"`的时。\r\n\r\n#### loader\r\n\r\n属性名称：`loader`，类型：`(resolverProps:ImageLoaderProps) => string`，默认值：`undefined`，必须：`false`\r\n\r\n`loader` 是一个自定义方法，使用图片的属性来生成完整 URL 地址，接受以下参数：\r\n\r\n- `src`: `string` 图片的相对或绝对路径。\r\n- `width`: `number` 期望加载图片的宽度。\r\n- `quality`: `number` 期望加载图片的压缩质量。\r\n- `config`: `ImageConfig` 图片模块的配置。\r\n\r\n下面是一个自定义的加载器示例：\r\n\r\n```tsx\r\nimport Image from \"@symph/joy/react\";\r\n\r\nconst myLoader = ({ src, width, quality }) => {\r\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`;\r\n};\r\n\r\nconst MyImage = (props) => {\r\n  return <Image loader={myLoader} src=\"me.png\" alt=\"Picture of the author\" width={500} height={500} />;\r\n};\r\n```\r\n\r\nJoy 内建了一些云服务提供商的图片加载器，我们可以在应用配置点 `images.loader` 上, 设置默认图片加载器。\r\n\r\n#### layout\r\n\r\n属性名称：`layout`，类型： `\"intrinsic\"|\"fixed\"|\"responsive\"|\"fill\"`，默认值：`\"intrinsic\"`，必须：`false`\r\n\r\n通过 `layout`属性设置布局模式，用于定义图片布局将随窗口变化时如何变化，Joy 内置了以下 4 种布局模式：\r\n\r\n- `intrinsic`\r\n  默认布局，当父容器的宽度小于图片组件的宽度时，缩小图片尺寸以适应父容器的宽度，当父容器的宽度大于图片组件的宽度时，会展示图片组件的固定宽度。\r\n  受影响的属性：\r\n\r\n  - `srcSet`： 基于当前图片组件的尺寸，从 `imageSizes` 中选取和组件尺寸相同或大一号的尺寸，生成 `srcSet` 中 `1x`，`2x`的图片。\r\n  - `sizes`: 该属性值无效。\r\n\r\n- `fixed` 图片组件的尺寸不会随着父容器的大小改变而改变，这个标准的`img`标签的表现一样。\r\n  受影响的属性：\r\n\r\n  - `srcSet`： 基于当前图片组件的尺寸，从 `imageSizes` 中选取和组件尺寸相同或大一号的尺寸，生成 `srcSet` 中 `1x`，`2x`的图片。\r\n  - `sizes`: 该属性值无效。\r\n\r\n- `responsive` 图片组件将缩放适应父元素的宽度，父元素需要样式需包含 `display: block`。\r\n  在不同的窗口尺寸下，组件将加载对应尺寸的图片。例如：在`1080px`宽度的窗口上加载 `1080px` 版本的图片，在`1920px`宽度的窗口上加载 `1920px`版本的图片。\r\n  受影响的属性：\r\n\r\n  - `srcSet`： 将 `imageSizes` 和 `deviceSizes` 定义的所有尺寸生成 `srcSet` 列表，以便可以响应式的加载对应尺寸的图片。\r\n  - `sizes`: 默认为 `100vw`。\r\n\r\n- `fill` 图片组件宽度和高度将拉伸到父元素的尺寸，父元素需要是相对布局的，样式需包含 `position: relative `。\r\n  配合 `objectFit` 属性定义拉伸缩放模式，例如：`fill` 拉伸填充， `contain` 包含等。\r\n  受影响的属性：\r\n\r\n  - `srcSet`： 将 `imageSizes` 和 `deviceSizes` 定义的所有尺寸生成 `srcSet` 列表，以便可以响应式的加载对应尺寸的图片。\r\n  - `sizes`: 默认为 `100vw`。\r\n\r\n#### sizes\r\n\r\n属性名称：`sizes`，类型： `string`，默认值：`undefined`，必须：`false`\r\n\r\n指定不同页面布局的图像大小了， 例如：`sizes=\"(max-width: 360px) 340px, 128px\"`，表示当视区宽度不大于 360 像素时候，图片的宽度限制为 340 像素，其他情况下，使用 128 像素。\r\n\r\n当 `layout=\"responsive\"` 或者 `layout=\"fill\"` 时，默认值时 `100vw` 即占满整个窗口，我们可以设置更小的值，使图片小于窗口的宽度。\r\n\r\n当 `layout=\"intrinsic\"` 或者 `layout=\"fixed\"` 时，`sizes`属性是无效的，因为它依赖的是父容器边界大小。\r\n\r\n[了解更多](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes)\r\n\r\n#### objectFit\r\n\r\n属性名称：`objectFit`，类型： `string`，默认值：`undefined`，必须：`false`\r\n\r\n当 `layout=\"fill\"`时，定义图片如何填充父元素， 如：\r\n\r\n- `fill` 图片拉伸填充整个父容器。\r\n- `container`图片等比放大后填满父容器的整个宽度或高度。\r\n- `cover` 图片等比放大覆盖整个父容器。\r\n- `none` 图片缩放，在父容器中心按原尺寸展示图片。\r\n\r\n该属性将直接传递给 `img` 的 [`object-fit`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) 属性。\r\n\r\n#### objectPosition\r\n\r\n属性名称：`objectPosition`，类型： `string`，默认值：`undefined`，必须：`false`\r\n\r\n当 `layout=\"fill\"`时，定义图片在父元素的布局位置，例如： `\"right top\"`\r\n\r\n该属性将直接传递给 `img` 的 [`object-position`](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position) 属性。\r\n\r\n#### quality\r\n\r\n属性名称：`quality`，类型： `number`，默认值：`75`，必须：`false`\r\n\r\n`quality`属性设置加载什么质量的图片，质量是相对于原图片的压缩质量，取 `1` 到 `100` 的整数，默认值 `75`。\r\n数值越高质量越好，同时图片的文件大小也会越大。\r\n\r\n#### priority\r\n\r\n属性名称：`priority`，类型： `bool`，默认值：`false`，必须：`false`\r\n\r\n如果为 `true` 图片将尽量优先加载，图片延迟加载将自动关闭。\r\n\r\n我们应该为任何的 [最大内容绘制 LCP](https://web.dev/lcp) 的图片元素设置 `priority` 属性。\r\n\r\n#### loading\r\n\r\n属性名称：`loading`，类型： `string`，默认值：`lazy`，必须：`false`\r\n\r\n设置图片的加载时机。\r\n\r\n- `lazy` 延迟加载图片，当图片滚动到可视区域时才开始加载图片。\r\n- `eager` 立即加载图片。\r\n\r\n> 请尽量保持默认的 `lazy` 模式，立即加载 `eager` 模式，在大多数情况下会影响网页的加载性能。如需尽快加载图片，推荐使用 `priority` 属性。\r\n\r\n#### lazyBoundary\r\n\r\n属性名称：`lazyBoundary`，类型： `string`，默认值：`\"200px\"`，必须：`false`\r\n\r\n当图片延迟加载时，检查图片到可视区域的距离阈值，当小于这个阈值时，即视为图片即将展示，需立即开始加载图片，触发加载过程。\r\n\r\n如果图片时嵌入在一个内部可滚动的父容器中，需要通过`lazyRoot`属性指定父容器，使用父容器的滚动位置来计算可视区域，而不是直接使用 document 的滚动位置。\r\n\r\n#### lazyRoot\r\n\r\n属性名称：`lazyRoot`，类型： `ref`，默认值：`null`，必须：`false`\r\n\r\n设置一个 [React Ref](https://reactjs.org/docs/refs-and-the-dom.html) ，指向滚动的父容器。默认值 `null`，表示 document。\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport Image from \"@symph/joy/react\";\r\n\r\nconst lazyRoot = React.useRef(null);\r\n\r\nconst Example = () => (\r\n  <div ref={lazyRoot} style={{ overflowX: \"scroll\", width: \"500px\" }}>\r\n    <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n    <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n  </div>\r\n);\r\n```\r\n\r\nRef 必须指向一个 DOM 元素，而不是 React Component 复合组件。如果父元素是 React Component 中，可以使用 [forwarding-refs](https://reactjs.org/docs/forwarding-refs.html) 方法，将引用指向其内部 DOM 元素。例如：\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport Image from \"@symph/joy/react\";\r\n\r\nconst Container = React.forwardRef((props, ref) => {\r\n  return (\r\n    <div ref={ref} style={{ overflowX: \"scroll\", width: \"500px\" }}>\r\n      {props.children}\r\n    </div>\r\n  );\r\n});\r\n\r\nconst Example = () => {\r\n  const lazyRoot = React.useRef(null);\r\n\r\n  return (\r\n    <Container ref={lazyRoot}>\r\n      <Image lazyRoot={lazyRoot} src=\"/one.jpg\" width=\"500\" height=\"500\" />\r\n      <Image lazyRoot={lazyRoot} src=\"/two.jpg\" width=\"500\" height=\"500\" />\r\n    </Container>\r\n  );\r\n};\r\n```\r\n\r\n#### placeholder\r\n\r\n属性名称：`placeholder`，类型： `\"blur\"|\"empty\"`，默认值：`\"empty\"`，必须：`false`\r\n\r\n`placeholder`属性设置图片加载中的占位图，提供 `blur`和`emtpy`两个选项，默认值：`emtpy`。\r\n\r\n当 `placeholder=\"blur\"` 时，使用`blurDataURL`图片来显示占位图。 如果 `src` 设置的是静态`import`的图片对象，如：导入的`.jpg`、`.png`、`.webp`等，`blurDataURL`属性将自动从导入对象中取值。\r\n如是是动态加载的远程图片，需要手动提供 `blurDataURL` 属性。\r\n\r\n当 `placeholder=\"blemtpyur\"`时，图片在加载过程中，将保留空白的区域，无任何的展位图。\r\n\r\n#### blurDataURL\r\n\r\n属性名称：`placeholder`，类型： `string`，默认值：`undefined`，必须：`false`\r\n\r\n当 `placeholder=\"blur\"`时，使用 `blurDataURL` 的内容来展示占位图，值必须是 Base64 编码的 DataUrl 字符串。\r\n占位图会被放大和模糊，所以建议使用非常小的图像(10px 或更小)，Joy 静态导入的图片，默认是 8px 的缩略图。\r\n\r\n#### unoptimized\r\n\r\n属性名称：`unoptimized`，类型： `bool`，默认值：`false`，必须：`false`\r\n\r\n为 `true` 时，关闭图片优化，将使用图片的源文件，不会使用经过大小、质量和格式优化后的图片。\r\n\r\n#### onLoadingComplete\r\n\r\n属性名称：`onLoadingComplete`，类型： `function`，默认值：`undefiend`，必须：`false`\r\n\r\n图片加载完成后的回调函数，接受 1 个对象参数，对象参数有以下属性：\r\n\r\n- [`naturalWidth` ](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalWidth)\r\n- [`naturalHeight`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalHeight)\r\n\r\n#### others\r\n\r\n赋值给`<Image >`组件的其它属性，将直接传递给内部的 `img` 标签。有以下几点需注意：\r\n\r\n- `style`属性，请使用 `className` 方式替换，不能直接给图片组件内联样式。\r\n- `srcSet`属性，请配置`images.deviceSize`项，设置可支持的设备窗口大小列表，组件会自动计算出合适的`srcSet`集合。\r\n- `ref`属性，请使用`onLoadingComplete`替换，如需获取图片的信息，可在该回调函数中获取。\r\n- `decoding` 属性需一直保持为 `\"async\"`。\r\n\r\n### 图片模块配置\r\n\r\n`Image` 组件和图片优化服务可以在应用配置的`images`节点中自定义配置。\r\n下面是应用的默认配置示例：\r\n\r\n```ts\r\nmodule.exports = {\r\n  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\r\n  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\r\n  path: \"/_joy/image\",\r\n  loader: \"default\",\r\n  domains: [],\r\n  disableStaticImages: false,\r\n  minimumCacheTTL: 60,\r\n  formats: [\"image/webp\"],\r\n  dangerouslyAllowSVG: false,\r\n  contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,\r\n  unoptimized: false,\r\n};\r\n```\r\n\r\n#### domains\r\n\r\n配置名称：`domains`，类型： `stirng[]`，默认值：`[]`，必须：`false`\r\n\r\n当使用其它域名的远程图片时，为了保护我们的应用程序不被恶意的用户破坏，`domains`配置远程图片所在域名的白名单，不在这些域名内的图片，`Image` 组件和图片优化将拒绝服务。\r\n\r\n#### loader\r\n\r\n配置名称：`loader`，类型： `string`，默认值：`\"default\"`，必须：`false`\r\n\r\n如果我们想不使用 Joy 内建的图片服务， 而想使用其它云服务商提供的图片存储和优化服务，可以配置 `loader` 参数来切换图片加载方式。\r\n一般结合 `path` 参数使用， `path`参数设置图片的 URL 地址前缀，而后在`Image`的 src 属性上，只需设置图片的相对路径。\r\n\r\n```tsx\r\nmodule.exports = {\r\n  images: {\r\n    loader: \"imgix\",\r\n    path: \"https://static.imgix.net\",\r\n  },\r\n};\r\n```\r\n\r\nJoy 提供了以下内置加载器：\r\n\r\n- `default` : 使用内置图片优化服务的加载器。\r\n- `imgix`: 使用 [Imgix](https://imgix.com/) 服务商提供的图片服务。\r\n- `cloudinary`: 使用 [Cloudinary](https://cloudinary.com/) 服务商提供的图片服务。\r\n- `akamai`: 使用 [Akamai](https://www.akamai.com/) 服务商提供的图片服务。\r\n- `custom`: 使用自定义的云服务，设置该选项后，每个`Image` 组件必须设置自定义的`loader`属性。\r\n\r\n#### path\r\n\r\n配置名称：`path`，类型： `string`，默认值：`\"/_joy/image\"`，必须：`false`\r\n\r\n在默认 `loader=\"default\"` 时， path 的默认值是 `\"/_joy/image\"`， 即使用 Joy 内置的图片优化服务。\r\n\r\n如果使用其它图片服务，可以设置`path`配置图片的统一 URL 地址前缀，而后在`Image`的 src 属性上只需设置图片的相对路径，运行时将两者合并生成完整的图片地址。\r\n\r\n#### deviceSizes\r\n\r\n配置名称：`deviceSizes`，类型： `number[]`，默认值：`[640, 750, 828, 1080, 1200, 1920, 2048, 3840]`，必须：`false`\r\n\r\n当我们明确知道用户设备的宽度有哪些时，我们可以设置一个列表将这些宽度分段，在分段区间的内，加载对应尺寸的图片，从而让用户在各种尺寸的屏幕上，都可以获得较好的体验。\r\n这些设备宽度仅会在`Image` 组件 `layout=\"responsive\"` 或 `layout=\"fill\"` 时使用得到。\r\n\r\n#### imageSizes\r\n\r\n配置名称：`imageSizes`，类型： `number[]`，默认值：`[16, 32, 48, 64, 96, 128, 256, 384]`，必须：`false`\r\n\r\n我们可以设置图片的宽度列表，这些宽度与`deviceSizes` 数组连接在一起，用于生成图像 srcsets 的完整大小数组。\r\n\r\n之所以有两个单独的宽度列表，是因为 `imageSizes` 只用于设置了`sizes`属性的图片，即图片的宽度小于全尺寸的屏幕宽度。因此，`imageSizes` 中的大小应该都小于`deviceSizes`中的最小大小。\r\n\r\n#### formats\r\n\r\n配置名称：`formats`，类型： `string[]`，默认值：`[\"image/webp\"]`，必须：`false`\r\n\r\n如果请求的`Accept`头能匹配配置列表中的多个格式，则使用数组中的第一个匹配项作为返回格式。因此，数组的顺序很重要。如果没有匹配的格式，将返回原始图像的格式。\r\n\r\n例如我们想优先使用`image/avif`，如果浏览器不支持 avif，则再检查是否支持 'image/webp' 格式，如果还不支持，则返回图片原格式，可以这样编写配置：\r\n\r\n```ts\r\nmodule.exports = {\r\n  images: {\r\n    formats: [\"image/avif\", \"image/webp\"],\r\n  },\r\n};\r\n```\r\n\r\n> AVIF 编码通常要多花 20%的时间，但它比 WebP 多压缩了 20%的空间。这意味着第一次请求图片时，它通常会缓慢点，而缓存后，后续请求会变快。\r\n\r\n#### minimumCacheTTL\r\n\r\n配置名称：`minimumCacheTTL`，类型： `number`，默认值：`60`，必须：`false`\r\n\r\n设置图片的在优化服务内的最小缓存时长，单位秒。\r\n大多数情况下，建议使用使用 [静态导入](#静态导入) 的方式加载图片，这将自动为图片生成一个唯一的 hash 值，并设置`Cache-Control`为`immutable`，使图片长期有效。\r\n\r\n#### disableStaticImages\r\n\r\n配置名称：`disableStaticImages`，类型： `bool`，默认值：`false`，必须：`false`\r\n\r\n默认情况下，我们可以直接静态导入图片，如 `import logo from \"./logo.png\"`，然后设置给图片组件的 `src`属性。\r\n\r\n但有时候，如果静态导入和其它插件冲突，或者想自定义 webpack 插件以实现不同的导入方式，我们可以设置为`false`关闭默认的图片导入插件。\r\n\r\n#### dangerouslyAllowSVG\r\n\r\n配置名称：`dangerouslyAllowSVG`，类型： `bool`，默认值：`false`，必须：`false`\r\n\r\n默认 Joy 的内置图片优化服务不会对 SVG 格式的图片进行优化。\r\n首先，SVG 是一种矢量格式，这意味着它可以无损地调整大小。其次，SVG 有许多与 HTML/CSS 相同的特性，如果没有适当的内容安全策略(CSP)头，这些特性可能会导致漏洞。\r\n\r\n如果想内置的图片优化服务提供 SVG 图片格式，可以启用该功能，并设置适当的内容安全策略。\r\n\r\n```ts\r\nmodule.exports = {\r\n  images: {\r\n    dangerouslyAllowSVG: true,\r\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\r\n  },\r\n};\r\n```\r\n","htmlContent":"\n                <h1 id=\"%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87\">\n                  使用图片\n                </h1>\n                <h2 id=\"%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5\">\n                  静态导入\n                </h2><p>Joy 应用中可以直接静态导入图片模块， 支持的图片格式有: <code>png|jpg|jpeg|gif|webp|avif|ico|bmp|svg</code>。</p>\n<p>下面例子中，我们导入图片，并设置给 <code>img</code> 标签来展示图片:</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> imgMe <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./me.png&quot;</span>;\n<span class=\"hljs-comment\">// or const imgMe = require(&quot;./me.png&quot;)</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Avator</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{imgMe.src}</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{imgMe.width}</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{imgMe.heigh}</span> /&gt;</span></span>;\n}\n</code></pre>\n<p>导入的变量类型为<code>StaticImageData</code>，包含加载地址和大小等信息：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">StaticImageData</span> {\n  <span class=\"hljs-attr\">src</span>: <span class=\"hljs-built_in\">string</span>;\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-built_in\">number</span>;\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">number</span>;\n  blurDataURL?: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<ul>\n<li><strong>src</strong> Type: string, 图片加载在线地址，类似： <code>/_joy/static/media/xxxx.png</code>。</li>\n<li><strong>width</strong> Type: number, 图片的宽度，单位像素。</li>\n<li><strong>height</strong> Type: number, 图片的高度，单位像素。</li>\n<li><strong>blurDataURL</strong> Type: string, 图片预览图，默认为 <code>8 * 8</code>像素的缩略图，生产模式打包时值为 Base64 的 DataUrl， 开发模式时值为缩略的在线生成地址。</li>\n</ul>\n\n                <h2 id=\"css-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87\">\n                  CSS 中使用图片\n                </h2><pre><code class=\"hljs language-css\"><span class=\"hljs-selector-class\">.logo</span> {\n  <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">&quot;./logo.png&quot;</span>);\n}\n</code></pre>\n\n                <h2 id=\"%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87\">\n                  引用静态文件图片\n                </h2><p>Joy 提供内建静态文件服务，将图片放入项目的<code>public</code>目录下，即可通过URL路径访问该图片。</p>\n<p>例如： 我们将图片放入 <code>public/logo.png</code> 路径下，在<code>img</code>标签里引用该图片。</p>\n<pre><code class=\"hljs language-tsx\">  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/logo.png&quot;</span> /&gt;</span></span>;\n</code></pre>\n\n                <h2 id=\"image-%E7%BB%84%E4%BB%B6%E5%92%8C%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96\">\n                  Image 组件和图片优化\n                </h2><p>Joy <code>Image</code> 组件是 HTML <code>&lt;img&gt;</code> 标签的扩展， 它集成了一系列的性能优化操作，为应用提供更好的用户体验。</p>\n<p>一些内建的优化操作有：</p>\n<ul>\n<li>提升加载性能： 在不同的设备上，自动加载适应屏幕尺寸的图片，并使用优化的图片格式，例如 <code>webp</code>。</li>\n<li>防止累积布局偏移：固定图片布局，防止图片在加载过程中导致界面布局跳动。</li>\n<li>加快页面加载：图片仅在它可见是才加载，在加载之前，也可展示模糊的缩略图。</li>\n<li>灵活提供图片资源：服务端实时的提供各种尺寸和格式的图片，即使图片存储在远程的服务器上。</li>\n</ul>\n\n                <h3 id=\"%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87\">\n                  使用本地图片\n                </h3><p>使用本地图片，首先使用相对地址导入图片，然后赋值给 <code>Image</code> 组件的<code>src</code>属性。 本地图片在导入时，Joy 会检查其高宽，自动设置 <code>width</code> 和 <code>height</code> 属性， 防止图片加载过程中布局跳动。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> logoImg <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./logo.png&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>HomePage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span>\n        <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{logoImg}</span>\n        <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span>\n        // <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{100}</span> 未设置时，默认采用图片的宽度。\n        // <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{100}</span> 未设置时，默认采用图片的高度。\n        // <span class=\"hljs-attr\">blurDataURL</span>=<span class=\"hljs-string\">&quot;data:...&quot;</span> 未设置时，默认使用原\n        //\n        // 始图片 <span class=\"hljs-attr\">8</span> * <span class=\"hljs-attr\">8</span> 的模糊缩略图。\n        // <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;blur&quot;</span> // 默认使用模糊缩略图，或者设置为 <span class=\"hljs-attr\">empty</span> 空白\n      /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Welcome to my homepage!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n\n                <h3 id=\"%E4%BD%BF%E7%94%A8%E8%BF%9C%E7%A8%8B%E5%9B%BE%E7%89%87\">\n                  使用远程图片\n                </h3><p>使用远程图片和本地图片类似，只是 <code>src</code> 属性设置为远程图片的相对或绝对字符串 URL 地址。 因为在编译时 Joy 不能访问远程图片，所以不能得到图片的高宽，我们需要明确的手动指定图片的 <code>width</code> 和 <code>height</code> 属性。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> logoImg <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./logo.png&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>HomePage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span>\n        <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/logo.png&quot;</span> // 图片的 <span class=\"hljs-attr\">URL</span> 相对路径。\n        <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;logo&quot;</span>\n        <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{100}</span>\n        <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{100}</span>\n      /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Welcome to my homepage!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>`\n    <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n  );\n}\n</code></pre>\n<p>如果是外部域名，例如：<code>https://example1.com/logo.png</code> ，我们应该添加<code>domians</code>配置来设置安全域白名单，保护我们的应用程序不被恶意的用户破坏，不在这些域名内的图片，将拒绝提供图片优化服务。\n在 <code>joy.config.js</code>中设置 <code>domains</code>来指定安全域，例如：</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">images</span>: {\n    <span class=\"hljs-attr\">domains</span>: [<span class=\"hljs-string\">&quot;example1.com&quot;</span>, <span class=\"hljs-string\">&quot;example2.com&quot;</span>],\n  },\n};\n</code></pre>\n\n                <h3 id=\"%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8\">\n                  图片尺寸\n                </h3><p>图片影响用户体验的最常见的场景是改不布局，如图片在加载过程中推动其它元素。这对用户来说是非常糟糕的体验，以至于产生了一个核心指标 <a href=\"https://web.dev/cls/\">累积布局偏移 CLS</a> 来量化用户经历意外布局偏移的频率。\n避免因图片加载导致布局偏移的方法是始终设置图片的大小，这让浏览器在加载之前为图片预留足够的空间。</p>\n<p><code>Image</code> 组件是为了保证良好的性能结果而设计的，所以它会采用以下 3 中方式来确定图片大小，防止布局变化：</p>\n<ol>\n<li>自动识别大小， 当采用静态导入的时候。</li>\n<li>明确指定大小， 使用 <code>width</code> 和 <code>height</code> 属性明确设置图片大小。</li>\n<li>隐式声明， 设置属性 <code>layout=&quot;fill&quot;</code>，使图片缩放适配其父元素大小。</li>\n</ol>\n<p>另外图片文件大小也是影响页面加载性能的重要因素之一，加载图片时，<code>Image</code> 组价计算出图片展示尺寸后，会从 <code>[16, 32, 48, 64, 96, 128, 256, 384, ...]</code>等尺寸规格中选取比当前展示尺寸大一号的图片版本，例如图片展示宽度为 <code>80px</code>，会加载<code>96px</code>规格的图片副本。\n并且副本图片会优先采用<code>webp</code>或者<code>avif</code>等压缩率和压缩质量较高的图片格式，进一步减小图片的文件大小。</p>\n\n                <h3 id=\"%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7\">\n                  加载优先级\n                </h3><p>我们应该为任何的 <a href=\"https://web.dev/lcp\">最大内容绘制 LCP</a> 的图片元素设置 <code>priority</code> 属性，从而让 Joy 优先加载图片（通过预加载标签和优先级属性实现 ），减少最大内容绘制耗时。</p>\n<p>通常最大内容绘制元素是页面可视区域内的大尺寸图片或者文本块，当使用 <code>joy dev</code> 开发模式运行应用时，如果一个最大内容绘制元素的<code>Image</code> 组件未设置 <code>priority</code>属性，将会在 console 里收到一条提示信息。</p>\n\n                <h3 id=\"%E5%86%85%E7%BD%AE%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1\">\n                  内置图片优化服务\n                </h3><p>Joy 内置图片优化服务，该服务可以优化 web 上的任何图像，然后从 Joy 的内置 web 服务器对外提供这些优化后图像。</p>\n<p>从以下几个优化面：</p>\n<ul>\n<li>根据界面布局大小，使用缩小版的图片。</li>\n<li>转换为压缩质量更高的图片格式，例如 <code>webp</code>。</li>\n<li>提供低质量的图片，提升加载速度。</li>\n<li>设置图片资源缓存，有效利用浏览器缓存。</li>\n</ul>\n<p>该服务对外提供 API GET 接口： <code>/_joy/image</code>， 接口参数：</p>\n<ul>\n<li><code>url</code>: <code>string</code> 必须，图片的下载地址，可以是本地相对或绝对路径，或者远程绝对路径。</li>\n<li><code>w</code>: <code>number</code> 必须，图片的宽度，等比缩放图片使宽度等于该值。</li>\n<li><code>q</code>: <code>number</code> 非必须，图片的压缩质量百分比，取 0 到 100 的整数，默认 75。</li>\n<li><code>mimeType</code>：隐藏参数，无需设置，通过请求 header 的<code>accept</code>自动获取，例如浏览器支持 <code>accept: image/webp</code>,将优先返回 <code>webp</code>格式，否则返回原图片格式。</li>\n</ul>\n<p>例如我们希望获取宽度 32px，压缩质量 75%、格式为<code>webp</code>的图片，完整的请求 URL 路径为：<code>http://localhost:3000/_joy/image/?url=%2Fexample.png&amp;w=32&amp;q=75</code></p>\n<blockquote>\n<p>该服务内部默认使用 <a href=\"https://www.npmjs.com/package/@squoosh/lib\"><code>squoosh</code></a> 库来加工图片，因为它安装起来很快，而且适合于开发环境。\n在生成环境中，建议替换为<a href=\"https://www.npmjs.com/package/sharp\"><code>sharp</code></a>工具，在项目目录中运行 <code>yarn add sharp</code> 来安装 <a href=\"https://www.npmjs.com/package/sharp\"><code>sharp</code></a>，安装成功后重启应用，会自动切换为 <a href=\"https://www.npmjs.com/package/sharp\"><code>sharp</code></a>。\n<code>sharp</code> 比 <code>squoosh</code> 能更快更高效的处理图片，由于 <code>sharp</code> 在安装时会下载其底层依赖<code>libvips</code>包，受网络环境的影响较大，安装很缓慢且容易失败，所以在开发环境使用安装更轻便的<code>squoosh</code>。</p>\n</blockquote>\n\n                <h3 id=\"%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8\">\n                  图片加载器\n                </h3><p>通过设置图片的 <code>loader</code> 属性指定加载器，图片加载器是一个方法，用于生成图片 URL 地址或者多尺寸的图片地址集合，地址集合将用于生成 <code>&lt;img /&gt;</code>标签的<code>srcset</code>属性，从而为用户提供满足他们展示设备的大小图片。</p>\n<p>Joy 应用的默认加载器 <code> default</code> 使用内置的图片优化服务 API。\n如果我们想直接从 CDN 或其它图像服务器上获取图片，可以用几行 JavaScript 实现一个新的加载器，使用一个 Joy 内置的加载器。</p>\n<p>下面示例展示如何使用 Imgix 服务商提供的图片服务，首先配置图片模块，设置全局的默认加载器为内置的 <code>imgix</code>，也可以不用全局配置，在<code>Image</code>组件内设置每个组件自己的加载器。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// joy.confing.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">images</span>: {\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;imgix&quot;</span>,\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;https://static.imgix.net&quot;</span>,\n  },\n};\n</code></pre>\n<p>在<code>Image</code>组件内定义图片路径和大小等信息：</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Image</span> src=<span class=\"hljs-string\">&quot;/daisy.png&quot;</span> width={<span class=\"hljs-number\">300</span>} qulity={<span class=\"hljs-number\">75</span>} /&gt;\n</code></pre>\n<p>上面的例子中，最终图片加载地址类似于：<code>https://static.imgix.net/daisy.png?auto=format&amp;fit=max&amp;w=300&amp;q=75</code></p>\n\n                <h3 id=\"%E5%9B%BE%E7%89%87%E6%A0%B7%E5%BC%8F\">\n                  图片样式\n                </h3><p><code>Image</code> 组件和标准的 <code>&lt;img &gt;</code>标签在样式设置上没有太大不同，下面是一些需要注意的指导建议：</p>\n<ul>\n<li>使用 <code>className</code> 来查询图片和定义样式，不应该依赖 DOM 结构， <code>Image</code> 组件是一个复合组件，里面使用 <code>&lt;span&gt;</code>标签包裹<code>&lt;img&gt;</code>标签，在某些情况下，我们并不能使用 DOM 结构精确的定位到图片。</li>\n<li>使用正确的布局模式，<code>Image</code> 组件提供了几种不同的布局模式来定义它在页面上的大小。</li>\n<li>当 <code>layout=&quot;fill&quot;</code> 时，其父元素的样式必须包含 <code>position: relative</code>。</li>\n<li>的 <code>layout=&quot;responsive&quot;</code> 时，其父元素样式必须包含 <code>display: block</code>。</li>\n</ul>\n\n                <h3 id=\"image-%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7\">\n                  Image 组件属性\n                </h3>\n                <h4 id=\"src\">\n                  src\n                </h4><p>属性名称：<code>src</code>，类型：<code>string|StaticImport</code>，默认值：<code>-</code>，必须：<code>true</code></p>\n<p>必须是下列之一：</p>\n<ul>\n<li>静态导入<code>import</code>的图片对象。</li>\n<li>字符串，可以是一个绝对的外部 URL，也可以是一个内部路径，这取决于配置的<code>loader</code>。</li>\n</ul>\n<p>使用外部 URL，我们应该设置安全域（在应用配置里添加<code>images.domains</code>配置）.</p>\n\n                <h4 id=\"width\">\n                  width\n                </h4><p>属性名称：<code>width</code>，类型：<code>number</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>图片的宽度，输入整数的像素值。\n必须设置该属性，除非是静态导入的图片或者<code>layout=&quot;fill&quot;</code>时。</p>\n\n                <h4 id=\"height\">\n                  height\n                </h4><p>属性名称：<code>height</code>，类型：<code>number</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>图片的宽度，输入整数的像素值。\n必须设置该属性，除非是静态导入的图片或者<code>layout=&quot;fill&quot;</code>的时。</p>\n\n                <h4 id=\"loader\">\n                  loader\n                </h4><p>属性名称：<code>loader</code>，类型：<code>(resolverProps:ImageLoaderProps) =&gt; string</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p><code>loader</code> 是一个自定义方法，使用图片的属性来生成完整 URL 地址，接受以下参数：</p>\n<ul>\n<li><code>src</code>: <code>string</code> 图片的相对或绝对路径。</li>\n<li><code>width</code>: <code>number</code> 期望加载图片的宽度。</li>\n<li><code>quality</code>: <code>number</code> 期望加载图片的压缩质量。</li>\n<li><code>config</code>: <code>ImageConfig</code> 图片模块的配置。</li>\n</ul>\n<p>下面是一个自定义的加载器示例：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">myLoader</span> = (<span class=\"hljs-params\">{ src, width, quality }</span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`https://example.com/<span class=\"hljs-subst\">${src}</span>?w=<span class=\"hljs-subst\">${width}</span>&amp;q=<span class=\"hljs-subst\">${quality || <span class=\"hljs-number\">75</span>}</span>`</span>;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">MyImage</span> = (<span class=\"hljs-params\">props</span>) =&gt; {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">loader</span>=<span class=\"hljs-string\">{myLoader}</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;me.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;Picture of the author&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">{500}</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">{500}</span> /&gt;</span></span>;\n};\n</code></pre>\n<p>Joy 内建了一些云服务提供商的图片加载器，我们可以在应用配置点 <code>images.loader</code> 上, 设置默认图片加载器。</p>\n\n                <h4 id=\"layout\">\n                  layout\n                </h4><p>属性名称：<code>layout</code>，类型： <code>&quot;intrinsic&quot;|&quot;fixed&quot;|&quot;responsive&quot;|&quot;fill&quot;</code>，默认值：<code>&quot;intrinsic&quot;</code>，必须：<code>false</code></p>\n<p>通过 <code>layout</code>属性设置布局模式，用于定义图片布局将随窗口变化时如何变化，Joy 内置了以下 4 种布局模式：</p>\n<ul>\n<li><p><code>intrinsic</code>\n默认布局，当父容器的宽度小于图片组件的宽度时，缩小图片尺寸以适应父容器的宽度，当父容器的宽度大于图片组件的宽度时，会展示图片组件的固定宽度。\n受影响的属性：</p>\n<ul>\n<li><code>srcSet</code>： 基于当前图片组件的尺寸，从 <code>imageSizes</code> 中选取和组件尺寸相同或大一号的尺寸，生成 <code>srcSet</code> 中 <code>1x</code>，<code>2x</code>的图片。</li>\n<li><code>sizes</code>: 该属性值无效。</li>\n</ul>\n</li>\n<li><p><code>fixed</code> 图片组件的尺寸不会随着父容器的大小改变而改变，这个标准的<code>img</code>标签的表现一样。\n受影响的属性：</p>\n<ul>\n<li><code>srcSet</code>： 基于当前图片组件的尺寸，从 <code>imageSizes</code> 中选取和组件尺寸相同或大一号的尺寸，生成 <code>srcSet</code> 中 <code>1x</code>，<code>2x</code>的图片。</li>\n<li><code>sizes</code>: 该属性值无效。</li>\n</ul>\n</li>\n<li><p><code>responsive</code> 图片组件将缩放适应父元素的宽度，父元素需要样式需包含 <code>display: block</code>。\n在不同的窗口尺寸下，组件将加载对应尺寸的图片。例如：在<code>1080px</code>宽度的窗口上加载 <code>1080px</code> 版本的图片，在<code>1920px</code>宽度的窗口上加载 <code>1920px</code>版本的图片。\n受影响的属性：</p>\n<ul>\n<li><code>srcSet</code>： 将 <code>imageSizes</code> 和 <code>deviceSizes</code> 定义的所有尺寸生成 <code>srcSet</code> 列表，以便可以响应式的加载对应尺寸的图片。</li>\n<li><code>sizes</code>: 默认为 <code>100vw</code>。</li>\n</ul>\n</li>\n<li><p><code>fill</code> 图片组件宽度和高度将拉伸到父元素的尺寸，父元素需要是相对布局的，样式需包含 <code>position: relative </code>。\n配合 <code>objectFit</code> 属性定义拉伸缩放模式，例如：<code>fill</code> 拉伸填充， <code>contain</code> 包含等。\n受影响的属性：</p>\n<ul>\n<li><code>srcSet</code>： 将 <code>imageSizes</code> 和 <code>deviceSizes</code> 定义的所有尺寸生成 <code>srcSet</code> 列表，以便可以响应式的加载对应尺寸的图片。</li>\n<li><code>sizes</code>: 默认为 <code>100vw</code>。</li>\n</ul>\n</li>\n</ul>\n\n                <h4 id=\"sizes\">\n                  sizes\n                </h4><p>属性名称：<code>sizes</code>，类型： <code>string</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>指定不同页面布局的图像大小了， 例如：<code>sizes=&quot;(max-width: 360px) 340px, 128px&quot;</code>，表示当视区宽度不大于 360 像素时候，图片的宽度限制为 340 像素，其他情况下，使用 128 像素。</p>\n<p>当 <code>layout=&quot;responsive&quot;</code> 或者 <code>layout=&quot;fill&quot;</code> 时，默认值时 <code>100vw</code> 即占满整个窗口，我们可以设置更小的值，使图片小于窗口的宽度。</p>\n<p>当 <code>layout=&quot;intrinsic&quot;</code> 或者 <code>layout=&quot;fixed&quot;</code> 时，<code>sizes</code>属性是无效的，因为它依赖的是父容器边界大小。</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes\">了解更多</a></p>\n\n                <h4 id=\"objectfit\">\n                  objectFit\n                </h4><p>属性名称：<code>objectFit</code>，类型： <code>string</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>当 <code>layout=&quot;fill&quot;</code>时，定义图片如何填充父元素， 如：</p>\n<ul>\n<li><code>fill</code> 图片拉伸填充整个父容器。</li>\n<li><code>container</code>图片等比放大后填满父容器的整个宽度或高度。</li>\n<li><code>cover</code> 图片等比放大覆盖整个父容器。</li>\n<li><code>none</code> 图片缩放，在父容器中心按原尺寸展示图片。</li>\n</ul>\n<p>该属性将直接传递给 <code>img</code> 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit\"><code>object-fit</code></a> 属性。</p>\n\n                <h4 id=\"objectposition\">\n                  objectPosition\n                </h4><p>属性名称：<code>objectPosition</code>，类型： <code>string</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>当 <code>layout=&quot;fill&quot;</code>时，定义图片在父元素的布局位置，例如： <code>&quot;right top&quot;</code></p>\n<p>该属性将直接传递给 <code>img</code> 的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/object-position\"><code>object-position</code></a> 属性。</p>\n\n                <h4 id=\"quality\">\n                  quality\n                </h4><p>属性名称：<code>quality</code>，类型： <code>number</code>，默认值：<code>75</code>，必须：<code>false</code></p>\n<p><code>quality</code>属性设置加载什么质量的图片，质量是相对于原图片的压缩质量，取 <code>1</code> 到 <code>100</code> 的整数，默认值 <code>75</code>。\n数值越高质量越好，同时图片的文件大小也会越大。</p>\n\n                <h4 id=\"priority\">\n                  priority\n                </h4><p>属性名称：<code>priority</code>，类型： <code>bool</code>，默认值：<code>false</code>，必须：<code>false</code></p>\n<p>如果为 <code>true</code> 图片将尽量优先加载，图片延迟加载将自动关闭。</p>\n<p>我们应该为任何的 <a href=\"https://web.dev/lcp\">最大内容绘制 LCP</a> 的图片元素设置 <code>priority</code> 属性。</p>\n\n                <h4 id=\"loading\">\n                  loading\n                </h4><p>属性名称：<code>loading</code>，类型： <code>string</code>，默认值：<code>lazy</code>，必须：<code>false</code></p>\n<p>设置图片的加载时机。</p>\n<ul>\n<li><code>lazy</code> 延迟加载图片，当图片滚动到可视区域时才开始加载图片。</li>\n<li><code>eager</code> 立即加载图片。</li>\n</ul>\n<blockquote>\n<p>请尽量保持默认的 <code>lazy</code> 模式，立即加载 <code>eager</code> 模式，在大多数情况下会影响网页的加载性能。如需尽快加载图片，推荐使用 <code>priority</code> 属性。</p>\n</blockquote>\n\n                <h4 id=\"lazyboundary\">\n                  lazyBoundary\n                </h4><p>属性名称：<code>lazyBoundary</code>，类型： <code>string</code>，默认值：<code>&quot;200px&quot;</code>，必须：<code>false</code></p>\n<p>当图片延迟加载时，检查图片到可视区域的距离阈值，当小于这个阈值时，即视为图片即将展示，需立即开始加载图片，触发加载过程。</p>\n<p>如果图片时嵌入在一个内部可滚动的父容器中，需要通过<code>lazyRoot</code>属性指定父容器，使用父容器的滚动位置来计算可视区域，而不是直接使用 document 的滚动位置。</p>\n\n                <h4 id=\"lazyroot\">\n                  lazyRoot\n                </h4><p>属性名称：<code>lazyRoot</code>，类型： <code>ref</code>，默认值：<code>null</code>，必须：<code>false</code></p>\n<p>设置一个 <a href=\"https://reactjs.org/docs/refs-and-the-dom.html\">React Ref</a> ，指向滚动的父容器。默认值 <code>null</code>，表示 document。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> lazyRoot = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Example</span> = (<span class=\"hljs-params\"></span>) =&gt; (\n  <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{lazyRoot}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">overflowX:</span> &quot;<span class=\"hljs-attr\">scroll</span>&quot;, <span class=\"hljs-attr\">width:</span> &quot;<span class=\"hljs-attr\">500px</span>&quot; }}&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">lazyRoot</span>=<span class=\"hljs-string\">{lazyRoot}</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/one.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">lazyRoot</span>=<span class=\"hljs-string\">{lazyRoot}</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/two.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n);\n</code></pre>\n<p>Ref 必须指向一个 DOM 元素，而不是 React Component 复合组件。如果父元素是 React Component 中，可以使用 <a href=\"https://reactjs.org/docs/forwarding-refs.html\">forwarding-refs</a> 方法，将引用指向其内部 DOM 元素。例如：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Container</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">forwardRef</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">props, ref</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{ref}</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">overflowX:</span> &quot;<span class=\"hljs-attr\">scroll</span>&quot;, <span class=\"hljs-attr\">width:</span> &quot;<span class=\"hljs-attr\">500px</span>&quot; }}&gt;</span>\n      {props.children}\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n});\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Example</span> = (<span class=\"hljs-params\"></span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> lazyRoot = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Container</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">{lazyRoot}</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">lazyRoot</span>=<span class=\"hljs-string\">{lazyRoot}</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/one.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Image</span> <span class=\"hljs-attr\">lazyRoot</span>=<span class=\"hljs-string\">{lazyRoot}</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/two.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;500&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;500&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Container</span>&gt;</span></span>\n  );\n};\n</code></pre>\n\n                <h4 id=\"placeholder\">\n                  placeholder\n                </h4><p>属性名称：<code>placeholder</code>，类型： <code>&quot;blur&quot;|&quot;empty&quot;</code>，默认值：<code>&quot;empty&quot;</code>，必须：<code>false</code></p>\n<p><code>placeholder</code>属性设置图片加载中的占位图，提供 <code>blur</code>和<code>emtpy</code>两个选项，默认值：<code>emtpy</code>。</p>\n<p>当 <code>placeholder=&quot;blur&quot;</code> 时，使用<code>blurDataURL</code>图片来显示占位图。 如果 <code>src</code> 设置的是静态<code>import</code>的图片对象，如：导入的<code>.jpg</code>、<code>.png</code>、<code>.webp</code>等，<code>blurDataURL</code>属性将自动从导入对象中取值。\n如是是动态加载的远程图片，需要手动提供 <code>blurDataURL</code> 属性。</p>\n<p>当 <code>placeholder=&quot;blemtpyur&quot;</code>时，图片在加载过程中，将保留空白的区域，无任何的展位图。</p>\n\n                <h4 id=\"blurdataurl\">\n                  blurDataURL\n                </h4><p>属性名称：<code>placeholder</code>，类型： <code>string</code>，默认值：<code>undefined</code>，必须：<code>false</code></p>\n<p>当 <code>placeholder=&quot;blur&quot;</code>时，使用 <code>blurDataURL</code> 的内容来展示占位图，值必须是 Base64 编码的 DataUrl 字符串。\n占位图会被放大和模糊，所以建议使用非常小的图像(10px 或更小)，Joy 静态导入的图片，默认是 8px 的缩略图。</p>\n\n                <h4 id=\"unoptimized\">\n                  unoptimized\n                </h4><p>属性名称：<code>unoptimized</code>，类型： <code>bool</code>，默认值：<code>false</code>，必须：<code>false</code></p>\n<p>为 <code>true</code> 时，关闭图片优化，将使用图片的源文件，不会使用经过大小、质量和格式优化后的图片。</p>\n\n                <h4 id=\"onloadingcomplete\">\n                  onLoadingComplete\n                </h4><p>属性名称：<code>onLoadingComplete</code>，类型： <code>function</code>，默认值：<code>undefiend</code>，必须：<code>false</code></p>\n<p>图片加载完成后的回调函数，接受 1 个对象参数，对象参数有以下属性：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalWidth\"><code>naturalWidth</code> </a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/naturalHeight\"><code>naturalHeight</code></a></li>\n</ul>\n\n                <h4 id=\"others\">\n                  others\n                </h4><p>赋值给<code>&lt;Image &gt;</code>组件的其它属性，将直接传递给内部的 <code>img</code> 标签。有以下几点需注意：</p>\n<ul>\n<li><code>style</code>属性，请使用 <code>className</code> 方式替换，不能直接给图片组件内联样式。</li>\n<li><code>srcSet</code>属性，请配置<code>images.deviceSize</code>项，设置可支持的设备窗口大小列表，组件会自动计算出合适的<code>srcSet</code>集合。</li>\n<li><code>ref</code>属性，请使用<code>onLoadingComplete</code>替换，如需获取图片的信息，可在该回调函数中获取。</li>\n<li><code>decoding</code> 属性需一直保持为 <code>&quot;async&quot;</code>。</li>\n</ul>\n\n                <h3 id=\"%E5%9B%BE%E7%89%87%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE\">\n                  图片模块配置\n                </h3><p><code>Image</code> 组件和图片优化服务可以在应用配置的<code>images</code>节点中自定义配置。\n下面是应用的默认配置示例：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">deviceSizes</span>: [<span class=\"hljs-number\">640</span>, <span class=\"hljs-number\">750</span>, <span class=\"hljs-number\">828</span>, <span class=\"hljs-number\">1080</span>, <span class=\"hljs-number\">1200</span>, <span class=\"hljs-number\">1920</span>, <span class=\"hljs-number\">2048</span>, <span class=\"hljs-number\">3840</span>],\n  <span class=\"hljs-attr\">imageSizes</span>: [<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">48</span>, <span class=\"hljs-number\">64</span>, <span class=\"hljs-number\">96</span>, <span class=\"hljs-number\">128</span>, <span class=\"hljs-number\">256</span>, <span class=\"hljs-number\">384</span>],\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/_joy/image&quot;</span>,\n  <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;default&quot;</span>,\n  <span class=\"hljs-attr\">domains</span>: [],\n  <span class=\"hljs-attr\">disableStaticImages</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">minimumCacheTTL</span>: <span class=\"hljs-number\">60</span>,\n  <span class=\"hljs-attr\">formats</span>: [<span class=\"hljs-string\">&quot;image/webp&quot;</span>],\n  <span class=\"hljs-attr\">dangerouslyAllowSVG</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">contentSecurityPolicy</span>: <span class=\"hljs-string\">`script-src &#x27;none&#x27;; frame-src &#x27;none&#x27;; sandbox;`</span>,\n  <span class=\"hljs-attr\">unoptimized</span>: <span class=\"hljs-literal\">false</span>,\n};\n</code></pre>\n\n                <h4 id=\"domains\">\n                  domains\n                </h4><p>配置名称：<code>domains</code>，类型： <code>stirng[]</code>，默认值：<code>[]</code>，必须：<code>false</code></p>\n<p>当使用其它域名的远程图片时，为了保护我们的应用程序不被恶意的用户破坏，<code>domains</code>配置远程图片所在域名的白名单，不在这些域名内的图片，<code>Image</code> 组件和图片优化将拒绝服务。</p>\n\n                <h4 id=\"loader\">\n                  loader\n                </h4><p>配置名称：<code>loader</code>，类型： <code>string</code>，默认值：<code>&quot;default&quot;</code>，必须：<code>false</code></p>\n<p>如果我们想不使用 Joy 内建的图片服务， 而想使用其它云服务商提供的图片存储和优化服务，可以配置 <code>loader</code> 参数来切换图片加载方式。\n一般结合 <code>path</code> 参数使用， <code>path</code>参数设置图片的 URL 地址前缀，而后在<code>Image</code>的 src 属性上，只需设置图片的相对路径。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">images</span>: {\n    <span class=\"hljs-attr\">loader</span>: <span class=\"hljs-string\">&quot;imgix&quot;</span>,\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;https://static.imgix.net&quot;</span>,\n  },\n};\n</code></pre>\n<p>Joy 提供了以下内置加载器：</p>\n<ul>\n<li><code>default</code> : 使用内置图片优化服务的加载器。</li>\n<li><code>imgix</code>: 使用 <a href=\"https://imgix.com/\">Imgix</a> 服务商提供的图片服务。</li>\n<li><code>cloudinary</code>: 使用 <a href=\"https://cloudinary.com/\">Cloudinary</a> 服务商提供的图片服务。</li>\n<li><code>akamai</code>: 使用 <a href=\"https://www.akamai.com/\">Akamai</a> 服务商提供的图片服务。</li>\n<li><code>custom</code>: 使用自定义的云服务，设置该选项后，每个<code>Image</code> 组件必须设置自定义的<code>loader</code>属性。</li>\n</ul>\n\n                <h4 id=\"path\">\n                  path\n                </h4><p>配置名称：<code>path</code>，类型： <code>string</code>，默认值：<code>&quot;/_joy/image&quot;</code>，必须：<code>false</code></p>\n<p>在默认 <code>loader=&quot;default&quot;</code> 时， path 的默认值是 <code>&quot;/_joy/image&quot;</code>， 即使用 Joy 内置的图片优化服务。</p>\n<p>如果使用其它图片服务，可以设置<code>path</code>配置图片的统一 URL 地址前缀，而后在<code>Image</code>的 src 属性上只需设置图片的相对路径，运行时将两者合并生成完整的图片地址。</p>\n\n                <h4 id=\"devicesizes\">\n                  deviceSizes\n                </h4><p>配置名称：<code>deviceSizes</code>，类型： <code>number[]</code>，默认值：<code>[640, 750, 828, 1080, 1200, 1920, 2048, 3840]</code>，必须：<code>false</code></p>\n<p>当我们明确知道用户设备的宽度有哪些时，我们可以设置一个列表将这些宽度分段，在分段区间的内，加载对应尺寸的图片，从而让用户在各种尺寸的屏幕上，都可以获得较好的体验。\n这些设备宽度仅会在<code>Image</code> 组件 <code>layout=&quot;responsive&quot;</code> 或 <code>layout=&quot;fill&quot;</code> 时使用得到。</p>\n\n                <h4 id=\"imagesizes\">\n                  imageSizes\n                </h4><p>配置名称：<code>imageSizes</code>，类型： <code>number[]</code>，默认值：<code>[16, 32, 48, 64, 96, 128, 256, 384]</code>，必须：<code>false</code></p>\n<p>我们可以设置图片的宽度列表，这些宽度与<code>deviceSizes</code> 数组连接在一起，用于生成图像 srcsets 的完整大小数组。</p>\n<p>之所以有两个单独的宽度列表，是因为 <code>imageSizes</code> 只用于设置了<code>sizes</code>属性的图片，即图片的宽度小于全尺寸的屏幕宽度。因此，<code>imageSizes</code> 中的大小应该都小于<code>deviceSizes</code>中的最小大小。</p>\n\n                <h4 id=\"formats\">\n                  formats\n                </h4><p>配置名称：<code>formats</code>，类型： <code>string[]</code>，默认值：<code>[&quot;image/webp&quot;]</code>，必须：<code>false</code></p>\n<p>如果请求的<code>Accept</code>头能匹配配置列表中的多个格式，则使用数组中的第一个匹配项作为返回格式。因此，数组的顺序很重要。如果没有匹配的格式，将返回原始图像的格式。</p>\n<p>例如我们想优先使用<code>image/avif</code>，如果浏览器不支持 avif，则再检查是否支持 &#39;image/webp&#39; 格式，如果还不支持，则返回图片原格式，可以这样编写配置：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">images</span>: {\n    <span class=\"hljs-attr\">formats</span>: [<span class=\"hljs-string\">&quot;image/avif&quot;</span>, <span class=\"hljs-string\">&quot;image/webp&quot;</span>],\n  },\n};\n</code></pre>\n<blockquote>\n<p>AVIF 编码通常要多花 20%的时间，但它比 WebP 多压缩了 20%的空间。这意味着第一次请求图片时，它通常会缓慢点，而缓存后，后续请求会变快。</p>\n</blockquote>\n\n                <h4 id=\"minimumcachettl\">\n                  minimumCacheTTL\n                </h4><p>配置名称：<code>minimumCacheTTL</code>，类型： <code>number</code>，默认值：<code>60</code>，必须：<code>false</code></p>\n<p>设置图片的在优化服务内的最小缓存时长，单位秒。\n大多数情况下，建议使用使用 <a href=\"#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5\">静态导入</a> 的方式加载图片，这将自动为图片生成一个唯一的 hash 值，并设置<code>Cache-Control</code>为<code>immutable</code>，使图片长期有效。</p>\n\n                <h4 id=\"disablestaticimages\">\n                  disableStaticImages\n                </h4><p>配置名称：<code>disableStaticImages</code>，类型： <code>bool</code>，默认值：<code>false</code>，必须：<code>false</code></p>\n<p>默认情况下，我们可以直接静态导入图片，如 <code>import logo from &quot;./logo.png&quot;</code>，然后设置给图片组件的 <code>src</code>属性。</p>\n<p>但有时候，如果静态导入和其它插件冲突，或者想自定义 webpack 插件以实现不同的导入方式，我们可以设置为<code>false</code>关闭默认的图片导入插件。</p>\n\n                <h4 id=\"dangerouslyallowsvg\">\n                  dangerouslyAllowSVG\n                </h4><p>配置名称：<code>dangerouslyAllowSVG</code>，类型： <code>bool</code>，默认值：<code>false</code>，必须：<code>false</code></p>\n<p>默认 Joy 的内置图片优化服务不会对 SVG 格式的图片进行优化。\n首先，SVG 是一种矢量格式，这意味着它可以无损地调整大小。其次，SVG 有许多与 HTML/CSS 相同的特性，如果没有适当的内容安全策略(CSP)头，这些特性可能会导致漏洞。</p>\n<p>如果想内置的图片优化服务提供 SVG 图片格式，可以启用该功能，并设置适当的内容安全策略。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">images</span>: {\n    <span class=\"hljs-attr\">dangerouslyAllowSVG</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">contentSecurityPolicy</span>: <span class=\"hljs-string\">&quot;default-src &#x27;self&#x27;; script-src &#x27;none&#x27;; sandbox;&quot;</span>,\n  },\n};\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 静态导入\n\n","depth":2,"text":"静态导入","tokens":[{"type":"text","raw":"静态导入","text":"静态导入"}],"id":"#%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5"},{"type":"heading","raw":"## CSS 中使用图片\n\n","depth":2,"text":"CSS 中使用图片","tokens":[{"type":"text","raw":"CSS 中使用图片","text":"CSS 中使用图片"}],"id":"#css-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87"},{"type":"heading","raw":"## 引用静态文件图片\n\n","depth":2,"text":"引用静态文件图片","tokens":[{"type":"text","raw":"引用静态文件图片","text":"引用静态文件图片"}],"id":"#%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E5%9B%BE%E7%89%87"},{"type":"heading","raw":"## Image 组件和图片优化\n\n","depth":2,"text":"Image 组件和图片优化","tokens":[{"type":"text","raw":"Image 组件和图片优化","text":"Image 组件和图片优化"}],"id":"#image-%E7%BB%84%E4%BB%B6%E5%92%8C%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96","children":[{"type":"heading","raw":"### 使用本地图片\n\n","depth":3,"text":"使用本地图片","tokens":[{"type":"text","raw":"使用本地图片","text":"使用本地图片"}],"id":"#%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87"},{"type":"heading","raw":"### 使用远程图片\n\n","depth":3,"text":"使用远程图片","tokens":[{"type":"text","raw":"使用远程图片","text":"使用远程图片"}],"id":"#%E4%BD%BF%E7%94%A8%E8%BF%9C%E7%A8%8B%E5%9B%BE%E7%89%87"},{"type":"heading","raw":"### 图片尺寸\n\n","depth":3,"text":"图片尺寸","tokens":[{"type":"text","raw":"图片尺寸","text":"图片尺寸"}],"id":"#%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8"},{"type":"heading","raw":"### 加载优先级\n\n","depth":3,"text":"加载优先级","tokens":[{"type":"text","raw":"加载优先级","text":"加载优先级"}],"id":"#%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"},{"type":"heading","raw":"### 内置图片优化服务\n\n","depth":3,"text":"内置图片优化服务","tokens":[{"type":"text","raw":"内置图片优化服务","text":"内置图片优化服务"}],"id":"#%E5%86%85%E7%BD%AE%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1"},{"type":"heading","raw":"### 图片加载器\n\n","depth":3,"text":"图片加载器","tokens":[{"type":"text","raw":"图片加载器","text":"图片加载器"}],"id":"#%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8"},{"type":"heading","raw":"### 图片样式\n\n","depth":3,"text":"图片样式","tokens":[{"type":"text","raw":"图片样式","text":"图片样式"}],"id":"#%E5%9B%BE%E7%89%87%E6%A0%B7%E5%BC%8F"},{"type":"heading","raw":"### Image 组件属性\n\n","depth":3,"text":"Image 组件属性","tokens":[{"type":"text","raw":"Image 组件属性","text":"Image 组件属性"}],"id":"#image-%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7","children":[{"type":"heading","raw":"#### src\n\n","depth":4,"text":"src","tokens":[{"type":"text","raw":"src","text":"src"}],"id":"#src"},{"type":"heading","raw":"#### width\n\n","depth":4,"text":"width","tokens":[{"type":"text","raw":"width","text":"width"}],"id":"#width"},{"type":"heading","raw":"#### height\n\n","depth":4,"text":"height","tokens":[{"type":"text","raw":"height","text":"height"}],"id":"#height"},{"type":"heading","raw":"#### loader\n\n","depth":4,"text":"loader","tokens":[{"type":"text","raw":"loader","text":"loader"}],"id":"#loader"},{"type":"heading","raw":"#### layout\n\n","depth":4,"text":"layout","tokens":[{"type":"text","raw":"layout","text":"layout"}],"id":"#layout"},{"type":"heading","raw":"#### sizes\n\n","depth":4,"text":"sizes","tokens":[{"type":"text","raw":"sizes","text":"sizes"}],"id":"#sizes"},{"type":"heading","raw":"#### objectFit\n\n","depth":4,"text":"objectFit","tokens":[{"type":"text","raw":"objectFit","text":"objectFit"}],"id":"#objectfit"},{"type":"heading","raw":"#### objectPosition\n\n","depth":4,"text":"objectPosition","tokens":[{"type":"text","raw":"objectPosition","text":"objectPosition"}],"id":"#objectposition"},{"type":"heading","raw":"#### quality\n\n","depth":4,"text":"quality","tokens":[{"type":"text","raw":"quality","text":"quality"}],"id":"#quality"},{"type":"heading","raw":"#### priority\n\n","depth":4,"text":"priority","tokens":[{"type":"text","raw":"priority","text":"priority"}],"id":"#priority"},{"type":"heading","raw":"#### loading\n\n","depth":4,"text":"loading","tokens":[{"type":"text","raw":"loading","text":"loading"}],"id":"#loading"},{"type":"heading","raw":"#### lazyBoundary\n\n","depth":4,"text":"lazyBoundary","tokens":[{"type":"text","raw":"lazyBoundary","text":"lazyBoundary"}],"id":"#lazyboundary"},{"type":"heading","raw":"#### lazyRoot\n\n","depth":4,"text":"lazyRoot","tokens":[{"type":"text","raw":"lazyRoot","text":"lazyRoot"}],"id":"#lazyroot"},{"type":"heading","raw":"#### placeholder\n\n","depth":4,"text":"placeholder","tokens":[{"type":"text","raw":"placeholder","text":"placeholder"}],"id":"#placeholder"},{"type":"heading","raw":"#### blurDataURL\n\n","depth":4,"text":"blurDataURL","tokens":[{"type":"text","raw":"blurDataURL","text":"blurDataURL"}],"id":"#blurdataurl"},{"type":"heading","raw":"#### unoptimized\n\n","depth":4,"text":"unoptimized","tokens":[{"type":"text","raw":"unoptimized","text":"unoptimized"}],"id":"#unoptimized"},{"type":"heading","raw":"#### onLoadingComplete\n\n","depth":4,"text":"onLoadingComplete","tokens":[{"type":"text","raw":"onLoadingComplete","text":"onLoadingComplete"}],"id":"#onloadingcomplete"},{"type":"heading","raw":"#### others\n\n","depth":4,"text":"others","tokens":[{"type":"text","raw":"others","text":"others"}],"id":"#others"}]},{"type":"heading","raw":"### 图片模块配置\n\n","depth":3,"text":"图片模块配置","tokens":[{"type":"text","raw":"图片模块配置","text":"图片模块配置"}],"id":"#%E5%9B%BE%E7%89%87%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE","children":[{"type":"heading","raw":"#### domains\n\n","depth":4,"text":"domains","tokens":[{"type":"text","raw":"domains","text":"domains"}],"id":"#domains"},{"type":"heading","raw":"#### loader\n\n","depth":4,"text":"loader","tokens":[{"type":"text","raw":"loader","text":"loader"}],"id":"#loader"},{"type":"heading","raw":"#### path\n\n","depth":4,"text":"path","tokens":[{"type":"text","raw":"path","text":"path"}],"id":"#path"},{"type":"heading","raw":"#### deviceSizes\n\n","depth":4,"text":"deviceSizes","tokens":[{"type":"text","raw":"deviceSizes","text":"deviceSizes"}],"id":"#devicesizes"},{"type":"heading","raw":"#### imageSizes\n\n","depth":4,"text":"imageSizes","tokens":[{"type":"text","raw":"imageSizes","text":"imageSizes"}],"id":"#imagesizes"},{"type":"heading","raw":"#### formats\n\n","depth":4,"text":"formats","tokens":[{"type":"text","raw":"formats","text":"formats"}],"id":"#formats"},{"type":"heading","raw":"#### minimumCacheTTL\n\n","depth":4,"text":"minimumCacheTTL","tokens":[{"type":"text","raw":"minimumCacheTTL","text":"minimumCacheTTL"}],"id":"#minimumcachettl"},{"type":"heading","raw":"#### disableStaticImages\n\n","depth":4,"text":"disableStaticImages","tokens":[{"type":"text","raw":"disableStaticImages","text":"disableStaticImages"}],"id":"#disablestaticimages"},{"type":"heading","raw":"#### dangerouslyAllowSVG\n\n","depth":4,"text":"dangerouslyAllowSVG","tokens":[{"type":"text","raw":"dangerouslyAllowSVG","text":"dangerouslyAllowSVG"}],"id":"#dangerouslyallowsvg"}]}]}]},{"title":"Head 组件","path":"/joy/react/head","file":"docs\\joy\\02-react\\10-head.md","hasMenu":false,"mdContent":"# Head 组件\r\n\r\n内建`Head` React 组件用于向页面的 `head`标签内追加元素，当 React 渲染时遇到 `<Head>`组件，将内部声明的标签追加到`document.head`内。\r\n\r\n> `Head`标签可以在React组件树的任何位置，也可以多次出现，后渲染的内容，将会覆盖之前渲染的相同标签。\r\n> \r\n> 组件卸载时，将卸载组件注册的在`head`中的内容，所以需保证每个页面组件中包含了其所需的所有`head`内容，也请不要在一个页面推测其它页面的需要，声明其它页面的`head`。\r\n\r\n下面我们在页面中定义 `tile` 和 `meta` 信息：\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport { Head } from \"@symph/joy/react\";\r\nimport { ReactController, BaseReactController } from \"@symph/react\";\r\n\r\n@ReactController()\r\nexport class Index extends BaseReactController {\r\n  renderView() {\r\n    return (\r\n      <div>\r\n        <Head>\r\n          <title>My page title</title>\r\n          <meta name=\"viewport\" content=\"initial-scale=1.0, width=device-width\" />\r\n        </Head>\r\n        <p>Hello world!</p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n我们可以使用`key`属性来避免重复渲染标签，确保标签只被渲染一次，例如：\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport { Head } from \"@symph/joy/react\";\r\nimport { ReactController, BaseReactController } from \"@symph/react\";\r\n\r\n@ReactController()\r\nexport class Index extends BaseReactController {\r\n  renderView() {\r\n    return (\r\n      <div>\r\n        <Head>\r\n          <title>My page title</title>\r\n          <meta property=\"og:title\" content=\"My page title\" key=\"title\" />\r\n        </Head>\r\n        <Head>\r\n          <meta property=\"og:title\" content=\"My new title\" key=\"title\" />\r\n        </Head>\r\n        <p>Hello world!</p>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n在上例中，只有第二个 `<meta property=\"og:title\" />` 会被渲染。 带有不同 `key` 属性的 `meta` 标签将会被分别分开处理。\r\n\r\n`title`、`meta`或者其它类型的标签（如： `script`）需作为`Head`组件的直接子元素，或者被最多一级的`<React.Fragment>`所包围，否则将无法正常收集其中定义的标签。\r\n\r\n\r\n\r\n\r\n","htmlContent":"\n                <h1 id=\"head-%E7%BB%84%E4%BB%B6\">\n                  Head 组件\n                </h1><p>内建<code>Head</code> React 组件用于向页面的 <code>head</code>标签内追加元素，当 React 渲染时遇到 <code>&lt;Head&gt;</code>组件，将内部声明的标签追加到<code>document.head</code>内。</p>\n<blockquote>\n<p><code>Head</code>标签可以在React组件树的任何位置，也可以多次出现，后渲染的内容，将会覆盖之前渲染的相同标签。</p>\n<p>组件卸载时，将卸载组件注册的在<code>head</code>中的内容，所以需保证每个页面组件中包含了其所需的所有<code>head</code>内容，也请不要在一个页面推测其它页面的需要，声明其它页面的<code>head</code>。</p>\n</blockquote>\n<p>下面我们在页面中定义 <code>tile</code> 和 <code>meta</code> 信息：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Head</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Index</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>My page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;initial-scale=1.0, width=device-width&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>我们可以使用<code>key</code>属性来避免重复渲染标签，确保标签只被渲染一次，例如：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Head</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">BaseReactController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Index</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>My page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">property</span>=<span class=\"hljs-string\">&quot;og:title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;My page title&quot;</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;title&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">property</span>=<span class=\"hljs-string\">&quot;og:title&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;My new title&quot;</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;title&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>在上例中，只有第二个 <code>&lt;meta property=&quot;og:title&quot; /&gt;</code> 会被渲染。 带有不同 <code>key</code> 属性的 <code>meta</code> 标签将会被分别分开处理。</p>\n<p><code>title</code>、<code>meta</code>或者其它类型的标签（如： <code>script</code>）需作为<code>Head</code>组件的直接子元素，或者被最多一级的<code>&lt;React.Fragment&gt;</code>所包围，否则将无法正常收集其中定义的标签。</p>\n","anchor":[]},{"title":"自定义 App","path":"/joy/react/custom-app","file":"docs\\joy\\02-react\\20-custom-app.md","hasMenu":false,"mdContent":"# 自定义 App\r\n\r\nJoy 使用`App`来包装和初始化整个界面，我们可以自定它来控制页面的初始化，例如：\r\n\r\n- 添加所有页面共有的布局。\r\n- 捕获渲染错误，使用`componentDidCatch`。\r\n- 修改路由或者路由的渲染方式。\r\n- 添加全局样式。\r\n\r\n## _app.tsx 文件\r\n\r\n下面我们开始覆盖默认的`App`， 首选创建文件`./src/pages/_app.tsx`，修改其内容：\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport { IReactApplication, ReactRouterService, RouteSwitch } from \"@symph/react\";\r\nimport { ReactAppProps } from \"@symph/joy\";\r\n\r\nexport default class App extends React.Component<ReactAppProps, any> {\r\n  protected reactRouterService: ReactRouterService;\r\n  constructor(props: ReactAppProps, context?: any) {\r\n    super(props, context);\r\n    const appContext = props.appContext;\r\n    this.reactRouterService = appContext.getSync<ReactRouterService>(\"reactRouterService\");\r\n  }\r\n  render() {\r\n    const routes = this.reactRouterService.getRoutes() || [];\r\n    return <RouteSwitch routes={routes} extraProps={{}} />;\r\n  }\r\n}\r\n```\r\n\r\n`App` 的`props`中包含了`IReactApplication`实例，我们可以通过它获取到整个 React 应用的业务组件，例如上面例子中的`reactRouterService`路由组件。\r\n`render()`中使用的`RouteSwitch`组件来渲染应用中注册的路由，包括文件约定路由。\r\n\r\n## 注意事项：\r\n\r\n- 如果你的应用正在开发模式下运行中，首次添加`./src/pages/_app.js`文件，需要重新启动开发服务器。\r\n- `App`在服务端和浏览器上都会被渲染，所以需要注意渲染环境差异，例如在服务端渲染时，不能使用浏览器特有的API。\r\n","htmlContent":"\n                <h1 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-app\">\n                  自定义 App\n                </h1><p>Joy 使用<code>App</code>来包装和初始化整个界面，我们可以自定它来控制页面的初始化，例如：</p>\n<ul>\n<li>添加所有页面共有的布局。</li>\n<li>捕获渲染错误，使用<code>componentDidCatch</code>。</li>\n<li>修改路由或者路由的渲染方式。</li>\n<li>添加全局样式。</li>\n</ul>\n\n                <h2 id=\"_apptsx-%E6%96%87%E4%BB%B6\">\n                  _app.tsx 文件\n                </h2><p>下面我们开始覆盖默认的<code>App</code>， 首选创建文件<code>./src/pages/_app.tsx</code>，修改其内容：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">IReactApplication</span>, <span class=\"hljs-title class_\">ReactRouterService</span>, <span class=\"hljs-title class_\">RouteSwitch</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactAppProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span>&lt;<span class=\"hljs-title class_\">ReactAppProps</span>, <span class=\"hljs-built_in\">any</span>&gt; {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-attr\">reactRouterService</span>: <span class=\"hljs-title class_\">ReactRouterService</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props: ReactAppProps, context?: <span class=\"hljs-built_in\">any</span></span>) {\n    <span class=\"hljs-variable language_\">super</span>(props, context);\n    <span class=\"hljs-keyword\">const</span> appContext = props.<span class=\"hljs-property\">appContext</span>;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reactRouterService</span> = appContext.<span class=\"hljs-property\">getSync</span>&lt;<span class=\"hljs-title class_\">ReactRouterService</span>&gt;(<span class=\"hljs-string\">&quot;reactRouterService&quot;</span>);\n  }\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> routes = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reactRouterService</span>.<span class=\"hljs-title function_\">getRoutes</span>() || [];\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RouteSwitch</span> <span class=\"hljs-attr\">routes</span>=<span class=\"hljs-string\">{routes}</span> <span class=\"hljs-attr\">extraProps</span>=<span class=\"hljs-string\">{{}}</span> /&gt;</span></span>;\n  }\n}\n</code></pre>\n<p><code>App</code> 的<code>props</code>中包含了<code>IReactApplication</code>实例，我们可以通过它获取到整个 React 应用的业务组件，例如上面例子中的<code>reactRouterService</code>路由组件。\n<code>render()</code>中使用的<code>RouteSwitch</code>组件来渲染应用中注册的路由，包括文件约定路由。</p>\n\n                <h2 id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A\">\n                  注意事项：\n                </h2><ul>\n<li>如果你的应用正在开发模式下运行中，首次添加<code>./src/pages/_app.js</code>文件，需要重新启动开发服务器。</li>\n<li><code>App</code>在服务端和浏览器上都会被渲染，所以需要注意渲染环境差异，例如在服务端渲染时，不能使用浏览器特有的API。</li>\n</ul>\n","anchor":[{"type":"heading","raw":"## _app.tsx 文件\n\n","depth":2,"text":"_app.tsx 文件","tokens":[{"type":"text","raw":"_app.tsx 文件","text":"_app.tsx 文件"}],"id":"#_apptsx-%E6%96%87%E4%BB%B6"},{"type":"heading","raw":"## 注意事项：\n\n","depth":2,"text":"注意事项：","tokens":[{"type":"text","raw":"注意事项：","text":"注意事项："}],"id":"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"}]},{"title":"自定义 Document","path":"/joy/react/custom-document","file":"docs\\joy\\02-react\\21-custom-document.md","hasMenu":false,"mdContent":"# 自定义 Document\r\n\r\n`Document` React 组件用于生成页面的`<html>`和`<body>`标签， Joy 会根据应用内的组件和样式，自动生成必须的 js 和 css 标签，保证页面 html 能够正常被加载。\r\n我们可以通过自定义`Document`在`<html>`加入自定义的扩展`<head>`、`<link>`或者`<sciprt>`。\r\n\r\n## _document.tsx\r\n\r\n覆盖默认的`Document`，创建文件`./src/pages/_document.tsx`并修改`Document`如下：\r\n\r\n```tsx\r\nimport React from \"react\";\r\nimport Document, { Html, Head, Main, JoyScript, DocumentContext } from \"@symph/joy/document\";\r\n\r\nexport default class MyDocument extends Document<any> {\r\n  static async getInitialProps(ctx: DocumentContext) {\r\n    const initialProps = await Document.getInitialProps(ctx);\r\n    return { ...initialProps };\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <Html>\r\n        <Head></Head>\r\n        <body>\r\n          <Main />\r\n          <JoyScript />\r\n        </body>\r\n      </Html>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n> 上面示例中的`MyDocument`，等效于 Joy 默认的`Document`，未加入自定义的内容，如果不需要`getInitialProps`或者`render`方法，可以删除掉。\r\n\r\n`Html`、`Head`、`Main`和`JoyScript`是页面必须的，在自定义的`Document`类中，不要删除它们和更改顺序。\r\n但它们支持一些自定义的属性，例如：\r\n\r\n```tsx\r\n<Html lang=\"en\">\r\n```\r\n\r\n这里的`<Head />`不同于`@symph/joy/react`中的`Head`组件，这里的`<Head />`用于定义在所有页面中共有的`<head>`元素，而其它的，例如`<title>`标签，建议在页面组件中使用`@symph/joy/react`中的`Head`组件来定义。\r\n\r\n`getInitialProps`方法返回`Document`组件的初始 props，参数`ctx: DocumentContext`具有以下属性：\r\n\r\n- `pathname`：`string`，当前渲染的页面路径。\r\n- `query`： `object`， url 中的请求参数被解析后的对象。\r\n- `req`：[`IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage), 触发当前渲染的请求对象。\r\n- `res`：[`ServerResponse`](https://nodejs.org/api/http.html#http_class_http_serverresponse), 触发当前渲染的请求的响应对象。\r\n- `err` ：Error, 在渲染阶段出现的异常。\r\n- `renderPage`: `functin` 将`App`渲染为 html 字符串，返回值`{html, head}`在服务端渲染时。\r\n\r\n## 注意事项\r\n\r\n- `Document`只在服务端被渲染，事件处理并不会触发执行，例如`onClick`事件。同理 React 的部分生命周期也不会执行，例如`onComponentDidMount`。\r\n- 在`<Main/>`之外的 React 组件并不会被浏览器初始化，所以不要在这里添加任何业务逻辑。如果需要给整个应用添加统一的组件，可以在根布局组件中添加，或者`App`中添加。\r\n","htmlContent":"\n                <h1 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89-document\">\n                  自定义 Document\n                </h1><p><code>Document</code> React 组件用于生成页面的<code>&lt;html&gt;</code>和<code>&lt;body&gt;</code>标签， Joy 会根据应用内的组件和样式，自动生成必须的 js 和 css 标签，保证页面 html 能够正常被加载。\n我们可以通过自定义<code>Document</code>在<code>&lt;html&gt;</code>加入自定义的扩展<code>&lt;head&gt;</code>、<code>&lt;link&gt;</code>或者<code>&lt;sciprt&gt;</code>。</p>\n\n                <h2 id=\"_documenttsx\">\n                  _document.tsx\n                </h2><p>覆盖默认的<code>Document</code>，创建文件<code>./src/pages/_document.tsx</code>并修改<code>Document</code>如下：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Document</span>, { <span class=\"hljs-title class_\">Html</span>, <span class=\"hljs-title class_\">Head</span>, <span class=\"hljs-title class_\">Main</span>, <span class=\"hljs-title class_\">JoyScript</span>, <span class=\"hljs-title class_\">DocumentContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/document&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDocument</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Document</span>&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getInitialProps</span>(<span class=\"hljs-params\">ctx: DocumentContext</span>) {\n    <span class=\"hljs-keyword\">const</span> initialProps = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Document</span>.<span class=\"hljs-title function_\">getInitialProps</span>(ctx);\n    <span class=\"hljs-keyword\">return</span> { ...initialProps };\n  }\n\n  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Html</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Main</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">JoyScript</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Html</span>&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<blockquote>\n<p>上面示例中的<code>MyDocument</code>，等效于 Joy 默认的<code>Document</code>，未加入自定义的内容，如果不需要<code>getInitialProps</code>或者<code>render</code>方法，可以删除掉。</p>\n</blockquote>\n<p><code>Html</code>、<code>Head</code>、<code>Main</code>和<code>JoyScript</code>是页面必须的，在自定义的<code>Document</code>类中，不要删除它们和更改顺序。\n但它们支持一些自定义的属性，例如：</p>\n<pre><code class=\"hljs language-tsx\">&lt;<span class=\"hljs-title class_\">Html</span> lang=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;\n</code></pre>\n<p>这里的<code>&lt;Head /&gt;</code>不同于<code>@symph/joy/react</code>中的<code>Head</code>组件，这里的<code>&lt;Head /&gt;</code>用于定义在所有页面中共有的<code>&lt;head&gt;</code>元素，而其它的，例如<code>&lt;title&gt;</code>标签，建议在页面组件中使用<code>@symph/joy/react</code>中的<code>Head</code>组件来定义。</p>\n<p><code>getInitialProps</code>方法返回<code>Document</code>组件的初始 props，参数<code>ctx: DocumentContext</code>具有以下属性：</p>\n<ul>\n<li><code>pathname</code>：<code>string</code>，当前渲染的页面路径。</li>\n<li><code>query</code>： <code>object</code>， url 中的请求参数被解析后的对象。</li>\n<li><code>req</code>：<a href=\"https://nodejs.org/api/http.html#http_class_http_incomingmessage\"><code>IncomingMessage</code></a>, 触发当前渲染的请求对象。</li>\n<li><code>res</code>：<a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\"><code>ServerResponse</code></a>, 触发当前渲染的请求的响应对象。</li>\n<li><code>err</code> ：Error, 在渲染阶段出现的异常。</li>\n<li><code>renderPage</code>: <code>functin</code> 将<code>App</code>渲染为 html 字符串，返回值<code>{html, head}</code>在服务端渲染时。</li>\n</ul>\n\n                <h2 id=\"%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">\n                  注意事项\n                </h2><ul>\n<li><code>Document</code>只在服务端被渲染，事件处理并不会触发执行，例如<code>onClick</code>事件。同理 React 的部分生命周期也不会执行，例如<code>onComponentDidMount</code>。</li>\n<li>在<code>&lt;Main/&gt;</code>之外的 React 组件并不会被浏览器初始化，所以不要在这里添加任何业务逻辑。如果需要给整个应用添加统一的组件，可以在根布局组件中添加，或者<code>App</code>中添加。</li>\n</ul>\n","anchor":[{"type":"heading","raw":"## _document.tsx\n\n","depth":2,"text":"_document.tsx","tokens":[{"type":"text","raw":"_document.tsx","text":"_document.tsx"}],"id":"#_documenttsx"},{"type":"heading","raw":"## 注意事项\n\n","depth":2,"text":"注意事项","tokens":[{"type":"text","raw":"注意事项","text":"注意事项"}],"id":"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"}]},{"title":"导出 React","path":"/joy/react/export","file":"docs\\joy\\02-react\\22-export.md","hasMenu":false,"mdContent":"# 导出 React\r\n\r\n运行命令：\r\n```shell\r\n$ joy build && joy export \r\n```\r\n\r\n构建产物默认生成到 ./out 下，目录结构类似于：\r\n\r\n```shell\r\n./out\r\n  index.html\r\n  404.html\r\n  _joy/ # 包含js、css、json等\r\n```\r\n\r\n## 本地验证\r\n\r\n使用`http-server`启动本地静态文件服务器\r\n\r\n```shell\r\n# 安装 http-server\r\n$ npm i -g http-server\r\n\r\n# 启动服务器\r\n$ http-server ./out\r\n```\r\n\r\n在浏览器上打开地址：[http://127.0.0.1:8080](http://127.0.0.1:8080), 正常情况下应该是和`yarn dev`开发运行时是一致的。\r\n\r\n## 部署\r\n\r\n本地验证完成后，将`out`目录部署到服务器上即可。\r\n\r\n","htmlContent":"\n                <h1 id=\"%E5%AF%BC%E5%87%BA-react\">\n                  导出 React\n                </h1><p>运行命令：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">joy build &amp;&amp; joy <span class=\"hljs-built_in\">export</span></span> \n</code></pre>\n<p>构建产物默认生成到 ./out 下，目录结构类似于：</p>\n<pre><code class=\"hljs language-shell\">./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n</code></pre>\n\n                <h2 id=\"%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81\">\n                  本地验证\n                </h2><p>使用<code>http-server</code>启动本地静态文件服务器</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装 http-server</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">npm i -g http-server</span>\n<span class=\"hljs-meta prompt_\">\n# </span><span class=\"language-bash\">启动服务器</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">http-server ./out</span>\n</code></pre>\n<p>在浏览器上打开地址：<a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>, 正常情况下应该是和<code>yarn dev</code>开发运行时是一致的。</p>\n\n                <h2 id=\"%E9%83%A8%E7%BD%B2\">\n                  部署\n                </h2><p>本地验证完成后，将<code>out</code>目录部署到服务器上即可。</p>\n","anchor":[{"type":"heading","raw":"## 本地验证\n\n","depth":2,"text":"本地验证","tokens":[{"type":"text","raw":"本地验证","text":"本地验证"}],"id":"#%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81"},{"type":"heading","raw":"## 部署\n\n","depth":2,"text":"部署","tokens":[{"type":"text","raw":"部署","text":"部署"}],"id":"#%E9%83%A8%E7%BD%B2"}]},{"title":"动态按需加载","path":"/joy/react/dynamic-load","file":"docs\\joy\\02-react\\30-dynamic-load.md","hasMenu":false,"mdContent":"# 动态按需加载\r\n\r\n## 动态加载模块 import()\r\n\r\nJoy 支持 ES2020 `import()` 语法，使用它在运行时动态的加载 JavaScript 模块。\r\n\r\n我们可以使用动态加载，将我们的应用代码分割为多个代码段，在应用运行时再逐步加载需要的代码段，这可以让浏览器加快应用的启动。\r\n\r\n下面例子中，我们使用`fuse.js`来模糊搜索，只在用户输入搜索关键字后，才动态加载`fuse.js`库，然后使用它来搜索。\r\n\r\n```tsx\r\nimport { useState } from \"react\";\r\n\r\nconst names = [\"Tim\", \"Joe\", \"Bel\", \"Max\", \"Lee\"];\r\n\r\nexport default function Page() {\r\n  const [results, setResults] = useState();\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"text\"\r\n        placeholder=\"Search\"\r\n        onChange={async (e) => {\r\n          const { value } = e.currentTarget;\r\n          // Dynamically load fuse.js\r\n          const Fuse = (await import(\"fuse.js\")).default;\r\n          const fuse = new Fuse(names);\r\n\r\n          setResults(fuse.search(value));\r\n        }}\r\n      />\r\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## 动态加载 React 组件\r\n\r\n使用 `@symph/joy/dynamic` 来动态加载 React 组件，它首先创建一个容器组件，在 React 组件树中使用容器组件替代目标，只当容器组件被渲染时，容器组件才会动态加载目标组件，加载完成后展示目标组件。\r\n\r\n容器组件提供加载动画、加载失败重试和错误展示的能力，它也支持服务端渲染，即服务端渲染时，动态加载的组件也能想其它组件一样同步渲染。\r\n\r\n下面的例子中展示了如何动态加载和使用 `../components/hello` 组件。\r\n\r\n```tsx\r\nimport dynamic from \"@symph/joy/dynamic\";\r\n\r\nconst DynamicComponent = dynamic(() => import(\"../components/hello\"));\r\n\r\nfunction Home() {\r\n  return (\r\n    <div>\r\n      <p>HOME PAGE</p>\r\n      <DynamicComponent />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n```\r\n\r\n> 在 `import('path/to/component')` 中， `path/to/component` 指定需动态加载组件的代码路径，该路径只能是明确的路径字符串，不能是变量或者字符串模板。\r\n> 此外，`import()`必须在`dynamic()`中调用，以便在服务端渲染时，能够在 Webpack 的输出 bundles 中查找包含该动态加载模块的 bundle，并在浏览器渲染之前预加载它们。\r\n> `dynamic()` 不能在 React 渲染中使用，因为它需要在模块的顶层进行标记，才能进行预加载，类似于`React.lazy`。\r\n\r\n如果按需动态加载的 React 组件在 JS 文件中不是 default 方式导出，而是命名的导出，我们可以在 `import()` 的结果`Promise`中取导出的命名值。\r\n例如动态加载的组件导出名称为`Hello` 时:\r\n\r\n```ts\r\nexport function Hello() {\r\n  return <p>Hello!</p>;\r\n}\r\n```\r\n\r\n引用模块和使用导出的组件：\r\n\r\n```ts\r\nconst DynamicComponent = dynamic(() => import(\"../components/hello\").then((md) => md.Hello));\r\n```\r\n\r\n### 加载动画和状态\r\n\r\n`dynamic()` 方法支持 `loading` 可选选项，用于渲染加载中的动画，或者加载失败的状态。\r\n例如：\r\n\r\n```tsx\r\nimport dynamic from \"@symph/joy/dynamic\";\r\nimport { DynamicLoadingComponentProps } from \"@symph/joy/react\";\r\n\r\nfunction LoadingComp({ error, isLoading, pastDelay }: DynamicLoadingComponentProps) {\r\n  if (error) return `error`;\r\n  if (pastDelay && isLoading) return \"...\";\r\n}\r\n\r\nconst DynamicComponentWithCustomLoading = dynamic(() => import(\"../components/hello\"), { loading: LoadingComp });\r\n\r\nfunction Home() {\r\n  return (\r\n    <div>\r\n      <p>HOME PAGE</p>\r\n      <DynamicComponentWithCustomLoading />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n```\r\n\r\n### 动态加载关闭 SSR\r\n\r\n有时候我们想为动态加载的组件关闭服务端渲染，只在浏览器上运行该组件。 我们可以设置 `ssr` 属性为 false：\r\n\r\n```tsx\r\nimport dynamic from \"@symph/joy/dynamic\";\r\n\r\nconst DynamicComponentWithNoSSR = dynamic(() => import(\"../components/hello\"), { ssr: false });\r\n\r\nfunction Home() {\r\n  return (\r\n    <div>\r\n      <p>HOME PAGE</p>\r\n      <DynamicComponentWithNoSSR />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n```\r\n\r\n### 动态加载使用 suspense\r\n\r\n类似 React 18 的 `React.lazy` 和 `<Suspense>`, 使用 `suspense` 参数来延迟懒加载组件。注意这暂时只能在服务端或者客户端的 `fallback`模式下有效。\r\n\r\n```tsx\r\nimport dynamic from \"@symph/joy/dynamic\";\r\n\r\nconst DynamicLazyComponent = dynamic(() => import(\"../components/hello\"), { suspense: true });\r\n\r\nfunction Home() {\r\n  return (\r\n    <div>\r\n      <p>HOME PAGE</p>\r\n      <Suspense fallback={`loading`}>\r\n        <DynamicLazyComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Home;\r\n```\r\n\r\n## 动态加载 Joy 路由组件\r\n\r\n动态加载路由组件，指只有渲染该路由页面时，才会加载该路由组件相关联的代码模块。\r\n我们可以直接使用 `@ReactDynamicLoad(options )` 装饰器将 `@ReactRoute` 路由组件模块声明为动态加载模块。\r\n动态加载的路由组件也支持服务端渲染，和 `@symph/joy/dynamic` 的参数列表类似，我们也可以为动态路由组件设置加载参数，例如：\r\n\r\n```tsx\r\nimport React, { ReactNode } from \"react\";\r\nimport { BaseReactController, ReactController, ReactRoute } from \"@symph/react\";\r\nimport { ReactDynamicLoad } from \"@symph/joy/react\";\r\n\r\n@ReactDynamicLoad({ delay: 200, timeout: 1000 })\r\n@ReactRoute({ path: \"/about\" })\r\n@ReactController()\r\nexport class AboutPage extends BaseReactController {\r\n  renderView(): ReactNode {\r\n    return <div>AboutPage</div>;\r\n  }\r\n}\r\n```\r\n\r\n`@ReactDynamicLoad` 支持可选的参数有：\r\n\r\n- loading: `string` 加载动画组件的组件名称。\r\n- delay: `number`, 默认值 `200`，表示如果在 200 毫秒内加载完成，就不用展示加载动画。这可以减少短时间内的界面切换给用户带来的困扰，让页面看起来加载的更快。\r\n- timeout: `number` 设置加载的超时时间。\r\n\r\n### 路由加载动画\r\n\r\n和`@symph/joy/dynamic`不一样的是，`loading` 参数只能设置加载动画组件的组件字符串名称，而不是具体的加载组件。\r\n因为要保证加载路由组件之前 Loading 组件已经存在，才能在加载时展现加载动画，同时还得要确保 Loading 模块和路由模块之间没有静态的依赖关系，webpack 才不会将两者打包到一起。\r\n所以需使用字符串的组件名来指向当前运行时已经存在的组件名称。\r\n\r\n我们可以在上层路由或者根路由文件模块导出 Loading 组件，来确保在动态路由模块加载之前，应用上下文中已经注册了 Loading 组件。\r\n例如在根布局路由中：\r\n\r\n```tsx\r\n// src/client/pages/_layout.tsx\r\n\r\n/**\r\n * 根路由组件\r\n */\r\nimport React, { ReactNode } from \"react\";\r\nimport { BaseReactController, ReactController, ReactRouteContainer } from \"@symph/react\";\r\nimport { Outlet } from \"react-router-dom\";\r\nimport { LoadableLoadingComponentProps } from \"@symph/joy/react\";\r\n\r\n@ReactRouteContainer({ path: \"/\" })\r\n@ReactController()\r\nexport class Rootlayout extends BaseReactController {\r\n  renderView(): ReactNode {\r\n    return (\r\n      <>\r\n        <Head>Hello</Head>\r\n        <Outlet />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * 自定义的加载动画组件\r\n */\r\n@ReactController()\r\nexport class DynamicLoading extends BaseReactController<LoadableLoadingComponentProps> {\r\n  renderView(): ReactNode {\r\n    return (\r\n      <>\r\n        <div id=\"loadingMsg\">Custom loading...</div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n然后在申明动态加载路由组件时，设置加载中动画组件。\r\n\r\n```tsx\r\nimport React, { ReactNode } from \"react\";\r\nimport { BaseReactController, ReactController, ReactRoute } from \"@symph/react\";\r\nimport { ReactDynamicLoad } from \"@symph/joy/react\";\r\n\r\n@ReactDynamicLoad({ loading: \"dynamicLoading\" }) \r\n@ReactRoute({ path: \"/about\" })\r\n@ReactController()\r\nexport class DynamicAboutPage extends BaseReactController {\r\n  renderView(): ReactNode {\r\n    return <div>This is dynamic load about page.</div>;\r\n  }\r\n}\r\n```\r\n","htmlContent":"\n                <h1 id=\"%E5%8A%A8%E6%80%81%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD\">\n                  动态按需加载\n                </h1>\n                <h2 id=\"%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97-import()\">\n                  动态加载模块 import()\n                </h2><p>Joy 支持 ES2020 <code>import()</code> 语法，使用它在运行时动态的加载 JavaScript 模块。</p>\n<p>我们可以使用动态加载，将我们的应用代码分割为多个代码段，在应用运行时再逐步加载需要的代码段，这可以让浏览器加快应用的启动。</p>\n<p>下面例子中，我们使用<code>fuse.js</code>来模糊搜索，只在用户输入搜索关键字后，才动态加载<code>fuse.js</code>库，然后使用它来搜索。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> { useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> names = [<span class=\"hljs-string\">&quot;Tim&quot;</span>, <span class=\"hljs-string\">&quot;Joe&quot;</span>, <span class=\"hljs-string\">&quot;Bel&quot;</span>, <span class=\"hljs-string\">&quot;Max&quot;</span>, <span class=\"hljs-string\">&quot;Lee&quot;</span>];\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Page</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [results, setResults] = <span class=\"hljs-title function_\">useState</span>();\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n        <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span>\n        <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;Search&quot;</span>\n        <span class=\"hljs-attr\">onChange</span>=<span class=\"hljs-string\">{async</span> (<span class=\"hljs-attr\">e</span>) =&gt;</span> {\n          const { value } = e.currentTarget;\n          // Dynamically load fuse.js\n          const Fuse = (await import(&quot;fuse.js&quot;)).default;\n          const fuse = new Fuse(names);\n\n          setResults(fuse.search(value));\n        }}\n      /&gt;\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pre</span>&gt;</span>Results: {JSON.stringify(results, null, 2)}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pre</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n</code></pre>\n\n                <h2 id=\"%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-react-%E7%BB%84%E4%BB%B6\">\n                  动态加载 React 组件\n                </h2><p>使用 <code>@symph/joy/dynamic</code> 来动态加载 React 组件，它首先创建一个容器组件，在 React 组件树中使用容器组件替代目标，只当容器组件被渲染时，容器组件才会动态加载目标组件，加载完成后展示目标组件。</p>\n<p>容器组件提供加载动画、加载失败重试和错误展示的能力，它也支持服务端渲染，即服务端渲染时，动态加载的组件也能想其它组件一样同步渲染。</p>\n<p>下面的例子中展示了如何动态加载和使用 <code>../components/hello</code> 组件。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/dynamic&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DynamicComponent</span> = <span class=\"hljs-title function_\">dynamic</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&quot;../components/hello&quot;</span>));\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>HOME PAGE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DynamicComponent</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n<blockquote>\n<p>在 <code>import(&#39;path/to/component&#39;)</code> 中， <code>path/to/component</code> 指定需动态加载组件的代码路径，该路径只能是明确的路径字符串，不能是变量或者字符串模板。\n此外，<code>import()</code>必须在<code>dynamic()</code>中调用，以便在服务端渲染时，能够在 Webpack 的输出 bundles 中查找包含该动态加载模块的 bundle，并在浏览器渲染之前预加载它们。\n<code>dynamic()</code> 不能在 React 渲染中使用，因为它需要在模块的顶层进行标记，才能进行预加载，类似于<code>React.lazy</code>。</p>\n</blockquote>\n<p>如果按需动态加载的 React 组件在 JS 文件中不是 default 方式导出，而是命名的导出，我们可以在 <code>import()</code> 的结果<code>Promise</code>中取导出的命名值。\n例如动态加载的组件导出名称为<code>Hello</code> 时:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Hello</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>;\n}\n</code></pre>\n<p>引用模块和使用导出的组件：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DynamicComponent</span> = <span class=\"hljs-title function_\">dynamic</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&quot;../components/hello&quot;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">md</span>) =&gt;</span> md.<span class=\"hljs-property\">Hello</span>));\n</code></pre>\n\n                <h3 id=\"%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%92%8C%E7%8A%B6%E6%80%81\">\n                  加载动画和状态\n                </h3><p><code>dynamic()</code> 方法支持 <code>loading</code> 可选选项，用于渲染加载中的动画，或者加载失败的状态。\n例如：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/dynamic&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">DynamicLoadingComponentProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">LoadingComp</span>(<span class=\"hljs-params\">{ error, isLoading, pastDelay }: DynamicLoadingComponentProps</span>) {\n  <span class=\"hljs-keyword\">if</span> (error) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`error`</span>;\n  <span class=\"hljs-keyword\">if</span> (pastDelay &amp;&amp; isLoading) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;...&quot;</span>;\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DynamicComponentWithCustomLoading</span> = <span class=\"hljs-title function_\">dynamic</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&quot;../components/hello&quot;</span>), { <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-title class_\">LoadingComp</span> });\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>HOME PAGE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DynamicComponentWithCustomLoading</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n\n                <h3 id=\"%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B3%E9%97%AD-ssr\">\n                  动态加载关闭 SSR\n                </h3><p>有时候我们想为动态加载的组件关闭服务端渲染，只在浏览器上运行该组件。 我们可以设置 <code>ssr</code> 属性为 false：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/dynamic&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DynamicComponentWithNoSSR</span> = <span class=\"hljs-title function_\">dynamic</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&quot;../components/hello&quot;</span>), { <span class=\"hljs-attr\">ssr</span>: <span class=\"hljs-literal\">false</span> });\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>HOME PAGE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DynamicComponentWithNoSSR</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n\n                <h3 id=\"%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BD%BF%E7%94%A8-suspense\">\n                  动态加载使用 suspense\n                </h3><p>类似 React 18 的 <code>React.lazy</code> 和 <code>&lt;Suspense&gt;</code>, 使用 <code>suspense</code> 参数来延迟懒加载组件。注意这暂时只能在服务端或者客户端的 <code>fallback</code>模式下有效。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> dynamic <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/dynamic&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">DynamicLazyComponent</span> = <span class=\"hljs-title function_\">dynamic</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">import</span>(<span class=\"hljs-string\">&quot;../components/hello&quot;</span>), { <span class=\"hljs-attr\">suspense</span>: <span class=\"hljs-literal\">true</span> });\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Home</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>HOME PAGE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Suspense</span> <span class=\"hljs-attr\">fallback</span>=<span class=\"hljs-string\">{</span>`<span class=\"hljs-attr\">loading</span>`}&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DynamicLazyComponent</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Suspense</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Home</span>;\n</code></pre>\n\n                <h2 id=\"%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-joy-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6\">\n                  动态加载 Joy 路由组件\n                </h2><p>动态加载路由组件，指只有渲染该路由页面时，才会加载该路由组件相关联的代码模块。\n我们可以直接使用 <code>@ReactDynamicLoad(options )</code> 装饰器将 <code>@ReactRoute</code> 路由组件模块声明为动态加载模块。\n动态加载的路由组件也支持服务端渲染，和 <code>@symph/joy/dynamic</code> 的参数列表类似，我们也可以为动态路由组件设置加载参数，例如：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">ReactNode</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactDynamicLoad</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactDynamicLoad</span>({ <span class=\"hljs-attr\">delay</span>: <span class=\"hljs-number\">200</span>, <span class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\">1000</span> })\n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/about&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AboutPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>AboutPage<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n<p><code>@ReactDynamicLoad</code> 支持可选的参数有：</p>\n<ul>\n<li>loading: <code>string</code> 加载动画组件的组件名称。</li>\n<li>delay: <code>number</code>, 默认值 <code>200</code>，表示如果在 200 毫秒内加载完成，就不用展示加载动画。这可以减少短时间内的界面切换给用户带来的困扰，让页面看起来加载的更快。</li>\n<li>timeout: <code>number</code> 设置加载的超时时间。</li>\n</ul>\n\n                <h3 id=\"%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB\">\n                  路由加载动画\n                </h3><p>和<code>@symph/joy/dynamic</code>不一样的是，<code>loading</code> 参数只能设置加载动画组件的组件字符串名称，而不是具体的加载组件。\n因为要保证加载路由组件之前 Loading 组件已经存在，才能在加载时展现加载动画，同时还得要确保 Loading 模块和路由模块之间没有静态的依赖关系，webpack 才不会将两者打包到一起。\n所以需使用字符串的组件名来指向当前运行时已经存在的组件名称。</p>\n<p>我们可以在上层路由或者根路由文件模块导出 Loading 组件，来确保在动态路由模块加载之前，应用上下文中已经注册了 Loading 组件。\n例如在根布局路由中：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-comment\">// src/client/pages/_layout.tsx</span>\n\n<span class=\"hljs-comment\">/**\n * 根路由组件\n */</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">ReactNode</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">ReactRouteContainer</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Outlet</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-router-dom&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">LoadableLoadingComponentProps</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactRouteContainer</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rootlayout</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Head</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Outlet</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n\n<span class=\"hljs-comment\">/**\n * 自定义的加载动画组件\n */</span>\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DynamicLoading</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span>&lt;<span class=\"hljs-title class_\">LoadableLoadingComponentProps</span>&gt; {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;loadingMsg&quot;</span>&gt;</span>Custom loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/&gt;</span></span>\n    );\n  }\n}\n</code></pre>\n<p>然后在申明动态加载路由组件时，设置加载中动画组件。</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { <span class=\"hljs-title class_\">ReactNode</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BaseReactController</span>, <span class=\"hljs-title class_\">ReactController</span>, <span class=\"hljs-title class_\">ReactRoute</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/react&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ReactDynamicLoad</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/joy/react&quot;</span>;\n\n<span class=\"hljs-meta\">@ReactDynamicLoad</span>({ <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-string\">&quot;dynamicLoading&quot;</span> }) \n<span class=\"hljs-meta\">@ReactRoute</span>({ <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/about&quot;</span> })\n<span class=\"hljs-meta\">@ReactController</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DynamicAboutPage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">BaseReactController</span> {\n  <span class=\"hljs-title function_\">renderView</span>(): <span class=\"hljs-title class_\">ReactNode</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>This is dynamic load about page.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span>;\n  }\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 动态加载模块 import()\n\n","depth":2,"text":"动态加载模块 import()","tokens":[{"type":"text","raw":"动态加载模块 import()","text":"动态加载模块 import()"}],"id":"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97-import()"},{"type":"heading","raw":"## 动态加载 React 组件\n\n","depth":2,"text":"动态加载 React 组件","tokens":[{"type":"text","raw":"动态加载 React 组件","text":"动态加载 React 组件"}],"id":"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-react-%E7%BB%84%E4%BB%B6","children":[{"type":"heading","raw":"### 加载动画和状态\n\n","depth":3,"text":"加载动画和状态","tokens":[{"type":"text","raw":"加载动画和状态","text":"加载动画和状态"}],"id":"#%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%92%8C%E7%8A%B6%E6%80%81"},{"type":"heading","raw":"### 动态加载关闭 SSR\n\n","depth":3,"text":"动态加载关闭 SSR","tokens":[{"type":"text","raw":"动态加载关闭 SSR","text":"动态加载关闭 SSR"}],"id":"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%85%B3%E9%97%AD-ssr"},{"type":"heading","raw":"### 动态加载使用 suspense\n\n","depth":3,"text":"动态加载使用 suspense","tokens":[{"type":"text","raw":"动态加载使用 suspense","text":"动态加载使用 suspense"}],"id":"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BD%BF%E7%94%A8-suspense"}]},{"type":"heading","raw":"## 动态加载 Joy 路由组件\n\n","depth":2,"text":"动态加载 Joy 路由组件","tokens":[{"type":"text","raw":"动态加载 Joy 路由组件","text":"动态加载 Joy 路由组件"}],"id":"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-joy-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6","children":[{"type":"heading","raw":"### 路由加载动画\n\n","depth":3,"text":"路由加载动画","tokens":[{"type":"text","raw":"路由加载动画","text":"路由加载动画"}],"id":"#%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB"}]}]},{"title":"快速刷新 Fast Refresh","path":"/joy/react/fast-refresh","file":"docs\\joy\\02-react\\31-fast-refresh.md","hasMenu":false,"mdContent":"# 快速刷新 Fast Refresh\r\n\r\n快速刷新（Fast Refresh）是 React 官方提供的热更新解决方案，让我们可以在对 React 组件进行修改时提供即时反馈。\r\n\r\n例如在开发时，我们修改了组件的布局或样式后，浏览器界面自动更新为新的布局或样式，假设之前在界面的表单里已经填入了数据，那这些数据应该依然存在。\r\n\r\nJoy 应用默认开启了快速刷新，大部分情况下，在 1 秒左右能看到更新后的结果。\r\n\r\n> 本文描述的组件状态，指的是 React 组件内部状态 `state`。\r\n>\r\n> 而我们的业务数据状态通常应该存放在 `ReactModel` 中，得益于 [@symph/react](/react/start/introduce) 统一数据源的设计，在 Fast Refresh 过程中不受影响，因为 React 能够使用全局状态在任何时候重新渲染组件。\r\n\r\n## 如何工作的\r\n\r\n- 如果编辑了一个只导出 React 组件的文件，Fast Refresh 将只热更新该文件的代码，并重新渲染组件。您可以编辑该文件中的任何内容，包括样式、呈现逻辑、事件处理程序或效果。\r\n- 如果编辑了一个非 React 组件导出的文件，Fast Refresh 会重新运行该文件，以及导入它的其他文件。因此，如果 `Button.js` 和 `Modal.js` 都导入了 `theme.js`，编辑 `theme.js` 将更新这两个组件。\r\n- 最后，如果编辑了一个由非 React 树导入的文件，Fast Refresh 将降级到完全重新加载。例如有一个文件，它渲染了一个 React 组件，但也导出了一个常量，而一个非 React 模块导入了它。\r\n  在这种情况下，想让快速刷新重新生效，可考虑将常量迁移到一个单独的文件，并将其导入到两个文件中。其它很多情况通常也可以用类似的方法解决。\r\n\r\n## 错误恢复\r\n\r\n### 语法错误\r\n\r\n如果在开发过程中出现语法错误，在编译中会看到错误提示，可以修复它并再次保存文件，这个错误会自动消失。因此我们不需要重新加载应用，也不会丢失组件状态。\r\n\r\n### 运行时错误\r\n\r\n如果组件内部出现运行时错误，界面将出现错误提示浮层覆盖界面，修复错误后，这个浮层会自动消失，无需重新加载整个应用。\r\n\r\n如果错误不是发生在组件渲染期间，错误修复后，组件的状态将会保留。但如果错误发现在组件渲染期间，React 将会使用更新后的代码重新加载应用。\r\n\r\n如果应用程序中有 [错误边界](https://reactjs.org/docs/error-boundaries.html) (这对于生产中是处理错误的一个推荐方式)，出现错误后将在下次修改时尝试重新渲染边界内的组件。\r\n这意味着错误边界可以防止错误上抛到应用根组件，重置整个应用状态。但是，要记住错误边界不应该太细，它们应该是为生产中特意设计和使用的。\r\n\r\n## 保留状态局限性\r\n\r\n在安全的情况下，Fast Refresh 试图在编辑组件后热更新组件时保留 React 组件的状态，但在以下是一些不安全的情况下，React 组件将重新挂载，状态不会被保留:\r\n\r\n- React 类声明的组件，其内部状态不会被保留。只有使用函数组件和 Hooks 时，才会保留状态。\r\n- 除了 React 组件之外，正在编辑的文件可能还有其他导出。\r\n- 当导出的组件是一个高阶组件（HOC 如： WrappedComponent），且高阶组件返回的是一个类时。\r\n- 匿名箭头函数，如 `export default () => <div />;`，也将导致状态重置。此时可考虑使用命名函数代替：`export default funciton MyComponent () { return <div />;}` 。\r\n\r\n## 使用技巧\r\n\r\n- 尽量将业务数据状态放在 ReactModel 中，它不受 Fast Refresh 的影响，能够更好的恢复业务场景。\r\n- 默认情况下，函数式组件能够更好的支持 Fast Refresh，在更新的过程中保留组件状态。\r\n- 有时，您可能希望强制重置状态，并重新安装组件。例如，如果你要调整一个只发生在挂载上的动画，这就很方便了。为此，我们可以通过在编辑的文件的任何位置添加 `// @refresh reset`注释， 指示 Fast Refresh 在每次编辑时重新挂载在该文件中定义的组件。\r\n- 通过 Fast Refresh，我们可以在编辑的文件中添加 `console.log` 或者 `debug`来调试应用，不用重新加载应用来使打印日志生效。\r\n\r\n## Fast Refresh 和 Hooks\r\n\r\n在尽可能的情况下， Fast Refresh 尝试在两次编辑之间保存组件的状态。特别是，只要不更改它们的参数或 Hook 调用的顺序，`useState`和`useRef`就会保留它们以前的值。\r\n\r\n带有依赖项的钩子（如`useEffect`、`useMemo`和`usecallback`）将始终在快速刷新期间更新。当快速刷新发生时，它们的依赖项列表将被忽略。\r\n例如，当编辑`useMemo(() => x * 2， [x])`为`useMemo (() => x * 10， [x])`时，即使`x`(依赖项)没有改变，它也会重新运行。\r\n\r\n有时，这可能会导致意想不到的结果。例如，即使一个带有空依赖数组的 `useEffect` 仍然会在快速刷新期间重新运行一次。\r\n\r\n然而，即使没有快速刷新，编写能够适应偶尔重新运行 useEffect 的代码也是一个很好的实践。\r\n它将使你更容易在以后引入新的依赖，并且它也是 React `Strict Mode`强制约束的，强烈建议启用它。\r\n","htmlContent":"\n                <h1 id=\"%E5%BF%AB%E9%80%9F%E5%88%B7%E6%96%B0-fast-refresh\">\n                  快速刷新 Fast Refresh\n                </h1><p>快速刷新（Fast Refresh）是 React 官方提供的热更新解决方案，让我们可以在对 React 组件进行修改时提供即时反馈。</p>\n<p>例如在开发时，我们修改了组件的布局或样式后，浏览器界面自动更新为新的布局或样式，假设之前在界面的表单里已经填入了数据，那这些数据应该依然存在。</p>\n<p>Joy 应用默认开启了快速刷新，大部分情况下，在 1 秒左右能看到更新后的结果。</p>\n<blockquote>\n<p>本文描述的组件状态，指的是 React 组件内部状态 <code>state</code>。</p>\n<p>而我们的业务数据状态通常应该存放在 <code>ReactModel</code> 中，得益于 <a href=\"/react/start/introduce\">@symph/react</a> 统一数据源的设计，在 Fast Refresh 过程中不受影响，因为 React 能够使用全局状态在任何时候重新渲染组件。</p>\n</blockquote>\n\n                <h2 id=\"%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\">\n                  如何工作的\n                </h2><ul>\n<li>如果编辑了一个只导出 React 组件的文件，Fast Refresh 将只热更新该文件的代码，并重新渲染组件。您可以编辑该文件中的任何内容，包括样式、呈现逻辑、事件处理程序或效果。</li>\n<li>如果编辑了一个非 React 组件导出的文件，Fast Refresh 会重新运行该文件，以及导入它的其他文件。因此，如果 <code>Button.js</code> 和 <code>Modal.js</code> 都导入了 <code>theme.js</code>，编辑 <code>theme.js</code> 将更新这两个组件。</li>\n<li>最后，如果编辑了一个由非 React 树导入的文件，Fast Refresh 将降级到完全重新加载。例如有一个文件，它渲染了一个 React 组件，但也导出了一个常量，而一个非 React 模块导入了它。\n在这种情况下，想让快速刷新重新生效，可考虑将常量迁移到一个单独的文件，并将其导入到两个文件中。其它很多情况通常也可以用类似的方法解决。</li>\n</ul>\n\n                <h2 id=\"%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D\">\n                  错误恢复\n                </h2>\n                <h3 id=\"%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF\">\n                  语法错误\n                </h3><p>如果在开发过程中出现语法错误，在编译中会看到错误提示，可以修复它并再次保存文件，这个错误会自动消失。因此我们不需要重新加载应用，也不会丢失组件状态。</p>\n\n                <h3 id=\"%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF\">\n                  运行时错误\n                </h3><p>如果组件内部出现运行时错误，界面将出现错误提示浮层覆盖界面，修复错误后，这个浮层会自动消失，无需重新加载整个应用。</p>\n<p>如果错误不是发生在组件渲染期间，错误修复后，组件的状态将会保留。但如果错误发现在组件渲染期间，React 将会使用更新后的代码重新加载应用。</p>\n<p>如果应用程序中有 <a href=\"https://reactjs.org/docs/error-boundaries.html\">错误边界</a> (这对于生产中是处理错误的一个推荐方式)，出现错误后将在下次修改时尝试重新渲染边界内的组件。\n这意味着错误边界可以防止错误上抛到应用根组件，重置整个应用状态。但是，要记住错误边界不应该太细，它们应该是为生产中特意设计和使用的。</p>\n\n                <h2 id=\"%E4%BF%9D%E7%95%99%E7%8A%B6%E6%80%81%E5%B1%80%E9%99%90%E6%80%A7\">\n                  保留状态局限性\n                </h2><p>在安全的情况下，Fast Refresh 试图在编辑组件后热更新组件时保留 React 组件的状态，但在以下是一些不安全的情况下，React 组件将重新挂载，状态不会被保留:</p>\n<ul>\n<li>React 类声明的组件，其内部状态不会被保留。只有使用函数组件和 Hooks 时，才会保留状态。</li>\n<li>除了 React 组件之外，正在编辑的文件可能还有其他导出。</li>\n<li>当导出的组件是一个高阶组件（HOC 如： WrappedComponent），且高阶组件返回的是一个类时。</li>\n<li>匿名箭头函数，如 <code>export default () =&gt; &lt;div /&gt;;</code>，也将导致状态重置。此时可考虑使用命名函数代替：<code>export default funciton MyComponent () { return &lt;div /&gt;;}</code> 。</li>\n</ul>\n\n                <h2 id=\"%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\">\n                  使用技巧\n                </h2><ul>\n<li>尽量将业务数据状态放在 ReactModel 中，它不受 Fast Refresh 的影响，能够更好的恢复业务场景。</li>\n<li>默认情况下，函数式组件能够更好的支持 Fast Refresh，在更新的过程中保留组件状态。</li>\n<li>有时，您可能希望强制重置状态，并重新安装组件。例如，如果你要调整一个只发生在挂载上的动画，这就很方便了。为此，我们可以通过在编辑的文件的任何位置添加 <code>// @refresh reset</code>注释， 指示 Fast Refresh 在每次编辑时重新挂载在该文件中定义的组件。</li>\n<li>通过 Fast Refresh，我们可以在编辑的文件中添加 <code>console.log</code> 或者 <code>debug</code>来调试应用，不用重新加载应用来使打印日志生效。</li>\n</ul>\n\n                <h2 id=\"fast-refresh-%E5%92%8C-hooks\">\n                  Fast Refresh 和 Hooks\n                </h2><p>在尽可能的情况下， Fast Refresh 尝试在两次编辑之间保存组件的状态。特别是，只要不更改它们的参数或 Hook 调用的顺序，<code>useState</code>和<code>useRef</code>就会保留它们以前的值。</p>\n<p>带有依赖项的钩子（如<code>useEffect</code>、<code>useMemo</code>和<code>usecallback</code>）将始终在快速刷新期间更新。当快速刷新发生时，它们的依赖项列表将被忽略。\n例如，当编辑<code>useMemo(() =&gt; x * 2， [x])</code>为<code>useMemo (() =&gt; x * 10， [x])</code>时，即使<code>x</code>(依赖项)没有改变，它也会重新运行。</p>\n<p>有时，这可能会导致意想不到的结果。例如，即使一个带有空依赖数组的 <code>useEffect</code> 仍然会在快速刷新期间重新运行一次。</p>\n<p>然而，即使没有快速刷新，编写能够适应偶尔重新运行 useEffect 的代码也是一个很好的实践。\n它将使你更容易在以后引入新的依赖，并且它也是 React <code>Strict Mode</code>强制约束的，强烈建议启用它。</p>\n","anchor":[{"type":"heading","raw":"## 如何工作的\n\n","depth":2,"text":"如何工作的","tokens":[{"type":"text","raw":"如何工作的","text":"如何工作的"}],"id":"#%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84"},{"type":"heading","raw":"## 错误恢复\n\n","depth":2,"text":"错误恢复","tokens":[{"type":"text","raw":"错误恢复","text":"错误恢复"}],"id":"#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D","children":[{"type":"heading","raw":"### 语法错误\n\n","depth":3,"text":"语法错误","tokens":[{"type":"text","raw":"语法错误","text":"语法错误"}],"id":"#%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF"},{"type":"heading","raw":"### 运行时错误\n\n","depth":3,"text":"运行时错误","tokens":[{"type":"text","raw":"运行时错误","text":"运行时错误"}],"id":"#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%94%99%E8%AF%AF"}]},{"type":"heading","raw":"## 保留状态局限性\n\n","depth":2,"text":"保留状态局限性","tokens":[{"type":"text","raw":"保留状态局限性","text":"保留状态局限性"}],"id":"#%E4%BF%9D%E7%95%99%E7%8A%B6%E6%80%81%E5%B1%80%E9%99%90%E6%80%A7"},{"type":"heading","raw":"## 使用技巧\n\n","depth":2,"text":"使用技巧","tokens":[{"type":"text","raw":"使用技巧","text":"使用技巧"}],"id":"#%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"},{"type":"heading","raw":"## Fast Refresh 和 Hooks\n\n","depth":2,"text":"Fast Refresh 和 Hooks","tokens":[{"type":"text","raw":"Fast Refresh 和 Hooks","text":"Fast Refresh 和 Hooks"}],"id":"#fast-refresh-%E5%92%8C-hooks"}]}]},{"title":"后端开发","path":"/joy/03-server","file":"docs/joy/03-server","children":[{"title":"Node.js 服务开发","path":"/joy/server/server-dev","file":"docs\\joy\\03-server\\01-server-dev.md","hasMenu":false,"mdContent":"# Node.js 服务开发\r\n\r\n`@symph/joy` 无缝集成 [`@symph/server`](/react/start/introduce) 库，让我们可以零配置开始 React 开发。\r\n\r\n> 请跳转到 \"[@symph/server 文档](/server/start/introduce)\"，查看详细的 Node.js 服务应用开发文档。\r\n\r\nJoy 可以自动扫描和注册项目中的`@symph/server` Components 组件，同时也为 React 开发提供了额外的扩展功能:\r\n\r\n- 自动扫描和注册组件\r\n- 配置管理\r\n- 热更新和热重启\r\n","htmlContent":"\n                <h1 id=\"nodejs-%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91\">\n                  Node.js 服务开发\n                </h1><p><code>@symph/joy</code> 无缝集成 <a href=\"/react/start/introduce\"><code>@symph/server</code></a> 库，让我们可以零配置开始 React 开发。</p>\n<blockquote>\n<p>请跳转到 &quot;<a href=\"/server/start/introduce\">@symph/server 文档</a>&quot;，查看详细的 Node.js 服务应用开发文档。</p>\n</blockquote>\n<p>Joy 可以自动扫描和注册项目中的<code>@symph/server</code> Components 组件，同时也为 React 开发提供了额外的扩展功能:</p>\n<ul>\n<li>自动扫描和注册组件</li>\n<li>配置管理</li>\n<li>热更新和热重启</li>\n</ul>\n","anchor":[]},{"title":"静态文件服务","path":"/joy/server/static-file-serving","file":"docs\\joy\\03-server\\02-static-file-serving.md","hasMenu":false,"mdContent":"# 静态文件服务\r\n\r\n## public 目录\r\n\r\nJoy 提供静态文件服务，在`public`目录下存放的文件，可通过 `/` URL 前缀的`http`请求访问，例如：\r\n\r\n- `myapp/public/favicon.ico` 可通过 URL 地址 `http://localhost:3000/favicon.ico` 访问。\r\n- `myapp/public/img/image-1.png` 可通过 URL 地址 `http://localhost:3000/img/image-1.png` 访问。\r\n\r\n`public` 目录中的静态文件，仅在编译阶段处理，在 Joy 应用初始化时加载，不能在运行时动态添加和修改文件。\r\n建议使用第三方存储服务存放文件，例如阿里云和 AWS S3，可少了应用服务器的 CPU 和网络负载，也能动态的维护资源文件。\r\n\r\n> 注意： 静态文件的 URL 路径，需避免和 React 应用的页面路径或者 API 路径冲突，如果重复，将优先返回静态文件。\r\n\r\n### React 使用静态文件\r\n\r\n在 React 应用中，可使用其 URL 加载资源。导出 react 应用时，整个`public`目录也将一起导出。\r\n\r\n例如 `public/me.png`，在 React 中访问：\r\n\r\n```tsx\r\nfunction Avator() {\r\n  return <img src={\"/me.png\"} />;\r\n}\r\n```\r\n","htmlContent":"\n                <h1 id=\"%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1\">\n                  静态文件服务\n                </h1>\n                <h2 id=\"public-%E7%9B%AE%E5%BD%95\">\n                  public 目录\n                </h2><p>Joy 提供静态文件服务，在<code>public</code>目录下存放的文件，可通过 <code>/</code> URL 前缀的<code>http</code>请求访问，例如：</p>\n<ul>\n<li><code>myapp/public/favicon.ico</code> 可通过 URL 地址 <code>http://localhost:3000/favicon.ico</code> 访问。</li>\n<li><code>myapp/public/img/image-1.png</code> 可通过 URL 地址 <code>http://localhost:3000/img/image-1.png</code> 访问。</li>\n</ul>\n<p><code>public</code> 目录中的静态文件，仅在编译阶段处理，在 Joy 应用初始化时加载，不能在运行时动态添加和修改文件。\n建议使用第三方存储服务存放文件，例如阿里云和 AWS S3，可少了应用服务器的 CPU 和网络负载，也能动态的维护资源文件。</p>\n<blockquote>\n<p>注意： 静态文件的 URL 路径，需避免和 React 应用的页面路径或者 API 路径冲突，如果重复，将优先返回静态文件。</p>\n</blockquote>\n\n                <h3 id=\"react-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6\">\n                  React 使用静态文件\n                </h3><p>在 React 应用中，可使用其 URL 加载资源。导出 react 应用时，整个<code>public</code>目录也将一起导出。</p>\n<p>例如 <code>public/me.png</code>，在 React 中访问：</p>\n<pre><code class=\"hljs language-tsx\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Avator</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{</span>&quot;/<span class=\"hljs-attr\">me.png</span>&quot;} /&gt;</span></span>;\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## public 目录\n\n","depth":2,"text":"public 目录","tokens":[{"type":"text","raw":"public 目录","text":"public 目录"}],"id":"#public-%E7%9B%AE%E5%BD%95","children":[{"type":"heading","raw":"### React 使用静态文件\n\n","depth":3,"text":"React 使用静态文件","tokens":[{"type":"text","raw":"React 使用静态文件","text":"React 使用静态文件"}],"id":"#react-%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6"}]}]}]},{"title":"Joy 进阶","path":"/joy/04-advanced-use","file":"docs/joy/04-advanced-use","children":[{"title":"使用 TypeScript","path":"/joy/advanced-use/typescript","file":"docs\\joy\\04-advanced-use\\typescript.md","hasMenu":false,"mdContent":"# 使用 TypeScript\r\n\r\n`@symph/joy`应用默认支持 `TypeScript`，无需配置，即可创建`ts、tsx`文件，开始应用开发。\r\n\r\n如果需更改TypeScript选项，可在项目根目录下创建`tsconfig.json`文件，添加自定义配置。\r\n\r\n以下是默认配置：\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"strict\": false,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"noEmit\": true,\r\n    \"esModuleInterop\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"jsx\": \"preserve\"\r\n  },\r\n  \"include\": [\"**/*.ts\", \"**/*.tsx\"],\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n```\r\n\r\n","htmlContent":"\n                <h1 id=\"%E4%BD%BF%E7%94%A8-typescript\">\n                  使用 TypeScript\n                </h1><p><code>@symph/joy</code>应用默认支持 <code>TypeScript</code>，无需配置，即可创建<code>ts、tsx</code>文件，开始应用开发。</p>\n<p>如果需更改TypeScript选项，可在项目根目录下创建<code>tsconfig.json</code>文件，添加自定义配置。</p>\n<p>以下是默认配置：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;target&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;es5&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;lib&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-string\">&quot;dom&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-string\">&quot;dom.iterable&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-string\">&quot;esnext&quot;</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;allowJs&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;skipLibCheck&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;strict&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">false</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;forceConsistentCasingInFileNames&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;emitDecoratorMetadata&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;experimentalDecorators&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;noEmit&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;esModuleInterop&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;module&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;esnext&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;moduleResolution&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;node&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;resolveJsonModule&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;isolatedModules&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">true</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;jsx&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;preserve&quot;</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;include&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-string\">&quot;**/*.ts&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-string\">&quot;**/*.tsx&quot;</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;exclude&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-string\">&quot;node_modules&quot;</span><span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n","anchor":[]}]},{"title":"应用容器","path":"/joy/05-container","file":"docs/joy/05-container","children":[{"title":"应用容器","path":"/joy/container/dependency-inject","file":"docs\\joy\\05-container\\01-dependency-inject.md","hasMenu":false,"mdContent":"# 应用容器\r\n\r\n容器`ApplicationContext`是整个应用的核心，容器管理应用的所有组件`Component`，负责组件的创建和装配。\r\n\r\n`@symph/core` 库提供了应用容器的约定接口 `IApplicationContext` 和基本实现类`ApplicationContext`。\r\n\r\n## 依赖注入 Dependency Injection\r\n\r\n依赖注入指当一个对象在创建时，由容器将其依赖的其它对象的引用传递给它，是面向对象编程中的一种设计模式，是控制反转（IoC: Inversion of Control）的一种技术实现。\r\n我们只需关注组件内部的功能实现，组件的创建将由容器完成，用来减低代码之间的耦合度，让各个组件能够轻易的组装和替换，方便进行扩展和测试等。\r\n\r\n下面以服务端的代码为例，展示依赖注入是如何工作的。\r\n首选创建一个 Service 类。\r\n\r\n```ts\r\n// src/server/posts.service.ts\r\n\r\nimport { Component } from \"@symph/core\";\r\n\r\n@Component()\r\nexport class PostsService {\r\n  private readonly posts: Post[] = [];\r\n\r\n  findAll(): Post[] {\r\n    return this.posts;\r\n  }\r\n}\r\n```\r\n\r\n然后让容器将组件注入到 Controller 类中:\r\n\r\n```ts\r\n// src/server/posts.controller.ts\r\n\r\nimport { Component } from \"@symph/core\";\r\nimport { PostsService } from \"./posts.service\";\r\n\r\n@Controller(\"posts\")\r\nexport class PostsController {\r\n  constructor(private postsService: PostsService) {}\r\n\r\n  @Get()\r\n  async findAll(): Promise<Post[]> {\r\n    return this.postsService.findAll();\r\n  }\r\n}\r\n```\r\n\r\n最后，注册所有的组件到容器中：\r\n\r\n```ts\r\n// src/server/app.ts\r\nimport { INestApplication, ServerFactory } from \"@symph/server\";\r\nimport { PostsService } from \"./posts.service\";\r\nimport { PostsController } from \"./posts.controller\";\r\n\r\nasync function startApp() {\r\n  const app = await ServerFactory.create([PostsService, PostsController]);\r\n  await app.listen(3000);\r\n}\r\nstartApp();\r\n```\r\n\r\n此时我们运行`ts-node app.ts`，整个应用已能够正常运行。\r\n上面例子有 3 个关键步骤：\r\n\r\n1. 在 `posts.service.ts` 中， 使用 `@Component()` 装饰器，声明`PostsService`类是一个可被依赖注入容器管理的组件。\r\n2. 在 `posts.controller.ts`中， 在 `PostsController` 类的构造函数里， 声明其依赖 `PostsService`。\r\n3. 在 `app.ts`中， 创建应用实例并注册组件，然后启动应用。启动的过程中会逐个创建组件实例，下面我们看看如何创建 `PostsController` 实例：\r\n   1. 在依赖注入容器创建 `PostsController` 实例之前，首先检查其依赖的组件，找到了 `PostsService`。\r\n   2. 然后通过类型 `PostsService` 在容器找到了之前注册的 `PostsService` 组件。\r\n   3. 容器将先创建 `PostsService` 的实例（默认为 `SINGTON` 单例模式），缓存和返回该实例，如果缓存已经存在，则直接返回该实例。\r\n   4. 将返回的 `PostsService` 的实例作为 `PostsController`构造函数的参数，创建 `PostsController` 实例。\r\n\r\n## 和 Java Spring 的主要区别：\r\n\r\n1. Spring 中，容器管理的对象成为 Bean 在 Joy 中我们称为`Component`。\r\n2. JavaScript 没有 Java 包的概念，所以不能通过字符串的类名来指定组件的类型。 且 Joy 组件 `package` 属性，仅用于命名分组，避免命名冲突，不影响通过类型查找组件。\r\n","htmlContent":"\n                <h1 id=\"%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8\">\n                  应用容器\n                </h1><p>容器<code>ApplicationContext</code>是整个应用的核心，容器管理应用的所有组件<code>Component</code>，负责组件的创建和装配。</p>\n<p><code>@symph/core</code> 库提供了应用容器的约定接口 <code>IApplicationContext</code> 和基本实现类<code>ApplicationContext</code>。</p>\n\n                <h2 id=\"%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-dependency-injection\">\n                  依赖注入 Dependency Injection\n                </h2><p>依赖注入指当一个对象在创建时，由容器将其依赖的其它对象的引用传递给它，是面向对象编程中的一种设计模式，是控制反转（IoC: Inversion of Control）的一种技术实现。\n我们只需关注组件内部的功能实现，组件的创建将由容器完成，用来减低代码之间的耦合度，让各个组件能够轻易的组装和替换，方便进行扩展和测试等。</p>\n<p>下面以服务端的代码为例，展示依赖注入是如何工作的。\n首选创建一个 Service 类。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/server/posts.service.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsService</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">posts</span>: <span class=\"hljs-title class_\">Post</span>[] = [];\n\n  <span class=\"hljs-title function_\">findAll</span>(): <span class=\"hljs-title class_\">Post</span>[] {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">posts</span>;\n  }\n}\n</code></pre>\n<p>然后让容器将组件注入到 Controller 类中:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/server/posts.controller.ts</span>\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">PostsService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./posts.service&quot;</span>;\n\n<span class=\"hljs-meta\">@Controller</span>(<span class=\"hljs-string\">&quot;posts&quot;</span>)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsController</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> postsService: PostsService</span>) {}\n\n  <span class=\"hljs-meta\">@Get</span>()\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">findAll</span>(): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-title class_\">Post</span>[]&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">postsService</span>.<span class=\"hljs-title function_\">findAll</span>();\n  }\n}\n</code></pre>\n<p>最后，注册所有的组件到容器中：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// src/server/app.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">INestApplication</span>, <span class=\"hljs-title class_\">ServerFactory</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">PostsService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./posts.service&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">PostsController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./posts.controller&quot;</span>;\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startApp</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">ServerFactory</span>.<span class=\"hljs-title function_\">create</span>([<span class=\"hljs-title class_\">PostsService</span>, <span class=\"hljs-title class_\">PostsController</span>]);\n  <span class=\"hljs-keyword\">await</span> app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);\n}\n<span class=\"hljs-title function_\">startApp</span>();\n</code></pre>\n<p>此时我们运行<code>ts-node app.ts</code>，整个应用已能够正常运行。\n上面例子有 3 个关键步骤：</p>\n<ol>\n<li>在 <code>posts.service.ts</code> 中， 使用 <code>@Component()</code> 装饰器，声明<code>PostsService</code>类是一个可被依赖注入容器管理的组件。</li>\n<li>在 <code>posts.controller.ts</code>中， 在 <code>PostsController</code> 类的构造函数里， 声明其依赖 <code>PostsService</code>。</li>\n<li>在 <code>app.ts</code>中， 创建应用实例并注册组件，然后启动应用。启动的过程中会逐个创建组件实例，下面我们看看如何创建 <code>PostsController</code> 实例：<ol>\n<li>在依赖注入容器创建 <code>PostsController</code> 实例之前，首先检查其依赖的组件，找到了 <code>PostsService</code>。</li>\n<li>然后通过类型 <code>PostsService</code> 在容器找到了之前注册的 <code>PostsService</code> 组件。</li>\n<li>容器将先创建 <code>PostsService</code> 的实例（默认为 <code>SINGTON</code> 单例模式），缓存和返回该实例，如果缓存已经存在，则直接返回该实例。</li>\n<li>将返回的 <code>PostsService</code> 的实例作为 <code>PostsController</code>构造函数的参数，创建 <code>PostsController</code> 实例。</li>\n</ol>\n</li>\n</ol>\n\n                <h2 id=\"%E5%92%8C-java-spring-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9A\">\n                  和 Java Spring 的主要区别：\n                </h2><ol>\n<li>Spring 中，容器管理的对象成为 Bean 在 Joy 中我们称为<code>Component</code>。</li>\n<li>JavaScript 没有 Java 包的概念，所以不能通过字符串的类名来指定组件的类型。 且 Joy 组件 <code>package</code> 属性，仅用于命名分组，避免命名冲突，不影响通过类型查找组件。</li>\n</ol>\n","anchor":[{"type":"heading","raw":"## 依赖注入 Dependency Injection\n\n","depth":2,"text":"依赖注入 Dependency Injection","tokens":[{"type":"text","raw":"依赖注入 Dependency Injection","text":"依赖注入 Dependency Injection"}],"id":"#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-dependency-injection"},{"type":"heading","raw":"## 和 Java Spring 的主要区别：\n\n","depth":2,"text":"和 Java Spring 的主要区别：","tokens":[{"type":"text","raw":"和 Java Spring 的主要区别：","text":"和 Java Spring 的主要区别："}],"id":"#%E5%92%8C-java-spring-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%EF%BC%9A"}]},{"title":"组件","path":"/joy/container/components","file":"docs\\joy\\05-container\\components.md","hasMenu":false,"mdContent":"# 组件\r\n\r\n我们可以将一个类，一个常量值或者一个工厂方法注册为组件，一个组件有以自己的名称和类型，当需要它时，我们可以通过其名称或者类型获取到它的值。\r\n\r\n## 基本属性\r\n\r\n以下列举了一个组件的基本属性和作用。\r\n\r\n#### name\r\n\r\nType: `string | symbol | undefined`\r\n\r\n组件名称，可以通过名称找到组件。 即依赖注入时，我们可以通过类型注入，也能够通过名称注入。\r\n在同一个 `package` 下， 相同名称的组件，如果类型兼容，后注册的将替换之前注册的组件。\r\n\r\n在声明类组件是，如果没有指定名称，将默认通过类名生成名称，生成规则：类名首字母小写，例如：`PostsService`类生成的 组件名称为 `postsService`。\r\n\r\n#### package\r\n\r\nType: `string | undefined`\r\n\r\n为 `undefined` 时， 默认为全局组件。\r\n\r\n组件所在包名，仅用于对容器中的组件进行命名分组，相同 `package` 的组件将分内一个组， 组内是一个独立的命名空间，即同一组内的不同组件的 `name` 冲突，不同组内可以有同名的组件。\r\n组件创建时，如果有通过名称注入的依赖， 将优先在组内查找同名的组件，未找到再在全局公开组件中查找。\r\n\r\n> `package` 只有在通过名称注入时有效，通过类型注入不受此影响，如果要限制通过类型注入，请在模块内限制 `export` 导出的类型，防止被外部访问。\r\n\r\n#### global\r\n\r\nType: `bool | undefined`, Default: `false`\r\n\r\n为 `true` 表示这是公开全局公开命名组件， 能够被所有的其它组件访问。\r\n需注意，全局组件的 `name` 可能冲突，我们在开发一个独立模块是，其公开组件建议采用可区分模块的命名方式，例如 Joy 提供的数据获取组件名为 `joyFectchService`，添加 `joy` 前缀来区分.\r\n\r\n当值为 `false`时， 表示为组内非公开组件，只有在同一个组内才能通过名称访问到。\r\n\r\n#### scope\r\n\r\nType: `Scope`, Default: `Scope.SINGLETON`\r\n\r\n组件的被注入时的生命周期：\r\n\r\n- `Scope.SINGLETON` 单例模式，每次获取该组件的实例，获取的是同一个实例，当多个依赖它的组件创建时，注入过去的是同一个实例。\r\n- `Scope.PROTOTYPE` 多例模式，每次获取该组件的实例，获取的是 **不同** 实例， 当多个依赖它的组件创建时，注入过去的是 **不同** 实例。\r\n- `Scope.REQUEST` 用在服务端请求到来时，为每个请求创建对应的实例，在同一个请求过程中，不会重复创建。\r\n\r\n#### alias\r\n\r\nType: `string[]|undefined`, Default: undefined\r\n\r\n组件的别名，组件名称不可以重复，但是别名可以重复， 后注册的同别名组件，将优先使用。\r\n\r\n## 类组件\r\n\r\n### 类组件装饰器 @Component\r\n\r\n声明类组件可以通过`@Component(ComponentOptions)`装饰器和自定义组件属性两种方式。\r\n\r\n通过 `@Component(ComponentOptions)`装饰器将一个类直接声明为组件，然后直接注册该类到容器中。\r\n\r\n> 在`@symph/joy`应用中，应用启动时会自动扫描和注册工程里的所有组件。如果我们单独使用容器`ApplicationContext`，需调用`registerModule`方法注册组件到容器中。\r\n\r\n下面我们再次看一下 `PostsService` 组件，并注册到普通容器中：\r\n\r\n```ts\r\nimport { Component, Scope, ApplicationContext } from \"@symph/core\";\r\n\r\n@Component({ name: \"postService\", scope: Scope.SINGLETON })\r\nexport class PostsService {\r\n  private readonly posts: Post[] = [];\r\n\r\n  findAll(): Post[] {\r\n    return this.posts;\r\n  }\r\n}\r\n\r\nconst app = new ApplicationContext();\r\napp.registerModule([PostsService]); // 注册\r\n```\r\n\r\n`ComponentOptions` 装饰参数，除了可以设置组件的基本属性，还包含以下类组件特有的属性：\r\n\r\n##### lazyRegister\r\n\r\nType: `bool|undefined`, Default: `false`\r\n\r\n延迟注册组件，在应用启动时不注册组件，在应用运行的过程中，遇到通过类型注入，且注入的类标记为可延迟注册，则此时将该类作为组件注册到容器中，然后创建并返回该类的实例。\r\n\r\n> 目前主要在 React 应用容器中使用该特性，用于动态的加载界面和其依赖，`@ReactComponent()` 也默认开启了该属性。\r\n\r\n### 自定义类组件 useClass \r\n\r\n第二中方式，是通过自定义属性的方式注册组件, 下面例子和装饰器方式注册的效果一样。\r\n\r\n```ts\r\nimport { Scope, ApplicationContext } from \"@symph/core\";\r\n\r\nexport class PostsService {\r\n  private readonly posts: Post[] = [];\r\n\r\n  findAll(): Post[] {\r\n    return this.posts;\r\n  }\r\n}\r\n\r\nconst app = new ApplicationContext();\r\napp.registerModule([\r\n  {\r\n    name: \"postsService\",\r\n    socpe: Scope.SINGLETON,\r\n    useClass: PostsService,\r\n  },\r\n]); // 注册\r\n```\r\n\r\n### 依赖声明和注入 @Inject()\r\n\r\n`@Inject<T>(typeOrName?: string | symbol | Type<T>) {)` 装饰器在类的构造方法或属性上声明一个外部依赖。\r\n\r\n> 在面向对象编程里，强依赖建议采用构造方法注入，弱依赖采用属性注入。\r\n\r\n#### 构造方法依赖注入\r\n\r\n类构造方法的每个入参都声明了一个外部依赖，组件在创建之前，容器会逐个创建这些依赖，然后作为参数调用构造函数创建组件实例。\r\n入参上可以省略 `@Inject()` 装饰，默认采用类型注入。\r\n\r\n```ts\r\nimport { Inject, Component } from \"@symph/core\";\r\n\r\n@Component()\r\nclass PostsService {\r\n  constructor(\r\n    private databaseConnection: DatabaseConnection, // 注入 PostsService 类型的组件。\r\n    \r\n    @Inject(\"configService\")\r\n    private configService: ConfigService // 注入名称为 configService 的组件。\r\n  ) {}\r\n}\r\n```\r\n\r\n#### 属性依赖注入\r\n\r\n类声明的属性上，使用`@Inject()`装饰器声明这个是一个需依赖注入的属性.\r\n\r\n```ts\r\nimport { Inject,Component } from \"@symph/core\";\r\n\r\n@Component()\r\nclass PostsService {\r\n  @Inject()\r\n  private logService: LogService;\r\n}\r\n```\r\n\r\n## 值组件 useValue\r\n\r\n常量值也可以注册为组件，例如注册外部库到容器中，或者使用 Mock 值替换真实值等，下面我们为了测试，使用 mock 的`PostsService`替换真实的值。\r\n\r\n```ts\r\nimport { INestApplication, ServerFactory } from \"@symph/server\";\r\nimport { PostsService } from \"./posts.service\";\r\nimport { PostsController } from \"./posts.controller\";\r\n\r\nconst mockPostsService = {\r\n  /**\r\n   * mock 功能\r\n   */\r\n};\r\n\r\nasync function startApp() {\r\n  const app = await ServerFactory.create([\r\n    {\r\n      name: \"postsService\",\r\n      type: PostsService,\r\n      useValue: mockPostsService,\r\n    },\r\n    PostsController,\r\n  ]);\r\n  await app.listen(3000);\r\n}\r\nstartApp();\r\n```\r\n\r\n上例中，通过`PostsService`类型注入或者 `postsService`名字注入的地方，都将强制注入`mockPostsService`常量值。虽然是常量值，我们依然可以为组件设置`name`和`type`，用于在注入匹配组件。\r\n\r\n## 工厂组件 useFactory\r\n\r\n使用`useFactory`定义产生组件值得工厂方法，允许我们动态的创建组件。\r\n工厂方法可以使用容器中的其它的组件，`inject` 属性接受一个依赖的其它组件数组，该数组的顺序和工厂方法的入参顺序需一直，下看一个代码片段：使用配置动态创建数据库连接.\r\n\r\n```ts\r\nServerFactory.create([\r\n  {\r\n    name: \"databaseConnection\",\r\n    useFactory: (configService: ConfigService) => {\r\n      const dbOptions = configService.get(\"dbOptions\");\r\n      return new DatabaseConnection(dbOptions);\r\n    },\r\n    inject: [ConfigService], // 通过类型注入配置管理服务\r\n    scope: Scope.SINGLETON\r\n  },\r\n]);\r\n```\r\n\r\n## 注册组件\r\n\r\n我们可以在应用容器初始化之前注册组件，也可以在运行过程中加载组件。\r\n注册组件时，有已下几种数据结构可以作为参数传入，容器会自动识别这些数据结构得到里面的组件配置。\r\n\r\n1. 被 `@Component()` 装饰的组件类。\r\n2. 自定义的类组件、值组件和工厂组件。\r\n3. 被`@Configuration()`装饰的配置类。\r\n4. 包含以上 3 中结构的对象，例如`import`一个模块后，直接扫描整个模块导出的内容。\r\n5. 以上结构组成的数组。\r\n\r\n容器初始化之前注册的组件，能够在容器初始化时，第一时间扫描内部所有的组件，进行组件识别和初始化，例如识别所有的 Controller 组件，得到应用的路由信息。\r\n容器初始化之前，可以在一下 2 个地方注册组件：\r\n\r\n1. 在创建应用容器实例时，将组件列表作为容器的构造参数传入。\r\n2. 使用`registerModule(module)`方法注册组件。\r\n\r\n```ts\r\n// 1. 作为容器的构成参数传入\r\nconst applicationContext = new ApplicationContext(components);\r\n\r\n// 2. 调用注册方法注册\r\napplicationContext.registerModule(extraComponents);\r\n```\r\n\r\n应用运行时，调用 `loadModule(module)`方法动态加载组件，组件注册完成后，立即执行组件初始化。\r\n需注意：不允许重复注册同名且已经创建过实例的组件，动态注册将会报错中断，因为这会让应用导致无法预测的错误。\r\n\r\n## 获取组件值\r\n\r\n有以下 2 个方法可以容器中组件的值：\r\n\r\n```ts\r\ninterface IApplicationContext {\r\n  /**\r\n   * 获取组件值\r\n   * @param typeOrName 组件类型或名称\r\n   */\r\n  get<TInput = any>(typeOrName: TypeOrTokenType<TInput>): Promise<TInput> | TInput;\r\n\r\n  /**\r\n   * 获取组件值，如果组件不存在，返回null。\r\n   * @param typeOrName 组件类型或名称\r\n   */\r\n  getOptional<TInput = any>(typeOrName: TypeOrTokenType<TInput>): Promise<TInput> | TInput | undefined;\r\n}\r\n```\r\n\r\n如果组件时异步组件，返回的 `Promise<Input>`，什么是异步组件？\r\n\r\n1. 异步工厂方法定义的组件。\r\n2. 组件的 initialize 方法返回的 promise。\r\n3. 组件的依赖中有异步组件。\r\n\r\n当我们确定组件是非异步组件，且不想中断当前执行流程的时候，可以强制使用同步方式获取组件值。例如在 React 的渲染过程中，我们会尽力采用同步方式使用组件，避免打断渲染流程，减少不必要的重复渲染。\r\n\r\n```ts\r\ninterface IApplicationContext {\r\n  /**\r\n   * 同步获取组件值，如果组件是异步组件，将会抛出异常。\r\n   *  @param typeOrName 组件类型或名称\r\n   */\r\n  getSync<TInput = any>(typeOrName: TypeOrTokenType<TInput>): TInput;\r\n\r\n  /**\r\n   * 同步获取组件值，如果组件不存在，返回null，如果组件是异步组件，将会抛出异常。\r\n   * @param typeOrName 组件类型或名称\r\n   */\r\n  getOptionalSync<TInput = any>(typeOrName: TypeOrTokenType<TInput>): TInput | undefined;\r\n}\r\n```\r\n\r\n","htmlContent":"\n                <h1 id=\"%E7%BB%84%E4%BB%B6\">\n                  组件\n                </h1><p>我们可以将一个类，一个常量值或者一个工厂方法注册为组件，一个组件有以自己的名称和类型，当需要它时，我们可以通过其名称或者类型获取到它的值。</p>\n\n                <h2 id=\"%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7\">\n                  基本属性\n                </h2><p>以下列举了一个组件的基本属性和作用。</p>\n\n                <h4 id=\"name\">\n                  name\n                </h4><p>Type: <code>string | symbol | undefined</code></p>\n<p>组件名称，可以通过名称找到组件。 即依赖注入时，我们可以通过类型注入，也能够通过名称注入。\n在同一个 <code>package</code> 下， 相同名称的组件，如果类型兼容，后注册的将替换之前注册的组件。</p>\n<p>在声明类组件是，如果没有指定名称，将默认通过类名生成名称，生成规则：类名首字母小写，例如：<code>PostsService</code>类生成的 组件名称为 <code>postsService</code>。</p>\n\n                <h4 id=\"package\">\n                  package\n                </h4><p>Type: <code>string | undefined</code></p>\n<p>为 <code>undefined</code> 时， 默认为全局组件。</p>\n<p>组件所在包名，仅用于对容器中的组件进行命名分组，相同 <code>package</code> 的组件将分内一个组， 组内是一个独立的命名空间，即同一组内的不同组件的 <code>name</code> 冲突，不同组内可以有同名的组件。\n组件创建时，如果有通过名称注入的依赖， 将优先在组内查找同名的组件，未找到再在全局公开组件中查找。</p>\n<blockquote>\n<p><code>package</code> 只有在通过名称注入时有效，通过类型注入不受此影响，如果要限制通过类型注入，请在模块内限制 <code>export</code> 导出的类型，防止被外部访问。</p>\n</blockquote>\n\n                <h4 id=\"global\">\n                  global\n                </h4><p>Type: <code>bool | undefined</code>, Default: <code>false</code></p>\n<p>为 <code>true</code> 表示这是公开全局公开命名组件， 能够被所有的其它组件访问。\n需注意，全局组件的 <code>name</code> 可能冲突，我们在开发一个独立模块是，其公开组件建议采用可区分模块的命名方式，例如 Joy 提供的数据获取组件名为 <code>joyFectchService</code>，添加 <code>joy</code> 前缀来区分.</p>\n<p>当值为 <code>false</code>时， 表示为组内非公开组件，只有在同一个组内才能通过名称访问到。</p>\n\n                <h4 id=\"scope\">\n                  scope\n                </h4><p>Type: <code>Scope</code>, Default: <code>Scope.SINGLETON</code></p>\n<p>组件的被注入时的生命周期：</p>\n<ul>\n<li><code>Scope.SINGLETON</code> 单例模式，每次获取该组件的实例，获取的是同一个实例，当多个依赖它的组件创建时，注入过去的是同一个实例。</li>\n<li><code>Scope.PROTOTYPE</code> 多例模式，每次获取该组件的实例，获取的是 <strong>不同</strong> 实例， 当多个依赖它的组件创建时，注入过去的是 <strong>不同</strong> 实例。</li>\n<li><code>Scope.REQUEST</code> 用在服务端请求到来时，为每个请求创建对应的实例，在同一个请求过程中，不会重复创建。</li>\n</ul>\n\n                <h4 id=\"alias\">\n                  alias\n                </h4><p>Type: <code>string[]|undefined</code>, Default: undefined</p>\n<p>组件的别名，组件名称不可以重复，但是别名可以重复， 后注册的同别名组件，将优先使用。</p>\n\n                <h2 id=\"%E7%B1%BB%E7%BB%84%E4%BB%B6\">\n                  类组件\n                </h2>\n                <h3 id=\"%E7%B1%BB%E7%BB%84%E4%BB%B6%E8%A3%85%E9%A5%B0%E5%99%A8-component\">\n                  类组件装饰器 @Component\n                </h3><p>声明类组件可以通过<code>@Component(ComponentOptions)</code>装饰器和自定义组件属性两种方式。</p>\n<p>通过 <code>@Component(ComponentOptions)</code>装饰器将一个类直接声明为组件，然后直接注册该类到容器中。</p>\n<blockquote>\n<p>在<code>@symph/joy</code>应用中，应用启动时会自动扫描和注册工程里的所有组件。如果我们单独使用容器<code>ApplicationContext</code>，需调用<code>registerModule</code>方法注册组件到容器中。</p>\n</blockquote>\n<p>下面我们再次看一下 <code>PostsService</code> 组件，并注册到普通容器中：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span>, <span class=\"hljs-title class_\">Scope</span>, <span class=\"hljs-title class_\">ApplicationContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;postService&quot;</span>, <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-title class_\">Scope</span>.<span class=\"hljs-property\">SINGLETON</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsService</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">posts</span>: <span class=\"hljs-title class_\">Post</span>[] = [];\n\n  <span class=\"hljs-title function_\">findAll</span>(): <span class=\"hljs-title class_\">Post</span>[] {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">posts</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ApplicationContext</span>();\napp.<span class=\"hljs-title function_\">registerModule</span>([<span class=\"hljs-title class_\">PostsService</span>]); <span class=\"hljs-comment\">// 注册</span>\n</code></pre>\n<p><code>ComponentOptions</code> 装饰参数，除了可以设置组件的基本属性，还包含以下类组件特有的属性：</p>\n\n                <h5 id=\"lazyregister\">\n                  lazyRegister\n                </h5><p>Type: <code>bool|undefined</code>, Default: <code>false</code></p>\n<p>延迟注册组件，在应用启动时不注册组件，在应用运行的过程中，遇到通过类型注入，且注入的类标记为可延迟注册，则此时将该类作为组件注册到容器中，然后创建并返回该类的实例。</p>\n<blockquote>\n<p>目前主要在 React 应用容器中使用该特性，用于动态的加载界面和其依赖，<code>@ReactComponent()</code> 也默认开启了该属性。</p>\n</blockquote>\n\n                <h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%BB%84%E4%BB%B6-useclass\">\n                  自定义类组件 useClass\n                </h3><p>第二中方式，是通过自定义属性的方式注册组件, 下面例子和装饰器方式注册的效果一样。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Scope</span>, <span class=\"hljs-title class_\">ApplicationContext</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsService</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> <span class=\"hljs-attr\">posts</span>: <span class=\"hljs-title class_\">Post</span>[] = [];\n\n  <span class=\"hljs-title function_\">findAll</span>(): <span class=\"hljs-title class_\">Post</span>[] {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">posts</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ApplicationContext</span>();\napp.<span class=\"hljs-title function_\">registerModule</span>([\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;postsService&quot;</span>,\n    <span class=\"hljs-attr\">socpe</span>: <span class=\"hljs-title class_\">Scope</span>.<span class=\"hljs-property\">SINGLETON</span>,\n    <span class=\"hljs-attr\">useClass</span>: <span class=\"hljs-title class_\">PostsService</span>,\n  },\n]); <span class=\"hljs-comment\">// 注册</span>\n</code></pre>\n\n                <h3 id=\"%E4%BE%9D%E8%B5%96%E5%A3%B0%E6%98%8E%E5%92%8C%E6%B3%A8%E5%85%A5-inject()\">\n                  依赖声明和注入 @Inject()\n                </h3><p><code>@Inject&lt;T&gt;(typeOrName?: string | symbol | Type&lt;T&gt;) {)</code> 装饰器在类的构造方法或属性上声明一个外部依赖。</p>\n<blockquote>\n<p>在面向对象编程里，强依赖建议采用构造方法注入，弱依赖采用属性注入。</p>\n</blockquote>\n\n                <h4 id=\"%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\">\n                  构造方法依赖注入\n                </h4><p>类构造方法的每个入参都声明了一个外部依赖，组件在创建之前，容器会逐个创建这些依赖，然后作为参数调用构造函数创建组件实例。\n入参上可以省略 <code>@Inject()</code> 装饰，默认采用类型注入。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Inject</span>, <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsService</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">\n    <span class=\"hljs-keyword\">private</span> databaseConnection: DatabaseConnection, <span class=\"hljs-comment\">// 注入 PostsService 类型的组件。</span>\n    \n    <span class=\"hljs-meta\">@Inject</span>(<span class=\"hljs-string\">&quot;configService&quot;</span>)\n    <span class=\"hljs-keyword\">private</span> configService: ConfigService <span class=\"hljs-comment\">// 注入名称为 configService 的组件。</span>\n  </span>) {}\n}\n</code></pre>\n\n                <h4 id=\"%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\">\n                  属性依赖注入\n                </h4><p>类声明的属性上，使用<code>@Inject()</code>装饰器声明这个是一个需依赖注入的属性.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Inject</span>,<span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostsService</span> {\n  <span class=\"hljs-meta\">@Inject</span>()\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-attr\">logService</span>: <span class=\"hljs-title class_\">LogService</span>;\n}\n</code></pre>\n\n                <h2 id=\"%E5%80%BC%E7%BB%84%E4%BB%B6-usevalue\">\n                  值组件 useValue\n                </h2><p>常量值也可以注册为组件，例如注册外部库到容器中，或者使用 Mock 值替换真实值等，下面我们为了测试，使用 mock 的<code>PostsService</code>替换真实的值。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">INestApplication</span>, <span class=\"hljs-title class_\">ServerFactory</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/server&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">PostsService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./posts.service&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">PostsController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./posts.controller&quot;</span>;\n\n<span class=\"hljs-keyword\">const</span> mockPostsService = {\n  <span class=\"hljs-comment\">/**\n   * mock 功能\n   */</span>\n};\n\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startApp</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">ServerFactory</span>.<span class=\"hljs-title function_\">create</span>([\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;postsService&quot;</span>,\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">PostsService</span>,\n      <span class=\"hljs-attr\">useValue</span>: mockPostsService,\n    },\n    <span class=\"hljs-title class_\">PostsController</span>,\n  ]);\n  <span class=\"hljs-keyword\">await</span> app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);\n}\n<span class=\"hljs-title function_\">startApp</span>();\n</code></pre>\n<p>上例中，通过<code>PostsService</code>类型注入或者 <code>postsService</code>名字注入的地方，都将强制注入<code>mockPostsService</code>常量值。虽然是常量值，我们依然可以为组件设置<code>name</code>和<code>type</code>，用于在注入匹配组件。</p>\n\n                <h2 id=\"%E5%B7%A5%E5%8E%82%E7%BB%84%E4%BB%B6-usefactory\">\n                  工厂组件 useFactory\n                </h2><p>使用<code>useFactory</code>定义产生组件值得工厂方法，允许我们动态的创建组件。\n工厂方法可以使用容器中的其它的组件，<code>inject</code> 属性接受一个依赖的其它组件数组，该数组的顺序和工厂方法的入参顺序需一直，下看一个代码片段：使用配置动态创建数据库连接.</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-title class_\">ServerFactory</span>.<span class=\"hljs-title function_\">create</span>([\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;databaseConnection&quot;</span>,\n    <span class=\"hljs-attr\">useFactory</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">configService: ConfigService</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> dbOptions = configService.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;dbOptions&quot;</span>);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DatabaseConnection</span>(dbOptions);\n    },\n    <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-title class_\">ConfigService</span>], <span class=\"hljs-comment\">// 通过类型注入配置管理服务</span>\n    <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-title class_\">Scope</span>.<span class=\"hljs-property\">SINGLETON</span>\n  },\n]);\n</code></pre>\n\n                <h2 id=\"%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6\">\n                  注册组件\n                </h2><p>我们可以在应用容器初始化之前注册组件，也可以在运行过程中加载组件。\n注册组件时，有已下几种数据结构可以作为参数传入，容器会自动识别这些数据结构得到里面的组件配置。</p>\n<ol>\n<li>被 <code>@Component()</code> 装饰的组件类。</li>\n<li>自定义的类组件、值组件和工厂组件。</li>\n<li>被<code>@Configuration()</code>装饰的配置类。</li>\n<li>包含以上 3 中结构的对象，例如<code>import</code>一个模块后，直接扫描整个模块导出的内容。</li>\n<li>以上结构组成的数组。</li>\n</ol>\n<p>容器初始化之前注册的组件，能够在容器初始化时，第一时间扫描内部所有的组件，进行组件识别和初始化，例如识别所有的 Controller 组件，得到应用的路由信息。\n容器初始化之前，可以在一下 2 个地方注册组件：</p>\n<ol>\n<li>在创建应用容器实例时，将组件列表作为容器的构造参数传入。</li>\n<li>使用<code>registerModule(module)</code>方法注册组件。</li>\n</ol>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-comment\">// 1. 作为容器的构成参数传入</span>\n<span class=\"hljs-keyword\">const</span> applicationContext = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ApplicationContext</span>(components);\n\n<span class=\"hljs-comment\">// 2. 调用注册方法注册</span>\napplicationContext.<span class=\"hljs-title function_\">registerModule</span>(extraComponents);\n</code></pre>\n<p>应用运行时，调用 <code>loadModule(module)</code>方法动态加载组件，组件注册完成后，立即执行组件初始化。\n需注意：不允许重复注册同名且已经创建过实例的组件，动态注册将会报错中断，因为这会让应用导致无法预测的错误。</p>\n\n                <h2 id=\"%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%80%BC\">\n                  获取组件值\n                </h2><p>有以下 2 个方法可以容器中组件的值：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IApplicationContext</span> {\n  <span class=\"hljs-comment\">/**\n   * 获取组件值\n   * <span class=\"hljs-doctag\">@param</span> typeOrName 组件类型或名称\n   */</span>\n  get&lt;<span class=\"hljs-title class_\">TInput</span> = <span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-attr\">typeOrName</span>: <span class=\"hljs-title class_\">TypeOrTokenType</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt;): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt; | <span class=\"hljs-title class_\">TInput</span>;\n\n  <span class=\"hljs-comment\">/**\n   * 获取组件值，如果组件不存在，返回null。\n   * <span class=\"hljs-doctag\">@param</span> typeOrName 组件类型或名称\n   */</span>\n  getOptional&lt;<span class=\"hljs-title class_\">TInput</span> = <span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-attr\">typeOrName</span>: <span class=\"hljs-title class_\">TypeOrTokenType</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt;): <span class=\"hljs-title class_\">Promise</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt; | <span class=\"hljs-title class_\">TInput</span> | <span class=\"hljs-literal\">undefined</span>;\n}\n</code></pre>\n<p>如果组件时异步组件，返回的 <code>Promise&lt;Input&gt;</code>，什么是异步组件？</p>\n<ol>\n<li>异步工厂方法定义的组件。</li>\n<li>组件的 initialize 方法返回的 promise。</li>\n<li>组件的依赖中有异步组件。</li>\n</ol>\n<p>当我们确定组件是非异步组件，且不想中断当前执行流程的时候，可以强制使用同步方式获取组件值。例如在 React 的渲染过程中，我们会尽力采用同步方式使用组件，避免打断渲染流程，减少不必要的重复渲染。</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">IApplicationContext</span> {\n  <span class=\"hljs-comment\">/**\n   * 同步获取组件值，如果组件是异步组件，将会抛出异常。\n   *  <span class=\"hljs-doctag\">@param</span> typeOrName 组件类型或名称\n   */</span>\n  getSync&lt;<span class=\"hljs-title class_\">TInput</span> = <span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-attr\">typeOrName</span>: <span class=\"hljs-title class_\">TypeOrTokenType</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt;): <span class=\"hljs-title class_\">TInput</span>;\n\n  <span class=\"hljs-comment\">/**\n   * 同步获取组件值，如果组件不存在，返回null，如果组件是异步组件，将会抛出异常。\n   * <span class=\"hljs-doctag\">@param</span> typeOrName 组件类型或名称\n   */</span>\n  getOptionalSync&lt;<span class=\"hljs-title class_\">TInput</span> = <span class=\"hljs-built_in\">any</span>&gt;(<span class=\"hljs-attr\">typeOrName</span>: <span class=\"hljs-title class_\">TypeOrTokenType</span>&lt;<span class=\"hljs-title class_\">TInput</span>&gt;): <span class=\"hljs-title class_\">TInput</span> | <span class=\"hljs-literal\">undefined</span>;\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 基本属性\n\n","depth":2,"text":"基本属性","tokens":[{"type":"text","raw":"基本属性","text":"基本属性"}],"id":"#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7","children":[{"type":"heading","raw":"#### name\n\n","depth":4,"text":"name","tokens":[{"type":"text","raw":"name","text":"name"}],"id":"#name"},{"type":"heading","raw":"#### package\n\n","depth":4,"text":"package","tokens":[{"type":"text","raw":"package","text":"package"}],"id":"#package"},{"type":"heading","raw":"#### global\n\n","depth":4,"text":"global","tokens":[{"type":"text","raw":"global","text":"global"}],"id":"#global"},{"type":"heading","raw":"#### scope\n\n","depth":4,"text":"scope","tokens":[{"type":"text","raw":"scope","text":"scope"}],"id":"#scope"},{"type":"heading","raw":"#### alias\n\n","depth":4,"text":"alias","tokens":[{"type":"text","raw":"alias","text":"alias"}],"id":"#alias"}]},{"type":"heading","raw":"## 类组件\n\n","depth":2,"text":"类组件","tokens":[{"type":"text","raw":"类组件","text":"类组件"}],"id":"#%E7%B1%BB%E7%BB%84%E4%BB%B6","children":[{"type":"heading","raw":"### 类组件装饰器 @Component\n\n","depth":3,"text":"类组件装饰器 @Component","tokens":[{"type":"text","raw":"类组件装饰器 @Component","text":"类组件装饰器 @Component"}],"id":"#%E7%B1%BB%E7%BB%84%E4%BB%B6%E8%A3%85%E9%A5%B0%E5%99%A8-component"},{"type":"heading","raw":"### 自定义类组件 useClass \n\n","depth":3,"text":"自定义类组件 useClass","tokens":[{"type":"text","raw":"自定义类组件 useClass","text":"自定义类组件 useClass"}],"id":"#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%BB%84%E4%BB%B6-useclass"},{"type":"heading","raw":"### 依赖声明和注入 @Inject()\n\n","depth":3,"text":"依赖声明和注入 @Inject()","tokens":[{"type":"text","raw":"依赖声明和注入 @Inject()","text":"依赖声明和注入 @Inject()"}],"id":"#%E4%BE%9D%E8%B5%96%E5%A3%B0%E6%98%8E%E5%92%8C%E6%B3%A8%E5%85%A5-inject()","children":[{"type":"heading","raw":"#### 构造方法依赖注入\n\n","depth":4,"text":"构造方法依赖注入","tokens":[{"type":"text","raw":"构造方法依赖注入","text":"构造方法依赖注入"}],"id":"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"},{"type":"heading","raw":"#### 属性依赖注入\n\n","depth":4,"text":"属性依赖注入","tokens":[{"type":"text","raw":"属性依赖注入","text":"属性依赖注入"}],"id":"#%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"}]}]},{"type":"heading","raw":"## 值组件 useValue\n\n","depth":2,"text":"值组件 useValue","tokens":[{"type":"text","raw":"值组件 useValue","text":"值组件 useValue"}],"id":"#%E5%80%BC%E7%BB%84%E4%BB%B6-usevalue"},{"type":"heading","raw":"## 工厂组件 useFactory\n\n","depth":2,"text":"工厂组件 useFactory","tokens":[{"type":"text","raw":"工厂组件 useFactory","text":"工厂组件 useFactory"}],"id":"#%E5%B7%A5%E5%8E%82%E7%BB%84%E4%BB%B6-usefactory"},{"type":"heading","raw":"## 注册组件\n\n","depth":2,"text":"注册组件","tokens":[{"type":"text","raw":"注册组件","text":"注册组件"}],"id":"#%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"},{"type":"heading","raw":"## 获取组件值\n\n","depth":2,"text":"获取组件值","tokens":[{"type":"text","raw":"获取组件值","text":"获取组件值"}],"id":"#%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%80%BC"}]},{"title":"配置类","path":"/joy/container/configuration","file":"docs\\joy\\05-container\\configuration.md","hasMenu":false,"mdContent":"# 配置类\r\n\r\n## @Configuration 装饰器\r\n\r\n配置类用于配置组件，可将一个模块的多个组件统一放在一个配置类里配置，而后只需注册配置类到容器。我们也可以使用继承等方式，扩展和定制配置类。\r\n\r\n使用 `@Configuration()` 装饰器，将一个类声明为配置类，在配置类的属性或方法上，使用 `Configuration.Component(options: ComponentOptions)` 声明一个组件，组件名称如果未设置，将默认采用属性名或方法名。\r\n参照比上面 [组件](#组件) 章节中的例子，下面我们看看如何使用配置类配置组件：\r\n\r\n```ts\r\nimport { Configuration, Scope } from \"@symph/core\";\r\nimport { ConfigService } from \"@symph/config\";\r\n\r\n@Configuration()\r\nclass PostConfiguration {\r\n  constructor(private configService: ConfigService) {}\r\n\r\n  // 使用工厂方法定义组件\r\n  @Configuration.Component({ scope: Scope.SINGLETON })\r\n  public databaseConnection(): DatabaseConnection {\r\n    const dbOptions = this.configService.get(\"dbOptions\");\r\n    return new DatabaseConnection(dbOptions);\r\n  }\r\n\r\n  // 快捷声明类组件\r\n  @Configuration.Component()\r\n  public postsService: PostsService;\r\n\r\n  @Configuration.Component()\r\n  public postsController: PostsController;\r\n}\r\n\r\n// 注册组件和启动应用。\r\nasync function startApp() {\r\n  const app = await ServerFactory.create(PostConfiguration);\r\n  await app.listen(3000);\r\n}\r\nstartApp();\r\n```\r\n\r\n配置类在容器中，其本身也是一个类组件，可以轻松的使用其它组件，例上例中，`PostConfiguration` 依赖 ` configService`组件来获取数据库连接配置。\r\n","htmlContent":"\n                <h1 id=\"%E9%85%8D%E7%BD%AE%E7%B1%BB\">\n                  配置类\n                </h1>\n                <h2 id=\"configuration-%E8%A3%85%E9%A5%B0%E5%99%A8\">\n                  @Configuration 装饰器\n                </h2><p>配置类用于配置组件，可将一个模块的多个组件统一放在一个配置类里配置，而后只需注册配置类到容器。我们也可以使用继承等方式，扩展和定制配置类。</p>\n<p>使用 <code>@Configuration()</code> 装饰器，将一个类声明为配置类，在配置类的属性或方法上，使用 <code>Configuration.Component(options: ComponentOptions)</code> 声明一个组件，组件名称如果未设置，将默认采用属性名或方法名。\n参照比上面 <a href=\"#%E7%BB%84%E4%BB%B6\">组件</a> 章节中的例子，下面我们看看如何使用配置类配置组件：</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Configuration</span>, <span class=\"hljs-title class_\">Scope</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ConfigService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/config&quot;</span>;\n\n<span class=\"hljs-meta\">@Configuration</span>()\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PostConfiguration</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> configService: ConfigService</span>) {}\n\n  <span class=\"hljs-comment\">// 使用工厂方法定义组件</span>\n  <span class=\"hljs-meta\">@Configuration</span>.<span class=\"hljs-title class_\">Component</span>({ <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-title class_\">Scope</span>.<span class=\"hljs-property\">SINGLETON</span> })\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">databaseConnection</span>(): <span class=\"hljs-title class_\">DatabaseConnection</span> {\n    <span class=\"hljs-keyword\">const</span> dbOptions = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">configService</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;dbOptions&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DatabaseConnection</span>(dbOptions);\n  }\n\n  <span class=\"hljs-comment\">// 快捷声明类组件</span>\n  <span class=\"hljs-meta\">@Configuration</span>.<span class=\"hljs-title class_\">Component</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">postsService</span>: <span class=\"hljs-title class_\">PostsService</span>;\n\n  <span class=\"hljs-meta\">@Configuration</span>.<span class=\"hljs-title class_\">Component</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">postsController</span>: <span class=\"hljs-title class_\">PostsController</span>;\n}\n\n<span class=\"hljs-comment\">// 注册组件和启动应用。</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">startApp</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">ServerFactory</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">PostConfiguration</span>);\n  <span class=\"hljs-keyword\">await</span> app.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);\n}\n<span class=\"hljs-title function_\">startApp</span>();\n</code></pre>\n<p>配置类在容器中，其本身也是一个类组件，可以轻松的使用其它组件，例上例中，<code>PostConfiguration</code> 依赖 <code> configService</code>组件来获取数据库连接配置。</p>\n","anchor":[{"type":"heading","raw":"## @Configuration 装饰器\n\n","depth":2,"text":"@Configuration 装饰器","tokens":[{"type":"text","raw":"@Configuration 装饰器","text":"@Configuration 装饰器"}],"id":"#configuration-%E8%A3%85%E9%A5%B0%E5%99%A8"}]}]},{"title":"配置管理","path":"/joy/06-config","file":"docs/joy/06-config","children":[{"title":"配置管理","path":"/joy/config/config-manager","file":"docs\\joy\\06-config\\config-manager.md","hasMenu":false,"mdContent":"# 配置管理\r\n\r\nJoy 遵循约定大于配置原则，参考最佳实践约定默认配置，0 配置也可启动应用，即新应用无需配置文件也可立即运行和发布。\r\n\r\n## 配置文件\r\n\r\nJoy 在`joy.config.ts`或者`config/config.ts`中配置项目，支持 ts、js、json、es6 文件格式。例如：\r\n\r\n```typescript\r\n// joy.config.ts\r\n\r\nexport default {\r\n  basePath: \"\",\r\n  apiPrefix: \"/api\",\r\n  ssr: true,\r\n};\r\n```\r\n\r\n如果项目的配置不复杂，推荐在 `joy.config.ts` 中写配置; 如果项目的配置比较复杂，可以将配置写在 config/config.ts 中，并把配置的一部分拆分出去，加载配置时会自动合并到主配置中，例如路由配置可以拆分成单独的 routes.ts：\r\n\r\n```typescript\r\n// config/routes.ts\r\n\r\nexport default [{ exact: true, path: \"/\", component: \"index\" }];\r\n```\r\n\r\n等同于：\r\n\r\n```typescript\r\n// joy.config.ts\r\n{\r\n  apiPrefix: \"/api\";\r\n  routes: [{ exact: true, path: \"/\", component: \"index\" }];\r\n}\r\n```\r\n\r\n## 多环境配置\r\n\r\n可以通过环境变量`NODE_ENV`或者`JOY_ENV`来区分不同环境配置，`JOY_ENV`的优先级更高。各环境配置文件，统一放在`/config`目录中，例如：`/config/config.beta.ts`、`/config/config.production.ts`。\r\n\r\n各配置的加载顺序：`.env` ➡ `joy.config.ts` ➡ `config/config.ts` ➡ `config/config.production.ts` ， 后加载的配置会覆盖之前的配置。\r\n\r\n## 本地临时配置\r\n\r\n可以新建 `config/config.local.ts`文件，例如该配置文件存在，则加载顺序为：\r\n`.env` ➡ `joy.config.ts` ➡ `config/config.ts` ➡ `config/config.development.ts` ➡ `config/config.local.ts` 。\r\n\r\n**注意：**\r\n\r\n- 该配置优先级最高，在最后加载该配置文件，且会覆盖之前读取的配置。\r\n- `config.local.ts` 是本地开发调试的临时配置，请将其添加到 `.gitignore`，**务必不要提交到 git 仓库中**\r\n\r\n## 环境变量配置\r\n\r\n### 执行命令时添加环境变量\r\n\r\n例如：\r\n\r\n```bash\r\n# OS X、 Linux\r\n$ port=3000 joy dev\r\n\r\n# Windows\r\n$ set port=3000&&joy dev\r\n```\r\n\r\n如果要同时考虑 OS X 和 Windows，可借助三方工具 cross-env。\r\n\r\n```bash\r\n$ yarn add cross-env --dev\r\n$ cross-env port=3000 umi dev\r\n```\r\n\r\n### .env 配置文件\r\n\r\nJoy 约定根目录下的`.env`为环境变量配置文件，该配置文件将在初始化配置时加载，其配置的值于 [执行命令时添加环境变量](#执行命令时添加环境变量)\r\n\r\n```typescript\r\n// .env\r\n\r\nport = 3000;\r\nhostname = \"localhost\";\r\n```\r\n\r\n## 应用内获取配置\r\n\r\n### 通过 ConfigService 服务获取\r\n\r\n`@symph/config`提供 `ConfigService`服务类，Joy 已内置该服务，通过其提供的`get<T = any>(configPath?:string, defaultValue?: T): T | undefined`方法获取配置值，方法参数：\r\n\r\n- configPath: 配置键值，支持 object path，获取配置值对象的内部值。\r\n- defaultValue: 默认值，如果配置不存在，则返回默认值。\r\n\r\n例如有以下配置内容：\r\n\r\n```typescript\r\n// joy.config.ts\r\nexport default {\r\n  database: {\r\n    type: \"mysql\",\r\n    host: \"localhost\",\r\n    port: 3306,\r\n  },\r\n};\r\n```\r\n\r\n在服务类中获取以上配置值：\r\n\r\n```typescript\r\nimport { ConfigService } from \"@symph/config\";\r\n\r\nimport { Component } from \"@symph/core\";\r\nimport { Value } from \"@symph/config\";\r\n\r\n@Component()\r\nexport class HelloService {\r\n  constructor(private configService: ConfigService) {\r\n    // 通过 configKey 获取 配置\r\n    const database = configService.get(\"database\");\r\n\r\n    // 如果配置值是一个对象，可以通过object path，获取获取对象内部属性的值\r\n    const host = configService.get<string>(\"database.host\", \"localhost\");\r\n  }\r\n}\r\n```\r\n\r\n### @Value 装饰器方式获取\r\n\r\n在组件的属性上，通过`@Value(options)`装饰器申明需要自动注入配置，注入的属性键值默认为组件的属性名称，例如：\r\n\r\n```typescript\r\nimport { Component } from \"@symph/core\";\r\nimport { Value } from \"@symph/config\";\r\n\r\n@Component()\r\nexport class HelloService {\r\n  // 读取joy.config.ts中配置的msg的值。\r\n  @Value()\r\n  public msg: string;\r\n}\r\n```\r\n\r\n`@Value(options)` 定制参数列表：\r\n\r\n- **configKey** 类型`string`，默认等于被装饰的属性名称，指定注入是取的配置文件中的键值，由此属性名称和配置文件中的键值可以不相等。\r\n- **schema** 类型`json-schema`，自定义 [json-schema](https://json-schema.org/learn/getting-started-step-by-step) 定义属性规则，不推荐直接使用该属性，大部分情况下可使用`@tsed/schema`库提供的装饰器来申明校验规则，例如`@Max(3)`申明该配置的值不能大于 4，否则运行是抛出异常。\r\n\r\n[//]: # \"- **onChange** 类型`string`, 默认值`undefined`，设置当该值发生变化后，系统需如何处理，目前仅支持`reload`重新启动应用，或者为空不做任何操作。\"\r\n\r\n- **transform** 类型`(configValue: any) => any`, 注入值时被调用，入参为配置文件中的值，返回值为转换后的值，然后将转化后的值设置到属性上。\r\n\r\n> `@Value()`声明的属性，也等于声明了一个配置项及其类型和验证规则，需要避免在不同地方声明相同的配置但又不兼容的类型，这种情况下，我们可以将声明移动到一个独立的配置类中，其它地方如果需要使用该配置，应该依赖和使用该类。\r\n\r\n#### 校验配置值\r\n\r\n使用`@tsed/schema`库提供的装饰器来申明校验规则。\r\n\r\n```typescript\r\nimport { Component } from \"@symph/core\";\r\nimport { Max, MaxLength, Required } from \"@tsed/schema\";\r\nimport { Value } from \"@symph/config\";\r\n\r\n@Component()\r\nexport class BasicConfig {\r\n  // 配置类型为number，且不能大于4，否则运行时抛出异常。\r\n  // 如果未配置，默认为 2\r\n  @Value({ default: 2 })\r\n  @Max(4)\r\n  public workers: number;\r\n\r\n  // 必须配置，且长度不能大于64.\r\n  @Value()\r\n  @MaxLength(64)\r\n  @Required()\r\n  public msg: string;\r\n\r\n  // 配置是一个负责对象数组，类型和验证规则声明在对象的类上。\r\n  @Value()\r\n  public routes: ReactRoute[];\r\n}\r\n\r\nclass ReactRoute {\r\n  @Required()\r\n  public path: string;\r\n\r\n  public extract: boolean;\r\n}\r\n```\r\n","htmlContent":"\n                <h1 id=\"%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\">\n                  配置管理\n                </h1><p>Joy 遵循约定大于配置原则，参考最佳实践约定默认配置，0 配置也可启动应用，即新应用无需配置文件也可立即运行和发布。</p>\n\n                <h2 id=\"%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">\n                  配置文件\n                </h2><p>Joy 在<code>joy.config.ts</code>或者<code>config/config.ts</code>中配置项目，支持 ts、js、json、es6 文件格式。例如：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// joy.config.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">basePath</span>: <span class=\"hljs-string\">&quot;&quot;</span>,\n  <span class=\"hljs-attr\">apiPrefix</span>: <span class=\"hljs-string\">&quot;/api&quot;</span>,\n  <span class=\"hljs-attr\">ssr</span>: <span class=\"hljs-literal\">true</span>,\n};\n</code></pre>\n<p>如果项目的配置不复杂，推荐在 <code>joy.config.ts</code> 中写配置; 如果项目的配置比较复杂，可以将配置写在 config/config.ts 中，并把配置的一部分拆分出去，加载配置时会自动合并到主配置中，例如路由配置可以拆分成单独的 routes.ts：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// config/routes.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> [{ <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-string\">&quot;index&quot;</span> }];\n</code></pre>\n<p>等同于：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// joy.config.ts</span>\n{\n  <span class=\"hljs-attr\">apiPrefix</span>: <span class=\"hljs-string\">&quot;/api&quot;</span>;\n  <span class=\"hljs-attr\">routes</span>: [{ <span class=\"hljs-attr\">exact</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-attr\">component</span>: <span class=\"hljs-string\">&quot;index&quot;</span> }];\n}\n</code></pre>\n\n                <h2 id=\"%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE\">\n                  多环境配置\n                </h2><p>可以通过环境变量<code>NODE_ENV</code>或者<code>JOY_ENV</code>来区分不同环境配置，<code>JOY_ENV</code>的优先级更高。各环境配置文件，统一放在<code>/config</code>目录中，例如：<code>/config/config.beta.ts</code>、<code>/config/config.production.ts</code>。</p>\n<p>各配置的加载顺序：<code>.env</code> ➡ <code>joy.config.ts</code> ➡ <code>config/config.ts</code> ➡ <code>config/config.production.ts</code> ， 后加载的配置会覆盖之前的配置。</p>\n\n                <h2 id=\"%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E9%85%8D%E7%BD%AE\">\n                  本地临时配置\n                </h2><p>可以新建 <code>config/config.local.ts</code>文件，例如该配置文件存在，则加载顺序为：\n<code>.env</code> ➡ <code>joy.config.ts</code> ➡ <code>config/config.ts</code> ➡ <code>config/config.development.ts</code> ➡ <code>config/config.local.ts</code> 。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>该配置优先级最高，在最后加载该配置文件，且会覆盖之前读取的配置。</li>\n<li><code>config.local.ts</code> 是本地开发调试的临时配置，请将其添加到 <code>.gitignore</code>，<strong>务必不要提交到 git 仓库中</strong></li>\n</ul>\n\n                <h2 id=\"%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE\">\n                  环境变量配置\n                </h2>\n                <h3 id=\"%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">\n                  执行命令时添加环境变量\n                </h3><p>例如：</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># OS X、 Linux</span>\n$ port=3000 joy dev\n\n<span class=\"hljs-comment\"># Windows</span>\n$ <span class=\"hljs-built_in\">set</span> port=3000&amp;&amp;joy dev\n</code></pre>\n<p>如果要同时考虑 OS X 和 Windows，可借助三方工具 cross-env。</p>\n<pre><code class=\"hljs language-bash\">$ yarn add cross-env --dev\n$ cross-env port=3000 umi dev\n</code></pre>\n\n                <h3 id=\"env-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">\n                  .env 配置文件\n                </h3><p>Joy 约定根目录下的<code>.env</code>为环境变量配置文件，该配置文件将在初始化配置时加载，其配置的值于 <a href=\"#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">执行命令时添加环境变量</a></p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// .env</span>\n\nport = <span class=\"hljs-number\">3000</span>;\nhostname = <span class=\"hljs-string\">&quot;localhost&quot;</span>;\n</code></pre>\n\n                <h2 id=\"%E5%BA%94%E7%94%A8%E5%86%85%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE\">\n                  应用内获取配置\n                </h2>\n                <h3 id=\"%E9%80%9A%E8%BF%87-configservice-%E6%9C%8D%E5%8A%A1%E8%8E%B7%E5%8F%96\">\n                  通过 ConfigService 服务获取\n                </h3><p><code>@symph/config</code>提供 <code>ConfigService</code>服务类，Joy 已内置该服务，通过其提供的<code>get&lt;T = any&gt;(configPath?:string, defaultValue?: T): T | undefined</code>方法获取配置值，方法参数：</p>\n<ul>\n<li>configPath: 配置键值，支持 object path，获取配置值对象的内部值。</li>\n<li>defaultValue: 默认值，如果配置不存在，则返回默认值。</li>\n</ul>\n<p>例如有以下配置内容：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// joy.config.ts</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">database</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&quot;mysql&quot;</span>,\n    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&quot;localhost&quot;</span>,\n    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3306</span>,\n  },\n};\n</code></pre>\n<p>在服务类中获取以上配置值：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ConfigService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/config&quot;</span>;\n\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Value</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/config&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloService</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> configService: ConfigService</span>) {\n    <span class=\"hljs-comment\">// 通过 configKey 获取 配置</span>\n    <span class=\"hljs-keyword\">const</span> database = configService.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&quot;database&quot;</span>);\n\n    <span class=\"hljs-comment\">// 如果配置值是一个对象，可以通过object path，获取获取对象内部属性的值</span>\n    <span class=\"hljs-keyword\">const</span> host = configService.<span class=\"hljs-property\">get</span>&lt;<span class=\"hljs-built_in\">string</span>&gt;(<span class=\"hljs-string\">&quot;database.host&quot;</span>, <span class=\"hljs-string\">&quot;localhost&quot;</span>);\n  }\n}\n</code></pre>\n\n                <h3 id=\"value-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96\">\n                  @Value 装饰器方式获取\n                </h3><p>在组件的属性上，通过<code>@Value(options)</code>装饰器申明需要自动注入配置，注入的属性键值默认为组件的属性名称，例如：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Value</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/config&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloService</span> {\n  <span class=\"hljs-comment\">// 读取joy.config.ts中配置的msg的值。</span>\n  <span class=\"hljs-meta\">@Value</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n<p><code>@Value(options)</code> 定制参数列表：</p>\n<ul>\n<li><strong>configKey</strong> 类型<code>string</code>，默认等于被装饰的属性名称，指定注入是取的配置文件中的键值，由此属性名称和配置文件中的键值可以不相等。</li>\n<li><strong>schema</strong> 类型<code>json-schema</code>，自定义 <a href=\"https://json-schema.org/learn/getting-started-step-by-step\">json-schema</a> 定义属性规则，不推荐直接使用该属性，大部分情况下可使用<code>@tsed/schema</code>库提供的装饰器来申明校验规则，例如<code>@Max(3)</code>申明该配置的值不能大于 4，否则运行是抛出异常。</li>\n</ul>\n<ul>\n<li><strong>transform</strong> 类型<code>(configValue: any) =&gt; any</code>, 注入值时被调用，入参为配置文件中的值，返回值为转换后的值，然后将转化后的值设置到属性上。</li>\n</ul>\n<blockquote>\n<p><code>@Value()</code>声明的属性，也等于声明了一个配置项及其类型和验证规则，需要避免在不同地方声明相同的配置但又不兼容的类型，这种情况下，我们可以将声明移动到一个独立的配置类中，其它地方如果需要使用该配置，应该依赖和使用该类。</p>\n</blockquote>\n\n                <h4 id=\"%E6%A0%A1%E9%AA%8C%E9%85%8D%E7%BD%AE%E5%80%BC\">\n                  校验配置值\n                </h4><p>使用<code>@tsed/schema</code>库提供的装饰器来申明校验规则。</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/core&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Max</span>, <span class=\"hljs-title class_\">MaxLength</span>, <span class=\"hljs-title class_\">Required</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@tsed/schema&quot;</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Value</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;@symph/config&quot;</span>;\n\n<span class=\"hljs-meta\">@Component</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasicConfig</span> {\n  <span class=\"hljs-comment\">// 配置类型为number，且不能大于4，否则运行时抛出异常。</span>\n  <span class=\"hljs-comment\">// 如果未配置，默认为 2</span>\n  <span class=\"hljs-meta\">@Value</span>({ <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">2</span> })\n  <span class=\"hljs-meta\">@Max</span>(<span class=\"hljs-number\">4</span>)\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">workers</span>: <span class=\"hljs-built_in\">number</span>;\n\n  <span class=\"hljs-comment\">// 必须配置，且长度不能大于64.</span>\n  <span class=\"hljs-meta\">@Value</span>()\n  <span class=\"hljs-meta\">@MaxLength</span>(<span class=\"hljs-number\">64</span>)\n  <span class=\"hljs-meta\">@Required</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-comment\">// 配置是一个负责对象数组，类型和验证规则声明在对象的类上。</span>\n  <span class=\"hljs-meta\">@Value</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">routes</span>: <span class=\"hljs-title class_\">ReactRoute</span>[];\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ReactRoute</span> {\n  <span class=\"hljs-meta\">@Required</span>()\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\">string</span>;\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-attr\">extract</span>: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n","anchor":[{"type":"heading","raw":"## 配置文件\n\n","depth":2,"text":"配置文件","tokens":[{"type":"text","raw":"配置文件","text":"配置文件"}],"id":"#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"},{"type":"heading","raw":"## 多环境配置\n\n","depth":2,"text":"多环境配置","tokens":[{"type":"text","raw":"多环境配置","text":"多环境配置"}],"id":"#%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"},{"type":"heading","raw":"## 本地临时配置\n\n","depth":2,"text":"本地临时配置","tokens":[{"type":"text","raw":"本地临时配置","text":"本地临时配置"}],"id":"#%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E9%85%8D%E7%BD%AE"},{"type":"heading","raw":"## 环境变量配置\n\n","depth":2,"text":"环境变量配置","tokens":[{"type":"text","raw":"环境变量配置","text":"环境变量配置"}],"id":"#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE","children":[{"type":"heading","raw":"### 执行命令时添加环境变量\n\n","depth":3,"text":"执行命令时添加环境变量","tokens":[{"type":"text","raw":"执行命令时添加环境变量","text":"执行命令时添加环境变量"}],"id":"#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"},{"type":"heading","raw":"### .env 配置文件\n\n","depth":3,"text":".env 配置文件","tokens":[{"type":"text","raw":".env 配置文件","text":".env 配置文件"}],"id":"#env-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"}]},{"type":"heading","raw":"## 应用内获取配置\n\n","depth":2,"text":"应用内获取配置","tokens":[{"type":"text","raw":"应用内获取配置","text":"应用内获取配置"}],"id":"#%E5%BA%94%E7%94%A8%E5%86%85%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE","children":[{"type":"heading","raw":"### 通过 ConfigService 服务获取\n\n","depth":3,"text":"通过 ConfigService 服务获取","tokens":[{"type":"text","raw":"通过 ConfigService 服务获取","text":"通过 ConfigService 服务获取"}],"id":"#%E9%80%9A%E8%BF%87-configservice-%E6%9C%8D%E5%8A%A1%E8%8E%B7%E5%8F%96"},{"type":"heading","raw":"### @Value 装饰器方式获取\n\n","depth":3,"text":"@Value 装饰器方式获取","tokens":[{"type":"text","raw":"@Value 装饰器方式获取","text":"@Value 装饰器方式获取"}],"id":"#value-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%8F%96","children":[{"type":"heading","raw":"#### 校验配置值\n\n","depth":4,"text":"校验配置值","tokens":[{"type":"text","raw":"校验配置值","text":"校验配置值"}],"id":"#%E6%A0%A1%E9%AA%8C%E9%85%8D%E7%BD%AE%E5%80%BC"}]}]}]},{"title":"Joy 应用配置","path":"/joy/config/joy-config","file":"docs\\joy\\06-config\\joy-config.md","hasMenu":false,"mdContent":"# Joy 应用配置\r\n\r\n## basePath\r\n\r\n类型：`string` 默认值：`\"\"`\r\n\r\n发布 Joy 应用到子路径下时，使用`basePath`设置子路径名称。 例如我们开发了一个文档应用，现将它发布到`/docs`子路径下，例如`www.mydomian.com/docs`。\r\n\r\n```typescript\r\n// config/config.production.ts\r\n// 只配置 production 环境\r\nexport default {\r\n  basePath: \"/docs\",\r\n};\r\n```\r\n\r\n> 注意：该配置值在构建编译时设置，会打包到客户端的运行包中，如果修改该值，需要重新编译。\r\n\r\n## assetPrefix\r\n\r\n类型：string，默认:`\"\"`\r\n\r\n在浏览器上运行时，加载应用资源的路径前缀。一般是在生产环境，将打包好的静态资源部署到不同的服务器（CDN，静态文件服务器）上时配置该值，而开发调试环境无需配置。 例如图片默认路径是`${basePath}/static/logo.png`，假如我们将资源部署到 CDN 上，图片的加载路径变为 CDN 的地址`https://cdn.mydomain.com/myapp/static/logo.png` ,此时我们更改`assetPrefix`为 CDN 的地址：\r\n\r\n```typescript\r\n// config/config.production.ts\r\n\r\nexport default {\r\n  assetPrefix: \"https://cdn.mydomain.com/myapp\",\r\n};\r\n```\r\n\r\n## distDir\r\n\r\n类型：`string`，默认: `\".joy\"`\r\n\r\n编译阶段输出的临时目录，你也可以设置自定义的目录名称。\r\n","htmlContent":"\n                <h1 id=\"joy-%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE\">\n                  Joy 应用配置\n                </h1>\n                <h2 id=\"basepath\">\n                  basePath\n                </h2><p>类型：<code>string</code> 默认值：<code>&quot;&quot;</code></p>\n<p>发布 Joy 应用到子路径下时，使用<code>basePath</code>设置子路径名称。 例如我们开发了一个文档应用，现将它发布到<code>/docs</code>子路径下，例如<code>www.mydomian.com/docs</code>。</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// config/config.production.ts</span>\n<span class=\"hljs-comment\">// 只配置 production 环境</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">basePath</span>: <span class=\"hljs-string\">&quot;/docs&quot;</span>,\n};\n</code></pre>\n<blockquote>\n<p>注意：该配置值在构建编译时设置，会打包到客户端的运行包中，如果修改该值，需要重新编译。</p>\n</blockquote>\n\n                <h2 id=\"assetprefix\">\n                  assetPrefix\n                </h2><p>类型：string，默认:<code>&quot;&quot;</code></p>\n<p>在浏览器上运行时，加载应用资源的路径前缀。一般是在生产环境，将打包好的静态资源部署到不同的服务器（CDN，静态文件服务器）上时配置该值，而开发调试环境无需配置。 例如图片默认路径是<code>${basePath}/static/logo.png</code>，假如我们将资源部署到 CDN 上，图片的加载路径变为 CDN 的地址<code>https://cdn.mydomain.com/myapp/static/logo.png</code> ,此时我们更改<code>assetPrefix</code>为 CDN 的地址：</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// config/config.production.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">assetPrefix</span>: <span class=\"hljs-string\">&quot;https://cdn.mydomain.com/myapp&quot;</span>,\n};\n</code></pre>\n\n                <h2 id=\"distdir\">\n                  distDir\n                </h2><p>类型：<code>string</code>，默认: <code>&quot;.joy&quot;</code></p>\n<p>编译阶段输出的临时目录，你也可以设置自定义的目录名称。</p>\n","anchor":[{"type":"heading","raw":"## basePath\n\n","depth":2,"text":"basePath","tokens":[{"type":"text","raw":"basePath","text":"basePath"}],"id":"#basepath"},{"type":"heading","raw":"## assetPrefix\n\n","depth":2,"text":"assetPrefix","tokens":[{"type":"text","raw":"assetPrefix","text":"assetPrefix"}],"id":"#assetprefix"},{"type":"heading","raw":"## distDir\n\n","depth":2,"text":"distDir","tokens":[{"type":"text","raw":"distDir","text":"distDir"}],"id":"#distdir"}]}]}],"defaultOpenKeys":["/joy/01-start","/joy/02-react","/joy/03-server","/joy/04-advanced-use","/joy/05-container","/joy/06-config"]}},{"type":"reactAppInitManager/__SET_STATE","state":{"/joy":{"pathname":"/joy","index":false,"initStatic":2}}}]},{"pathname":"/joy/react/export","ssgData":[{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadingCurrentDoc":true}},{"type":"docsModel/__SET_STATE","state":{"loadCurrentDocErr":null,"currentDoc":{"title":"导出 React","path":"/joy/react/export","file":"docs\\joy\\02-react\\22-export.md","hasMenu":false,"mdContent":"# 导出 React\r\n\r\n运行命令：\r\n```shell\r\n$ joy build && joy export \r\n```\r\n\r\n构建产物默认生成到 ./out 下，目录结构类似于：\r\n\r\n```shell\r\n./out\r\n  index.html\r\n  404.html\r\n  _joy/ # 包含js、css、json等\r\n```\r\n\r\n## 本地验证\r\n\r\n使用`http-server`启动本地静态文件服务器\r\n\r\n```shell\r\n# 安装 http-server\r\n$ npm i -g http-server\r\n\r\n# 启动服务器\r\n$ http-server ./out\r\n```\r\n\r\n在浏览器上打开地址：[http://127.0.0.1:8080](http://127.0.0.1:8080), 正常情况下应该是和`yarn dev`开发运行时是一致的。\r\n\r\n## 部署\r\n\r\n本地验证完成后，将`out`目录部署到服务器上即可。\r\n\r\n","htmlContent":"\n                <h1 id=\"%E5%AF%BC%E5%87%BA-react\">\n                  导出 React\n                </h1><p>运行命令：</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">joy build &amp;&amp; joy <span class=\"hljs-built_in\">export</span></span> \n</code></pre>\n<p>构建产物默认生成到 ./out 下，目录结构类似于：</p>\n<pre><code class=\"hljs language-shell\">./out\n  index.html\n  404.html\n  _joy/ # 包含js、css、json等\n</code></pre>\n\n                <h2 id=\"%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81\">\n                  本地验证\n                </h2><p>使用<code>http-server</code>启动本地静态文件服务器</p>\n<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">安装 http-server</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">npm i -g http-server</span>\n<span class=\"hljs-meta prompt_\">\n# </span><span class=\"language-bash\">启动服务器</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">http-server ./out</span>\n</code></pre>\n<p>在浏览器上打开地址：<a href=\"http://127.0.0.1:8080\">http://127.0.0.1:8080</a>, 正常情况下应该是和<code>yarn dev</code>开发运行时是一致的。</p>\n\n                <h2 id=\"%E9%83%A8%E7%BD%B2\">\n                  部署\n                </h2><p>本地验证完成后，将<code>out</code>目录部署到服务器上即可。</p>\n","anchor":[{"type":"heading","raw":"## 本地验证\n\n","depth":2,"text":"本地验证","tokens":[{"type":"text","raw":"本地验证","text":"本地验证"}],"id":"#%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81"},{"type":"heading","raw":"## 部署\n\n","depth":2,"text":"部署","tokens":[{"type":"text","raw":"部署","text":"部署"}],"id":"#%E9%83%A8%E7%BD%B2"}]},"titleTrees":[{"type":"heading","raw":"## 本地验证\n\n","depth":2,"text":"本地验证","tokens":[{"type":"text","raw":"本地验证","text":"本地验证"}],"id":"#%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81"},{"type":"heading","raw":"## 部署\n\n","depth":2,"text":"部署","tokens":[{"type":"text","raw":"部署","text":"部署"}],"id":"#%E9%83%A8%E7%BD%B2"}],"loadingCurrentDoc":false}},{"type":"reactAppInitManager/__SET_STATE","state":{"/joy/react/export":{"pathname":"/joy/react/export","index":false,"initStatic":2}}}]}]