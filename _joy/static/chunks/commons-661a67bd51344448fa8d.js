(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([[351],{

/***/ 15198:
/***/ (function(module) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 66132:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _typeof = (__webpack_require__(58921)["default"]);

function _regeneratorRuntime() {
  "use strict";
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) {
            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
          }

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      }
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 58921:
/***/ (function(module) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 77162:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(66132)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 92267:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

__webpack_require__(1738);
var path = __webpack_require__(21023);

function catchError(cb) {
  try {
    cb();
  } catch (er) {
    return er;
  }
}
async function catchAsyncError(cb) {
  try {
    await cb();
  } catch (er) {
    return er;
  }
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

/**
 * Create a complete and iterable trap.
 * @param self
 * @param options
 * @ignore
 */
function proxyDelegation(self, options = {}) {
  const {
    handlers = {},
    remove,
    ownKeys
  } = options;

  const get = options.getter || ((target, propertyKey) => target.get(propertyKey));

  const set = options.setter || ((target, propertyKey, value) => !!target.set(propertyKey, value));

  const itsOwnProp = (target, p) => Reflect.has(target, p) || typeof p === "symbol";

  return new Proxy(self, _extends({
    getOwnPropertyDescriptor(target, p) {
      return Reflect.getOwnPropertyDescriptor(target, p);
    },

    has(target, p) {
      if (itsOwnProp(target, p)) {
        return Reflect.has(target, p);
      }

      return get(target, p) !== undefined;
    },

    get(target, p, receiver) {
      if (itsOwnProp(target, p)) {
        return Reflect.get(target, p, receiver);
      }

      return get(target, p);
    },

    set(target, p, value, receiver) {
      if (itsOwnProp(target, p)) {
        return Reflect.set(target, p, value, receiver);
      }

      return !!set(target, p, value, receiver);
    },

    deleteProperty(target, p) {
      if (itsOwnProp(target, p) || !remove) {
        return Reflect.deleteProperty(target, p);
      }

      return remove(target, p);
    },

    defineProperty(target, p, attributes) {
      return Reflect.defineProperty(target, p, attributes);
    },

    ownKeys(target) {
      return Reflect.ownKeys(target).concat(ownKeys && ownKeys(target) || []);
    }

  }, handlers));
}

function uniq(list) {
  return Array.from(new Set(list).values());
}
function uniqBy(list, key = "id") {
  const map = new Map();
  list.forEach(item => {
    map.set(item[key], item);
  });
  return Array.from(map.values());
}

/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 */
function getClass(target) {
  return target.prototype ? target : target.constructor;
}
/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 * @alias getClass
 */

function classOf(target) {
  return getClass(target);
}

function getInheritedClass(target) {
  return Object.getPrototypeOf(target);
}

/**
 * Get the provide name.
 * @param targetClass
 */
function nameOfClass(targetClass) {
  return typeof targetClass === "function" ? targetClass.name : targetClass.constructor.name;
}
/**
 * Get symbol name.
 * @param sym
 */

const nameOfSymbol = sym => sym.toString().replace("Symbol(", "").replace(")", "");
/**
 * Get object name
 */

function nameOf(obj) {
  switch (typeof obj) {
    default:
      return "" + obj;

    case "symbol":
      return nameOfSymbol(obj);

    case "function":
      return nameOfClass(obj);
  }
}

/**
 *
 * @param target
 * @returns {Array}
 */

function ancestorsOf(target) {
  const classes = [];
  let currentTarget = classOf(target);

  while (nameOf(currentTarget) !== "") {
    classes.unshift(currentTarget);
    currentTarget = getInheritedClass(currentTarget);
  }

  return classes;
}

/**
 * Return the prototype of the given class.
 * @param target
 * @returns {any}
 */

function prototypeOf(target) {
  return classOf(target) === target ? target.prototype : target;
}

/**
 * Return all methods for a given class.
 * @param target
 */

function methodsOf(target) {
  const methods = new Map();
  target = classOf(target);
  ancestorsOf(target).forEach(target => {
    const keys = Reflect.ownKeys(prototypeOf(target));
    keys.forEach(propertyKey => {
      if (propertyKey !== "constructor") {
        methods.set(propertyKey, {
          target,
          propertyKey
        });
      }
    });
  });
  return Array.from(methods.values());
}

/**
 * Return the descriptor for a given class and propertyKey
 * @param target
 * @param {string} propertyKey
 * @returns {PropertyDescriptor}
 */
function descriptorOf(target, propertyKey) {
  return Object.getOwnPropertyDescriptor(target && target.prototype || target, propertyKey);
}

function decorateMethodsOf(klass, decorator) {
  methodsOf(klass).forEach(({
    target,
    propertyKey
  }) => {
    if (target !== classOf(klass)) {
      Object.defineProperty(prototypeOf(klass), propertyKey, {
        value(...args) {
          return prototypeOf(target)[propertyKey].apply(this, args);
        }

      });
    }

    decorator(prototypeOf(klass), propertyKey, descriptorOf(klass, propertyKey));
  });
}

function decoratorArgs(target, propertyKey) {
  return [target, propertyKey, descriptorOf(target, propertyKey)];
}

exports.DecoratorTypes = void 0;

(function (DecoratorTypes) {
  DecoratorTypes["PARAM"] = "parameter";
  DecoratorTypes["PARAM_CTOR"] = "parameter.constructor";
  DecoratorTypes["PARAM_STC"] = "parameter.static";
  DecoratorTypes["PROP"] = "property";
  DecoratorTypes["PROP_STC"] = "property.static";
  DecoratorTypes["METHOD"] = "method";
  DecoratorTypes["METHOD_STC"] = "method.static";
  DecoratorTypes["CLASS"] = "class";
})(exports.DecoratorTypes || (exports.DecoratorTypes = {}));

function decoratorTypeOf(args) {
  const [target, propertyKey, descriptor] = args;

  const staticType = type => {
    return target !== classOf(target) ? type : `${type}.static`;
  };

  if (typeof descriptor === "number") {
    return propertyKey ? staticType("parameter") : "parameter.constructor";
  }

  if (descriptor && descriptor.value) {
    return staticType("method");
  }

  if (propertyKey && descriptor === undefined || descriptor) {
    return staticType("property");
  }

  return exports.DecoratorTypes.CLASS;
}

function inheritedDescriptorOf(target, propertyKey) {
  for (const klass of ancestorsOf(target)) {
    const descriptor = Object.getOwnPropertyDescriptor(klass && klass.prototype || klass, propertyKey);

    if (descriptor) {
      return descriptor;
    }
  }

  return undefined;
}

function useDecorators(...decorators) {
  return (...args) => {
    decorators.filter(o => !!o).forEach(decorator => {
      decorator(...args);
    });
  };
}

function useMethodDecorator(decorator) {
  return (target, propertyKey) => decorator(target, propertyKey, descriptorOf(target, propertyKey));
}
function useMethodDecorators(...decorators) {
  return (target, propertyKey) => {
    decorators.filter(Boolean).forEach(decorator => decorator(target, propertyKey, descriptorOf(target, propertyKey)));
  };
}

/**
 * Prevent prototype pollution vulnerability
 * @param key
 */
function isProtectedKey(key) {
  return ["__proto__", "constructor", "prototype"].includes(key);
}

/**
 * Remove undefined value
 * @param obj
 * @param ignore
 */

function cleanObject(obj, ignore = []) {
  return Object.entries(obj).reduce((obj, [key, value]) => {
    if (isProtectedKey(key) || ignore.includes(key)) {
      return obj;
    }

    return value === undefined ? obj : _extends({}, obj, {
      [key]: value
    });
  }, {});
}

/**
 * Get the class constructor
 * @param target
 */
function getConstructor(target) {
  return typeof target === "function" ? target : target.constructor;
}
/**
 * Get the class constructor
 * @param target
 */

function constructorOf(target) {
  return getConstructor(target);
}

/**
 * Return true if value is an array
 * @param target
 * @returns {boolean}
 */
function isArray(target) {
  return Array.isArray(target);
}
/**
 * Return true if the clazz is an array.
 * @param target
 * @returns {boolean}
 * @ignore
 */

function isArrayOrArrayClass(target) {
  return target === Array || isArray(target);
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isDate(target) {
  return target === Date || target instanceof Date && !isNaN(+target);
}

function isFunction(target) {
  return typeof target === "function";
}

function isNil(value) {
  return value === undefined || value === null;
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isBoolean(target) {
  return typeof target === "boolean" || target instanceof Boolean || target === Boolean;
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isNumber(target) {
  return typeof target === "number" || target instanceof Number || target === Number;
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isString(target) {
  return typeof target === "string" || target instanceof String || target === String;
}

/**
 * Return true if the given obj is a primitive.
 * @param target
 * @returns {boolean}
 * @ignore
 */

function isPrimitiveOrPrimitiveClass(target) {
  return isString(target) || isNumber(target) || isBoolean(target);
}
/**
 * Return true if the given obj is a primitive.
 * @param target
 * @returns {boolean}
 */

function isPrimitive(target) {
  return isPrimitiveOrPrimitiveClass(target);
}
function isPrimitiveClass(target) {
  return [String, Number, Boolean].includes(target);
}

/**
 *
 * @param target
 */
function isSymbol(target) {
  return typeof target === "symbol" || target instanceof Symbol || target === Symbol;
}

const isBasicType = source => isNil(source) || isPrimitive(source) || isSymbol(source) || isFunction(source);
/**
 * Return a cloned value
 * @param source
 */


function deepClone(source) {
  let dest;

  if (isBasicType(source)) {
    return source;
  }

  if (isDate(source)) {
    return new Date(source);
  }

  dest = isArrayOrArrayClass(source) ? [] : {};

  for (const key in source) {
    // Use getOwnPropertyDescriptor instead of source[key] to prevent from triggering setter/getter.
    const descriptor = Object.getOwnPropertyDescriptor(source, key);

    if (descriptor) {
      if (!isFunction(descriptor.value)) {
        dest[key] = deepClone(descriptor.value);
      } else {
        Object.defineProperty(dest, key, descriptor);
      }
    }
  }

  if (!isArrayOrArrayClass(source)) {
    const prototype = Reflect.getPrototypeOf(source);
    Reflect.setPrototypeOf(dest, prototype);
  }

  return dest;
}

function createInstance(obj) {
  return obj ? classOf(obj) !== Object ? Object.create(obj) : {} : {};
}

function objectKeys(obj) {
  return Object.keys(obj).filter(key => !isProtectedKey(key));
}

function reducer() {
  return (collection, value) => {
    collection.indexOf(value) === -1 && collection.push(value);
    return collection;
  };
}
/**
 * Deep extends a model with another one.
 * @param out
 * @param obj
 * @param reducers
 * @returns {any}
 * @deprecated Since 2021-07-16. Use deepMerge instead of
 */


function deepExtends(out, obj, reducers = {}) {
  if (obj === undefined || obj === null) {
    return out;
  }

  if (isPrimitive(obj) || typeof obj === "symbol" || typeof obj === "function") {
    return obj;
  }

  if (isArrayOrArrayClass(obj)) {
    out = out || [];
  } else {
    out = out || createInstance(obj);
  }

  const defaultReducer = reducers["default"] ? reducers["default"] : reducer();

  const set = (key, value) => {
    if (isArrayOrArrayClass(obj)) {
      out.indexOf(value) === -1 && out.push(value);
    } else {
      out[key] = value;
    }
  };

  objectKeys(obj).forEach(key => {
    let value = obj[key]; // istanbul ignore next

    if (value === undefined || value === null) {
      return;
    } // istanbul ignore next


    if (value === "" && out[key] !== "") {
      return;
    }

    if (isPrimitive(value) || typeof value === "function") {
      set(key, value);
      return;
    }

    if (isArrayOrArrayClass(value)) {
      value = value.map(value => deepExtends(undefined, value));
      set(key, [].concat(out[key] || [], value).reduce((collection, value) => reducers[key] ? reducers[key](collection, value) : defaultReducer(collection, value), []));
      return;
    } // Object


    if (isArrayOrArrayClass(obj)) {
      set(key, deepExtends(undefined, value, reducers));
    } else {
      set(key, deepExtends(out[key], value, reducers));
    }
  });

  if (isArrayOrArrayClass(out)) {
    out.reduce((collection, value) => defaultReducer(collection, value), []);
  }

  return out;
}

function mergeReducerBuilder(cb) {
  return (collection, value, options) => {
    const index = collection.findIndex(item => cb(item, value));

    if (index === -1) {
      return [...collection, value];
    }

    collection[index] = deepMerge(collection[index], value, options);
    return collection;
  };
}
const defaultReducer = mergeReducerBuilder((a, b) => a === b);

function getReducer(options) {
  if (!options.reducers) {
    return defaultReducer;
  }

  if (options.parentKey && options.reducers[options.parentKey]) {
    return options.reducers[options.parentKey];
  }

  return options.reducers["default"] || defaultReducer;
}

function deepMerge(source, obj, options = {}) {
  if (obj === undefined || obj === null || obj === "" && source !== "") {
    return source;
  }

  if (isPrimitive(obj) || isSymbol(obj) || isFunction(obj) || source === undefined) {
    return obj;
  }

  if (isArray(source)) {
    const reducer = getReducer(options);
    const collection = [...source];
    return [].concat(obj).reduce((out, value) => {
      return reducer([...out], value, _extends({}, options));
    }, collection);
  }

  return [...objectKeys(source), ...objectKeys(obj)].reduce((out, key) => {
    const src = source && source[key];
    const value = obj && obj[key];
    return _extends({}, out, {
      [key]: deepMerge(src, value, _extends({}, options, {
        parentKey: key
      }))
    });
  }, createInstance(source));
}

function isArrowFn(target) {
  return target && isFunction(target) && !target.prototype;
}

/**
 *
 * @param target
 * @returns {boolean}
 */

function isClassObject(target) {
  return target === Object;
}
function isPlainObject(target) {
  return isClassObject(classOf(target));
}

/**
 * Tests to see if the object is an ES2015 (ES6) Promise
 * @see {@link https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects}
 * @param target
 * @returns {boolean}
 */
function isPromise(target) {
  return target === Promise || target instanceof Promise || !!target && typeof target.subscribe !== "function" && typeof target.then === "function";
}

function isClass(target) {
  if (!target) {
    return false;
  }

  if (isArrowFn(target)) {
    return false;
  }

  return !(isSymbol(target) || isPrimitiveOrPrimitiveClass(target) || isClassObject(target) || isDate(target) || isPromise(target) || isArrayOrArrayClass(target));
}

function getClassOrSymbol(target) {
  return isClass(target) ? classOf(target) : target;
}

function toStringConstructor(target) {
  const ctr = constructorOf(target);
  const strings = ctr.toString().split("\n");
  const ctrString = strings.find(s => s.indexOf("constructor(") > -1) || "constructor()";
  return `${ctrString.replace("{", "").trim()}`;
}

function getConstructorArgNames(target) {
  return toStringConstructor(target).replace("constructor(", "").replace(")", "").split(", ").filter(Boolean);
}

/**
 *
 * @param obj
 * @param key
 */

function isEnumerable(obj, key) {
  const klass = classOf(obj);

  if (klass) {
    const descriptor = inheritedDescriptorOf(klass, key);

    if (descriptor) {
      return descriptor.enumerable;
    }
  }

  return Object.prototype.propertyIsEnumerable.call(obj, key);
}

/**
 * Return all enumerable keys of the given object
 * @param obj
 */

function getEnumerableKeys(obj) {
  const keys = [];

  for (const key in obj) {
    if (!isProtectedKey(key) && isEnumerable(obj, key)) {
      keys.push(key);
    }
  }

  return keys;
}

function isObject(target) {
  return typeof target === "object";
}

const mapOptions = args => {
  const [expression, scope, defaultValue, separator = "."] = args;

  if (isObject(scope) || isString(expression)) {
    return {
      expression,
      scope,
      defaultValue,
      separator
    };
  }

  return {
    expression: scope,
    scope: expression,
    defaultValue,
    separator
  };
};

function getValue(...args) {
  const options = mapOptions(args);
  let scope = options.scope;
  const {
    expression,
    defaultValue,
    separator
  } = options;

  if (!expression) {
    return scope;
  }

  if (!scope) {
    return defaultValue;
  }

  const keys = expression.split(separator);

  const getValue = key => {
    if (scope instanceof Map || isFunction(scope.get)) {
      return scope[key] || scope.get(key);
    }

    return scope[key];
  };

  while ((scope = getValue(keys.shift())) && keys.length) {}

  return scope === undefined ? defaultValue : scope;
}

/**
 * Return true if the target.
 * @param target
 * @returns {boolean}
 */

function isCollection(target) {
  return isArrayOrArrayClass(target) || target === Map || target instanceof Map || target === Set || target instanceof Set || target === WeakMap || target instanceof WeakMap || target === WeakSet || target instanceof WeakSet;
}

/**
 * Return true if the value is an empty string, null or undefined.
 * @param value
 * @returns {boolean}
 */

function isEmpty(value) {
  return value === "" || isNil(value);
}

function isInheritedFrom(target, from, deep = 5) {
  if (!target || !from) {
    return false;
  }

  target = classOf(target);
  from = classOf(from);

  while (nameOf(target) !== "") {
    if (!deep) {
      return false;
    }

    if (target === from) {
      return true;
    }

    target = getInheritedClass(target);
    deep--;
  }

  return false;
}

function isObservable(obj) {
  return !!obj && typeof obj.lift === "function" && typeof obj.subscribe === "function";
}

function isStream(obj) {
  return obj !== null && typeof obj === "object" && typeof obj.pipe === "function";
}

function primitiveOf(target) {
  if (isString(target)) {
    return "string";
  }

  if (isNumber(target)) {
    return "number";
  }

  if (isBoolean(target)) {
    return "boolean";
  }

  return "any";
}

function setValue(scope, expression, value, separator = ".") {
  const keys = expression.split(separator);

  const setValue = (key, add) => {
    if (isProtectedKey(key)) {
      return false;
    }

    if (add) {
      if (typeof scope.set === "function") {
        scope.set(key, value);
      } else {
        scope[key] = value;
      }

      return false;
    }

    if (typeof scope.set === "function") {
      if (!scope.has(key)) {
        scope.set(key, {});
      }

      scope = scope.get(key);
    } else {
      scope = scope[key] = scope[key] || {};
    }

    return true;
  };

  while (setValue(keys.shift(), !keys.length)) {}
}

function createIdentityFn(keyOrFn) {
  if (!keyOrFn) {
    return (v, k) => String(k);
  }

  if (isString(keyOrFn)) {
    return item => {
      return item[keyOrFn];
    };
  }

  return keyOrFn;
}

function toMap(input, keyOrFn) {
  if (isArray(input)) {
    const identity = createIdentityFn(keyOrFn || "id");
    return input.reduce((map, value, index) => {
      const ids = [].concat(identity(value, index));
      ids.forEach(id => map.set(id, value));
      return map;
    }, new Map());
  }

  const identity = createIdentityFn(keyOrFn);
  return Object.entries(input).reduce((map, [key, value]) => {
    return map.set(identity(value, key), value);
  }, new Map());
}

const fixPath = __webpack_require__(7360);

function normalizePath(item, ...paths) {
  if (isString(item)) {
    const path$1 = path.join(item, ...paths);
    return fixPath(path$1);
  }

  if (isArray(item)) {
    return item.map(item => normalizePath(item));
  }

  return item;
}

class Entity {
  constructor({
    target,
    propertyKey,
    descriptor,
    index
  }) {
    this._target = target;
    this.propertyKey = propertyKey;
    this.propertyName = String(propertyKey);
    this.descriptor = descriptor;
    this.index = index;
    this.decoratorType = decoratorTypeOf([target, propertyKey, descriptor || index]);
    this.token = target && classOf(target);
  }
  /**
   * Reference to the class
   */


  get target() {
    return this._target;
  }
  /**
   * Return the class name of the entity.
   * @returns {string}
   */


  get targetName() {
    return nameOf(this.token);
  }
  /**
   *
   * @returns {Type<any>}
   */


  get type() {
    return this._type;
  }
  /**
   * Get original type without transformation
   * @param value
   */


  set type(value) {
    this._type = value;
  }
  /**
   * Return the itemSchema target type. if the type is a function used for recursive model, the function will be called to
   * get the right type.
   */


  get computedType() {
    return this._type;
  }
  /**
   *
   * @returns {boolean}
   */


  get isCollection() {
    return !!this.collectionType;
  }
  /**
   *
   * @returns {boolean}
   */


  get isArray() {
    return isArrayOrArrayClass(this.collectionType);
  }
  /**
   *
   * @returns {boolean}
   */


  get isPrimitive() {
    return isPrimitiveOrPrimitiveClass(this._type);
  }
  /**
   *
   * @returns {boolean}
   */


  get isDate() {
    return isDate(this.computedType);
  }
  /**
   *
   * @returns {boolean}
   */


  get isObject() {
    return isObject(this.computedType);
  }
  /**
   *
   */


  get isClass() {
    return isClass(this.computedType);
  }

}

/**
 *
 */
exports.Env = void 0;

(function (Env) {
  Env["PROD"] = "production";
  Env["DEV"] = "development";
  Env["TEST"] = "test";
})(exports.Env || (exports.Env = {}));
/**
 * Fallback
 * @type {Env}
 */
// tslint:disable-next-line: variable-name


const EnvTypes = exports.Env;

class Hooks {
  constructor() {
    this.listeners = new Map();
  }
  /**
   * Listen a hook event
   * @param event
   * @param cb
   */


  on(event, cb) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }

    this.listeners.get(event).push(cb);
    return this;
  }
  /**
   * Remove a listener attached to an event
   * @param event
   * @param cb
   */


  off(event, cb) {
    if (this.listeners.has(event)) {
      this.listeners.set(event, this.listeners.get(event).filter(item => item === cb));
    }

    return this;
  }
  /**
   * Trigger an event and call listener.
   * @param event
   * @param args
   * @param callThis
   */


  emit(event, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        cb.call(callThis, ...args);
      }
    }
  }
  /**
   * Trigger an event, listener alter given value and return it.
   * @param event
   * @param value
   * @param args
   * @param callThis
   */


  alter(event, value, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        value = cb.call(callThis, value, ...args);
      }
    }

    return value;
  }
  /**
   * Trigger an event and call async listener.
   * @param event
   * @param args
   * @param callThis
   */


  async asyncEmit(event, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        await cb.call(callThis, ...args);
      }
    }
  }
  /**
   * Trigger an event, async listener alter given value and return it.
   * @param event
   * @param value
   * @param args
   * @param callThis
   */


  async asyncAlter(event, value, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        value = await cb.call(callThis, value, ...args);
      }
    }

    return value;
  }

}

/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_PARAM_TYPES = "design:paramtypes";
/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_TYPE = "design:type";
/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_RETURN_TYPE = "design:returntype";
/**
 * Properties collections
 * @private
 * @type {string}
 */

const PROPERTIES = new Map();
/**
 * @stable
 */

class Metadata {
  /**
   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.get("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.get("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.get("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.get("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.get("custom:annotation", Example.prototype, "method");
   * ```
   *
   */
  static get(key, target, propertyKey) {
    return Reflect.getMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.getOwn("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwn("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.getOwn("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.getOwn("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.getOwn("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static getOwn(key, target, propertyKey) {
    return Reflect.getOwnMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getType(Example, "staticMethod");
   * ```
   *
   */


  static getType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getOwnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getOwnType(Example, "staticMethod");
   * ```
   *
   */


  static getOwnType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getReturnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getReturnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getReturnType(Example, "staticMethod");
   * ```
   *
   */


  static getReturnType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_RETURN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getOwnReturnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwnReturnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getOwnReturnType(Example, "staticMethod");
   * ```
   *
   */


  static getOwnReturnType(target, propertyKey) {
    return Reflect.getOwnMetadata(DESIGN_RETURN_TYPE, target, propertyKey);
  }
  /**
   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.has("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.has("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.has("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.has("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.has("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static has(key, target, propertyKey) {
    try {
      return Reflect.hasMetadata(key, classOf(target), propertyKey);
    } catch (er) {}

    return false;
  }
  /**
   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.has("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.hasOwn("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.hasOwn("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.hasOwn("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.hasOwn("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static hasOwn(key, target, propertyKey) {
    return Reflect.hasOwnMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Deletes the metadata entry from the target object with the provided key.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata entry was found and deleted; otherwise, false.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.delete("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.delete("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.delete("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.delete("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.delete("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static delete(key, target, propertyKey) {
    return Reflect.deleteMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Set the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @param value A value that contains attached metadata.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.setParamTypes(Example, undefined, [Object]);
   *
   * // property (on constructor)
   * result = Metadata.setParamTypes(Example, "staticProperty", [Object]);
   *
   * // property (on prototype)
   * result = Metadata.setParamTypes(Example.prototype, "property", [Object]);
   *
   * // method (on constructor)
   * result = Metadata.setParamTypes(Example, "staticMethod", [Object]);
   *
   * // method (on prototype)
   * result = Metadata.setParamTypes(Example.prototype, "method", [Object]);
   * ```
   *
   */


  static setParamTypes(target, propertyKey, value) {
    return this.set(DESIGN_PARAM_TYPES, value, target.prototype, propertyKey);
  }
  /**
   * Define a unique metadata entry on the target.
   * @param key A key used to store and retrieve metadata.
   * @param value A value that contains attached metadata.
   * @param target The target object on which to define metadata.
   * @param propertyKey The property key for the target.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * Reflect.defineMetadata("custom:annotation", options, Example);
   *
   * // property (on constructor)
   * Reflect.defineMetadata("custom:annotation", Number, Example, "staticProperty");
   *
   * // property (on prototype)
   * Reflect.defineMetadata("custom:annotation", Number, Example.prototype, "property");
   *
   * // method (on constructor)
   * Reflect.defineMetadata("custom:annotation", Number, Example, "staticMethod");
   *
   * // method (on prototype)
   * Reflect.defineMetadata("custom:annotation", Number, Example.prototype, "method");
   *
   * // decorator factory as metadata-producing annotation.
   * function MyAnnotation(options): PropertyDecorator {
   *     return (target, key) => Reflect.defineMetadata("custom:annotation", options, target, key);
   * }
   * ```
   *
   */


  static set(key, value, target, propertyKey) {
    const targets = PROPERTIES.has(key) ? PROPERTIES.get(key) || [] : [];
    const classConstructor = classOf(target);

    if (targets.indexOf(classConstructor) === -1) {
      targets.push(classConstructor);
      PROPERTIES.set(key, targets);
    }

    Reflect.defineMetadata(key, value, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param targetPrototype
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getParamTypes(Example.prototype);
   *
   * // property (on constructor)
   * result = Metadata.getParamTypes(Example.prototype, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getParamTypes(Example.prototype, "staticMethod");
   * ```
   *
   */


  static getParamTypes(targetPrototype, propertyKey) {
    return Reflect.getMetadata(DESIGN_PARAM_TYPES, targetPrototype, propertyKey) || [];
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getParamTypes(Example);
   *
   * // property (on constructor)
   * result = Metadata.getParamTypes(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getParamTypes(Example, "staticMethod");
   * ```
   *
   */


  static getOwnParamTypes(target, propertyKey) {
    return Reflect.getOwnMetadata(DESIGN_PARAM_TYPES, target, propertyKey) || [];
  }

}
/**
 * Get all metadata for a metadataKey.
 * @param metadataKey
 */

Metadata.getTargetsFromPropertyKey = metadataKey => PROPERTIES.has(metadataKey) ? PROPERTIES.get(metadataKey) || [] : [];

/**
 * @ignore
 */

const CLASS_STORE = "tsed:class:store";
/**
 * @ignore
 */

const METHOD_STORE = "tsed:method:store";
/**
 * @ignore
 */

const PROPERTY_STORE = "tsed:property:store";
/**
 * @ignore
 */

const PARAM_STORE = "tsed:param:store";
const stores = new Map();

function storeGet(key, ...args) {
  if (isSymbol(args[0])) {
    if (!stores.has(args[0])) {
      stores.set(args[0], new Store());
    }

    return stores.get(args[0]);
  } else {
    const registry = Metadata;

    if (!registry.hasOwn(key, ...args)) {
      registry.set(key, new Store(), ...args);
    }

    return registry.getOwn(key, ...args);
  }
}

function defineStore(args) {
  const [target, propertyKey, descriptor] = args;

  switch (decoratorTypeOf(args)) {
    case exports.DecoratorTypes.PARAM_CTOR:
    case exports.DecoratorTypes.PARAM_STC:
    case exports.DecoratorTypes.PARAM:
      const store = storeGet(PARAM_STORE, target, propertyKey);

      if (!store.has("" + descriptor)) {
        store.set("" + descriptor, new Store());
      }

      return store.get("" + descriptor);

    case exports.DecoratorTypes.PROP:
    case exports.DecoratorTypes.PROP_STC:
      return storeGet(PROPERTY_STORE, target, propertyKey);

    case exports.DecoratorTypes.METHOD:
    case exports.DecoratorTypes.METHOD_STC:
      return storeGet(METHOD_STORE, target, propertyKey);

    case exports.DecoratorTypes.CLASS:
      return storeGet(CLASS_STORE, target);
  }
}

var _entries = /*#__PURE__*/_classPrivateFieldLooseKey("entries");

class Store {
  constructor() {
    Object.defineProperty(this, _entries, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _entries)[_entries] = new Map();
  }

  /**
   * Create or get a Store from args {target + methodName + descriptor}
   * @param args
   * @returns {Store}
   */
  static from(...args) {
    return defineStore(args);
  }
  /**
   * Create store on the method.
   * @param target
   * @param {string} propertyKey
   * @returns {Store}
   */


  static fromMethod(target, propertyKey) {
    return Store.from(target, propertyKey, descriptorOf(target, propertyKey));
  }
  /**
   * The get() method returns a specified element from a Map object.
   * @param key Required. The key of the element to return from the Map object.
   * @param defaultValue
   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
   */


  get(key, defaultValue) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].get(nameOf(key)) || defaultValue;
  }
  /**
   * The has() method returns a boolean indicating whether an element with the specified key exists or not.
   * @param key
   * @returns {boolean}
   */


  has(key) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].has(nameOf(key));
  }
  /**
   * The set() method adds or updates an element with a specified key and value to a Map object.
   * @param key Required. The key of the element to add to the Map object.
   * @param metadata Required. The value of the element to add to the Map object.
   */


  set(key, metadata) {
    _classPrivateFieldLooseBase(this, _entries)[_entries].set(nameOf(key), metadata);

    return this;
  }
  /**
   * The delete() method removes the specified element from a Map object.
   * @param key Required. The key of the element to remove from the Map object.
   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
   */


  delete(key) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].delete(nameOf(key));
  }
  /**
   * Merge given value with existing value.
   * @param key
   * @param value
   * @param inverse Change the merge order. Get the existing value and apply over given value
   * @returns {Store}
   */


  merge(key, value, inverse = false) {
    let _value_ = this.get(key);

    if (_value_) {
      value = deepClone(value);
      _value_ = deepClone(_value_);
      value = inverse ? deepMerge(value, _value_) : deepMerge(_value_, value);
    }

    this.set(key, value);
    return this;
  }

}

const Type = Function; // @ts-ignore

__webpack_require__.g.Type = Type;

class UnsupportedDecoratorType extends Error {
  constructor(decorator, args) {
    super(UnsupportedDecoratorType.buildMessage(decorator, args));
  }

  static buildMessage(decorator, args) {
    const [target, propertyKey, index] = args;
    const bindingType = decoratorTypeOf(args);
    const shortBinding = bindingType.split("/")[0];
    const param = shortBinding === "parameter" ? ".[" + index + "]" : "";
    const cstr = shortBinding === "parameter" ? ".constructor" : "";
    const method = propertyKey ? "." + propertyKey : cstr;
    const path = nameOf(classOf(target)) + method + param;
    return `${decorator.name} cannot be used as ${bindingType} decorator on ${path}`;
  }

}

/**
 * The `@Deprecated()` decorators wraps the given method in such a way that it is marked as deprecated.
 *
 * ```typescript
 * provide Foo {
 *
 * @Deprecated("Foo.method: Use Foo.method2 instead")
 * public method() {
 *
 * }
 * ```
 *
 * When called, @Deprecated() will return a function that will emit a `DeprecationWarning` using the `process.on('warning')` event.
 * By default, this warning will be emitted and printed to `stderr` exactly once, the first time it is called. After the warning is emitted, the wrapped method is called.
 *
 * If either the `--no-deprecation` or `--no-warnings` command line flags are used, or if the `process.noDeprecation`
 * property is set to `true` prior to the first deprecation warning, the `@Deprecated()` decorators does nothing.
 *
 * If the `--trace-deprecation` or `--trace-warnings` command line flags are set, or the `process.traceDeprecation`
 * property is set to `true`, a warning and a stack trace are printed to stderr the first time the deprecated function is called.
 *
 * If the `--throw-deprecation` command line flag is set, or the `process.throwDeprecation` property is set to `true`,
 * then an exception will be thrown when the deprecated function is called.
 *
 * The `--throw-deprecation` command line flag and `process.throwDeprecation` property take precedence over `--trace-deprecation`
 * and `process.traceDeprecation`.
 *
 * @param message
 * @returns {Function}
 * @decorator
 */
function Deprecated(message) {
  return (target, targetKey, descriptor) => {
    const originalMethod = descriptor.value;
    descriptor.value = (__webpack_require__(43335).deprecate)(originalMethod, message);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Configurable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      writable: true,
      enumerable: true
    };
    descriptor.configurable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Enumerable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      writable: true,
      configurable: true
    };
    descriptor.enumerable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Writable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      configurable: true,
      enumerable: true
    };
    descriptor.writable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Readonly() {
  return Writable(false);
}

/**
 * @module common/core
 */
/** */

function NotConfigurable() {
  return Configurable(false);
}

/**
 * @module common/core
 */
/** */

function NotEnumerable() {
  return Enumerable(false);
}

/**
 * Create a store correctly configured from the parameters given by the decorator.
 * The `fn` can return a decorator that will be initialized with the parameters (target, propertyKey, descriptor).
 * @param {(store: Store, parameters: DecoratorParameters) => void} fn
 * @returns {Function}
 */

function StoreFn(fn) {
  return (...parameters) => {
    const store = Store.from(...parameters);
    const result = fn(store, parameters);

    if (typeof result === "function") {
      result(...parameters);
    }

    return parameters[2];
  };
}

function StoreSet(key, value) {
  return StoreFn(store => {
    store.set(key, value);
  });
}

function StoreMerge(key, value) {
  return StoreFn(store => {
    store.merge(key, value);
  });
}

exports.CLASS_STORE = CLASS_STORE;
exports.Configurable = Configurable;
exports.Deprecated = Deprecated;
exports.Entity = Entity;
exports.Enumerable = Enumerable;
exports.EnvTypes = EnvTypes;
exports.Hooks = Hooks;
exports.METHOD_STORE = METHOD_STORE;
exports.Metadata = Metadata;
exports.NotConfigurable = NotConfigurable;
exports.NotEnumerable = NotEnumerable;
exports.PARAM_STORE = PARAM_STORE;
exports.PROPERTY_STORE = PROPERTY_STORE;
exports.Readonly = Readonly;
exports.Store = Store;
exports.StoreFn = StoreFn;
exports.StoreMerge = StoreMerge;
exports.StoreSet = StoreSet;
exports.Type = Type;
exports.UnsupportedDecoratorType = UnsupportedDecoratorType;
exports.Writable = Writable;
exports.ancestorsOf = ancestorsOf;
exports.catchAsyncError = catchAsyncError;
exports.catchError = catchError;
exports.classOf = classOf;
exports.cleanObject = cleanObject;
exports.constructorOf = constructorOf;
exports.decorateMethodsOf = decorateMethodsOf;
exports.decoratorArgs = decoratorArgs;
exports.decoratorTypeOf = decoratorTypeOf;
exports.deepClone = deepClone;
exports.deepExtends = deepExtends;
exports.deepMerge = deepMerge;
exports.descriptorOf = descriptorOf;
exports.getClass = getClass;
exports.getClassOrSymbol = getClassOrSymbol;
exports.getConstructor = getConstructor;
exports.getConstructorArgNames = getConstructorArgNames;
exports.getEnumerableKeys = getEnumerableKeys;
exports.getInheritedClass = getInheritedClass;
exports.getValue = getValue;
exports.inheritedDescriptorOf = inheritedDescriptorOf;
exports.isArray = isArray;
exports.isArrayOrArrayClass = isArrayOrArrayClass;
exports.isArrowFn = isArrowFn;
exports.isBoolean = isBoolean;
exports.isClass = isClass;
exports.isClassObject = isClassObject;
exports.isCollection = isCollection;
exports.isDate = isDate;
exports.isEmpty = isEmpty;
exports.isEnumerable = isEnumerable;
exports.isFunction = isFunction;
exports.isInheritedFrom = isInheritedFrom;
exports.isNil = isNil;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isObservable = isObservable;
exports.isPlainObject = isPlainObject;
exports.isPrimitive = isPrimitive;
exports.isPrimitiveClass = isPrimitiveClass;
exports.isPrimitiveOrPrimitiveClass = isPrimitiveOrPrimitiveClass;
exports.isPromise = isPromise;
exports.isProtectedKey = isProtectedKey;
exports.isStream = isStream;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.mergeReducerBuilder = mergeReducerBuilder;
exports.methodsOf = methodsOf;
exports.nameOf = nameOf;
exports.nameOfClass = nameOfClass;
exports.nameOfSymbol = nameOfSymbol;
exports.normalizePath = normalizePath;
exports.objectKeys = objectKeys;
exports.primitiveOf = primitiveOf;
exports.prototypeOf = prototypeOf;
exports.proxyDelegation = proxyDelegation;
exports.setValue = setValue;
exports.toMap = toMap;
exports.toStringConstructor = toStringConstructor;
exports.uniq = uniq;
exports.uniqBy = uniqBy;
exports.useDecorators = useDecorators;
exports.useMethodDecorator = useMethodDecorator;
exports.useMethodDecorators = useMethodDecorators;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 1755:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStatusConstant = exports.HTTP_STATUS_MESSAGES = void 0;
const change_case_1 = __webpack_require__(54672);
exports.HTTP_STATUS_MESSAGES = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "Success",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "306": "(Unused)",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "310": "Too Many Redirects",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Request Entity Too Large",
    "414": "Request URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Request Range Unsatisfiable",
    "417": "Expectation Failed",
    "418": "I'm a Teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "427": "Unassigned",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "430": "Unassigned",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
};
function getStatusConstant(status) {
    return change_case_1.constantCase(exports.HTTP_STATUS_MESSAGES[status]);
}
exports.getStatusConstant = getStatusConstant;
//# sourceMappingURL=httpStatusMessages.js.map

/***/ }),

/***/ 36733:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CollectionContains = void 0;
const collectionOf_1 = __webpack_require__(43004);
/**
 * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...
 *
 * The array instance will be valid against "contains" if at least one of its elements is valid against the given schema.
 *
 * ```typescript
 * class Model {
 *    @CollectionContains(String).MinLength(0).MaxLength(0)
 *    property: string[];
 * }
 * ```
 *
 * @param {Type<any>} type
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function CollectionContains(type) {
    return collectionOf_1.CollectionOf(type).Contains();
}
exports.CollectionContains = CollectionContains;
//# sourceMappingURL=collectionContains.js.map

/***/ }),

/***/ 43004:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapOf = exports.ArrayOf = exports.CollectionOf = void 0;
const JsonEntityStore_1 = __webpack_require__(28718);
/**
 * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String).MinLength(0).MaxLength(0)
 *    property: string[];
 * }
 * ```
 * ::: warning
 * You mustn't use the `type Type = string | number` as parameters Type.
 *
 * This example doesn't work:
 *
 * ```typescript
 * type Type = "string" | "number"
 * class Model {
 *    @CollectionOf(Type)
 *    property: Type[];
 * }
 * ```
 * :::
 *
 * @param {Type<any>} type
 * @param collectionType
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function CollectionOf(type, collectionType) {
    const schema = {};
    let contains = false;
    const decorator = (...args) => {
        const store = JsonEntityStore_1.JsonEntityStore.from(...args);
        // const itemSchema = store.itemSchema.toJSON();
        if (collectionType) {
            store.collectionType = collectionType;
            store.schema.type(collectionType);
        }
        store.type = type;
        // console.log(type);
        store.itemSchema.type(type);
        // console.log(store.itemSchema.getComputedType(), schema);
        // store.itemSchema.assign({...itemSchema, type});
        store.schema.assign(schema);
        if (store.isArray && contains) {
            store.schema.set("contains", store.schema.get("items"));
            store.schema.delete("items");
        }
    };
    decorator.MinItems = (minItems) => {
        schema.minItems = minItems;
        return decorator;
    };
    decorator.MaxItems = (maxItems) => {
        schema.maxItems = maxItems;
        return decorator;
    };
    decorator.MinProperties = (minProperties) => {
        schema.minProperties = minProperties;
        return decorator;
    };
    decorator.MaxProperties = (maxProperties) => {
        schema.maxProperties = maxProperties;
        return decorator;
    };
    decorator.Contains = () => {
        contains = true;
        return decorator;
    };
    decorator.UniqueItems = (uniqueItems = true) => {
        schema.uniqueItems = uniqueItems;
        return decorator;
    };
    return decorator;
}
exports.CollectionOf = CollectionOf;
/**
 * Alias of @@GenericOf@@ decorator.
 * @param type
 * @decorator
 */
function ArrayOf(type) {
    return CollectionOf(type, Array);
}
exports.ArrayOf = ArrayOf;
/**
 * Alias of @@GenericOf@@ decorator.
 * @param type
 * @decorator
 */
function MapOf(type) {
    return CollectionOf(type, Map);
}
exports.MapOf = MapOf;
//# sourceMappingURL=collectionOf.js.map

/***/ }),

/***/ 18453:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxItems = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The value `maxItems` MUST be a non-negative integer.
 *
 * An array instance is valid against `maxItems` if its size is less than, or equal to, the value of this keyword.
 *
 * :: warning
 * The value `maxItems` MUST be a non-negative integer.
 * :::
 *
 * :: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@MaxItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @MaxItems(10)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maxItems": 10
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maxItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function MaxItems(maxItems) {
    if (maxItems < 0) {
        throw new Error("The value of maxItems MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((storedJson) => {
        storedJson.schema.maxItems(maxItems);
    });
}
exports.MaxItems = MaxItems;
//# sourceMappingURL=maxItems.js.map

/***/ }),

/***/ 83841:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxProperties = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * An object instance is valid against `maxProperties` if its number of properties is less than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value of this keyword MUST be a non-negative integer.
 * :::
 *
 * ::: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@MaxProperties@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### On prop
 * ```typescript
 * class Model {
 *    @MaxProperties(10)
 *    property: any;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "any",
 *       "maxProperties": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### On class
 *
 * ```typescript
 * @MaxProperties(10)
 * class Model {
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "maxProperties": 10
 * }
 * ```
 *
 * ### On Parameter
 *
 * ```typescript
 *
 * class Model {
 *   method(@Any() @MaxProperties(10) obj: any){}
 * }
 * ```
 *
 * @param {number} maxProperties The maximum properties allowed on the given object
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function MaxProperties(maxProperties) {
    if (maxProperties < 0) {
        throw new Error("The value of maxProperties MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.isCollection ? store.schema.maxProperties(maxProperties) : store.itemSchema.maxProperties(maxProperties);
    });
}
exports.MaxProperties = MaxProperties;
//# sourceMappingURL=maxProperties.js.map

/***/ }),

/***/ 96171:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MinItems = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * An array instance is valid against `minItems` if its size is greater than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value `minItems` MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @MinItems(10)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "minItems": 10,
 *       "items": {
 *         "type": "string"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function MinItems(minItems) {
    if (minItems < 0) {
        throw new Error("The value of minItems MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((storedJson) => {
        storedJson.schema.minItems(minItems);
    });
}
exports.MinItems = MinItems;
//# sourceMappingURL=minItems.js.map

/***/ }),

/***/ 20230:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MinProperties = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * An object instance is valid against `minProperties` if its number of properties is less than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value of this keyword MUST be a non-negative integer.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinProperties@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### On prop
 * ```typescript
 * class Model {
 *    @MinProperties(10)
 *    property: any;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "any",
 *       "minProperties": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### On class
 *
 * ```typescript
 * @MinProperties(10)
 * class Model {
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "minProperties": 10
 * }
 * ```
 *
 * ### On Parameter
 *
 * ```typescript
 *
 * class Model {
 *   method(@Any() @MinProperties(10) obj: any){}
 * }
 * ```
 *
 * @param {number} minProperties The minimum properties allowed on the object.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function MinProperties(minProperties) {
    if (minProperties < 0) {
        throw new Error("The value of minProperties MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.isCollection ? store.schema.minProperties(minProperties) : store.itemSchema.minProperties(minProperties);
    });
}
exports.MinProperties = MinProperties;
//# sourceMappingURL=minProperties.js.map

/***/ }),

/***/ 26052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniqueItems = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * If this keyword has boolean value false, the instance validates successfully. If it has boolean value true, the instance validates successfully if all of its elements are unique.
 *
 * ::: warning
 * For v6 user, use @@UniqueItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @UniqueItems()  // default true
 *    property: number[];
 * }
 * ```
 *
 *  * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @UniqueItems()
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "uniqueItems": true,
 *       "items": {
 *         "type": "string"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {boolean} uniqueItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */
function UniqueItems(uniqueItems = true) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.schema.uniqueItems(uniqueItems);
    });
}
exports.UniqueItems = UniqueItems;
//# sourceMappingURL=uniqueItems.js.map

/***/ }),

/***/ 77173:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdditionalProperties = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Accept unknown properties on the deserialized model.
 *
 * @param schema
 * @decorator
 * @validation
 * @swagger
 * @schema
 */
function AdditionalProperties(schema) {
    return jsonEntityFn_1.JsonEntityFn((entity, parameters) => {
        entity.itemSchema.additionalProperties(schema);
    });
}
exports.AdditionalProperties = AdditionalProperties;
//# sourceMappingURL=additionalProperties.js.map

/***/ }),

/***/ 12062:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllOf = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param allOf
 */
function AllOf(...allOf) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.itemSchema.allOf(allOf);
    });
}
exports.AllOf = AllOf;
//# sourceMappingURL=allOf.js.map

/***/ }),

/***/ 95301:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Allow = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
const property_1 = __webpack_require__(70814);
/**
 * Add allowed values when the property or parameters is required.
 *
 * #### Example on parameter:
 *
 * ```typescript
 * @Post("/")
 * async method(@Allow("") @BodyParams("field") field: string) {}
 * ```
 * > Required will throw a BadRequest when the given value is `null` or `undefined` but not for an empty string.
 *
 * #### Example on model:
 *
 * ```typescript
 * class Model {
 *   @Allow("")
 *   field: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Allow(...values) {
    const model = values.find((item) => core_1.isClass(item));
    return core_1.useDecorators(model && property_1.Property(model), jsonEntityFn_1.JsonEntityFn((store, args) => {
        store.schema.allow(...values);
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                store.parameter.required(true);
                break;
            case core_1.DecoratorTypes.PROP:
                store.parentSchema.addRequired(store.propertyName);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Allow, args);
        }
    }));
}
exports.Allow = Allow;
//# sourceMappingURL=allow.js.map

/***/ }),

/***/ 34351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Any = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set the type of the array items.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Any()
 *    property: any;
 *
 *    @Any(String, Number, Boolean)
 *    property: string | number | boolean;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": ["integer", "number", "string", "boolean", "array", "object", "null"]
 *     }
 *   }
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Any(...types) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.any(...types);
    });
}
exports.Any = Any;
//# sourceMappingURL=any.js.map

/***/ }),

/***/ 41191:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnyOf = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 *
 * ::: warning
 * AnyOf isn't supported by OS2
 * :::
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param anyOf
 */
function AnyOf(...anyOf) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.itemSchema.anyOf(anyOf);
    });
}
exports.AnyOf = AnyOf;
//# sourceMappingURL=anyOf.js.map

/***/ }),

/***/ 46383:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Const = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The const keyword is used to restrict a value to a fixed value.
 *
 * ::: warning
 * For v6 user, use @@Const@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With a string
 *
 * ```typescript
 * class Model {
 *    @Const("value1")
 *    property: "value1";
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "const": "value1"
 *     }
 *   }
 * }
 * ```
 *  * ### With a boolean
 *
 * ```typescript
 * class Model {
 *    @Const(true)
 *    property: boolean;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "boolean",
 *       "const": true
 *     }
 *   }
 * }
 * ```
 *
 * @param {string | number | boolean } constValue
 * @decorator
 * @validation
 * @swagger
 * @schema
 */
function Const(constValue) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.const(constValue);
    });
}
exports.Const = Const;
//# sourceMappingURL=const.js.map

/***/ }),

/***/ 14134:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomKeys = exports.CustomKey = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set a custom key on JsonSchema that is not a part of the official spec.
 *
 * This custom key can only be displayed if the @@getJsonSchema@@ is called with `{customKeys: true}`.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function CustomKey(key, value) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.customKey(key, value);
    });
}
exports.CustomKey = CustomKey;
/**
 * Set a group of custom keys on JsonSchema that is not a part of the official spec.
 *
 * This custom key can only be displayed if the @@getJsonSchema@@ is called with `{customKeys: true}`.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function CustomKeys(obj) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        Object.entries(obj).forEach(([key, value]) => {
            store.itemSchema.customKey(key, value);
        });
    });
}
exports.CustomKeys = CustomKeys;
//# sourceMappingURL=customKey.js.map

/***/ }),

/***/ 1460:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * There are no restrictions placed on the value of this keyword.
 *
 * ::: warning
 * For v6 user, use @@Default@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * This keyword can be used to supply a default JSON value associated with a particular schema.
 * It is RECOMMENDED that a default value be valid against the associated schema.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Default("10")
 *    property: string = "10";
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "default": "10"
 *     }
 *   }
 * }
 * ```
 *
 * @param {string | number | boolean | {}} defaultValue
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Default(defaultValue) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.default(defaultValue);
    });
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ 19701:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Description = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add a description to the class, method or property
 *
 * ## Examples
 * ### On class
 *
 * ```typescript
 * @Description("description")
 * class Model {
 *
 * }
 * ```
 *
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    @Description("description")
 *    async method() {}
 * }
 * ```
 *
 * ### On parameter
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    async method(@Description("description") @PathParam("id") id: string) {}
 * }
 * ```
 *
 * ### On property
 *
 * ```typescript
 * class Model {
 *    @Description("description")
 *    id: string;
 * }
 * ```
 *
 * @param {string} description
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @classDecorator
 * @methodDecorator
 * @propertyDecorator
 * @parameterDecorator
 */
function Description(description) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        var _a, _b;
        switch (core_1.decoratorTypeOf(args)) {
            case core_1.DecoratorTypes.PROP:
            case core_1.DecoratorTypes.CLASS:
                store.schema.description(description);
                break;
            case core_1.DecoratorTypes.PARAM:
                (_a = store.parameter) === null || _a === void 0 ? void 0 : _a.description(description);
                break;
            case core_1.DecoratorTypes.METHOD:
                (_b = store.operation) === null || _b === void 0 ? void 0 : _b.description(description);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Description, args);
        }
    });
}
exports.Description = Description;
//# sourceMappingURL=description.js.map

/***/ }),

/***/ 88993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enum = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
const transformTsEnum = (enumValue) => {
    return Object.keys(enumValue).reduce((acc, key) => {
        if (isNaN(+key)) {
            const value = enumValue[key];
            return acc.concat(value);
        }
        return acc;
    }, []);
};
function Enum(enumValue, ...enumValues) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        const values = [enumValue].concat(enumValues).reduce((acc, value) => {
            if (core_1.isObject(value) && value !== null) {
                value = transformTsEnum(value);
            }
            return acc.concat(value);
        }, []);
        const types = values.reduce((set, value) => {
            return set.add(value === null ? "null" : typeof value);
        }, new Set());
        store.itemSchema.enum(values).any(...types);
    });
}
exports.Enum = Enum;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ 51922:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Example = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add a example metadata on the decorated element.
 *
 * @decorator
 * @swagger
 * @schema
 * @input
 * @methodDecorator
 * @classDecorator
 */
function Example(...examples) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (core_1.decoratorTypeOf(args)) {
            case core_1.DecoratorTypes.CLASS:
            case core_1.DecoratorTypes.PROP:
            case core_1.DecoratorTypes.PARAM:
            case core_1.DecoratorTypes.METHOD:
                store.schema.examples(examples);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Example, args);
        }
    });
}
exports.Example = Example;
//# sourceMappingURL=example.js.map

/***/ }),

/***/ 79052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExclusiveMaximum = void 0;
const maximum_1 = __webpack_require__(91937);
/**
 * The value of `exclusiveMaximum` MUST be number, representing an exclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then the instance is valid only if it has a value strictly less than (not equal to) `exclusiveMaximum`.
 *
 * ::: warning
 * For v6 user, use @@ExclusiveMaximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMaximum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "exclusiveMaximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMaximum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "exclusiveMaximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param maximum
 * @param {boolean} exclusiveMaximum
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function ExclusiveMaximum(maximum, exclusiveMaximum = true) {
    return maximum_1.Maximum(maximum, exclusiveMaximum);
}
exports.ExclusiveMaximum = ExclusiveMaximum;
//# sourceMappingURL=exclusiveMaximum.js.map

/***/ }),

/***/ 88086:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExclusiveMinimum = void 0;
const minimum_1 = __webpack_require__(77852);
/**
 * The value of `exclusiveMinimum` MUST be number, representing an exclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then the instance is valid only if it has a value strictly greater than (not equal to) `exclusiveMinimum`.
 *
 * ::: warning
 * For v6 user, use @@ExclusiveMinimum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMinimum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "exclusiveMinimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMinimum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "exclusiveMinimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param minimum
 * @param {boolean} exclusiveMinimum
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function ExclusiveMinimum(minimum, exclusiveMinimum = true) {
    return minimum_1.Minimum(minimum, exclusiveMinimum);
}
exports.ExclusiveMinimum = ExclusiveMinimum;
//# sourceMappingURL=exclusiveMinimum.js.map

/***/ }),

/***/ 55759:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Url = exports.Uri = exports.TimeFormat = exports.DateFormat = exports.DateTime = exports.Email = exports.Format = void 0;
const JsonFormatTypes_1 = __webpack_require__(46382);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The following formats are supported for string validation with `format` keyword:
 *
 * - **date**: full-date according to [RFC3339](https://json-schema.org/latest/json-schema-validation.html#RFC3339).
 * - **time**: time with optional time-zone.
 * - **date-time**: date-time from the same source (time-zone is mandatory).
 * - **uri**: full uri with optional protocol.
 * - **email**: email address.
 * - **hostname**: host name according to [RFC1034](https://tools.ietf.org/html/rfc1034#section-3.1).
 * - **ipv4**: IP address v4.
 * - **ipv6**: IP address v6.
 * - **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.
 *
 * ::: warning
 * For v6 user, use @@Format@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Format("email")
 *    property: string;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "email"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Format("email")
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "email"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} format
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Format(format) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.format(format);
    });
}
exports.Format = Format;
/**
 * Apply an email validation on property.
 *
 * ::: warning
 * For v6 user, use @@Email@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Email()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "email"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Email()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "email"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @schema
 * @swagger
 * @input
 */
function Email() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.EMAIL);
}
exports.Email = Email;
/**
 * Apply a date-time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @DateTime()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "date-time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @DateTime()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "date-time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).
 */
function DateTime() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.DATE_TIME);
}
exports.DateTime = DateTime;
/**
 * Apply a time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Time()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Time()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function DateFormat() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.DATE);
}
exports.DateFormat = DateFormat;
/**
 * Apply a time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @TimeFormat()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @TimeFormat()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function TimeFormat() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.TIME);
}
exports.TimeFormat = TimeFormat;
/**
 * Apply a uri validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Uri()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "uri"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Uri()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "uri"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function Uri() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.URI);
}
exports.Uri = Uri;
/**
 * Apply a url validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Url()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "url"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Url()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "url"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function Url() {
    return Format(JsonFormatTypes_1.JsonFormatTypes.URL);
}
exports.Url = Url;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ 13625:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForwardGroups = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Allow to forward group on specific property.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function ForwardGroups(bool = true) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.schema.$forwardGroups = bool;
    });
}
exports.ForwardGroups = ForwardGroups;
//# sourceMappingURL=forwardGroups.js.map

/***/ }),

/***/ 23048:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Groups = void 0;
const core_1 = __webpack_require__(92267);
const matchGroups_1 = __webpack_require__(46517);
const jsonEntityFn_1 = __webpack_require__(14984);
function Groups(...groups) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        switch (entity.decoratorType) {
            case core_1.DecoratorTypes.CLASS:
                const entries = Object.entries(groups[0]);
                entity.children.forEach((propEntity) => {
                    const groups = entries.filter(([, props]) => props.includes(propEntity.propertyName)).map(([key]) => key);
                    const decorator = Groups(...groups);
                    decorator(propEntity.target, propEntity.propertyKey);
                });
                break;
            case core_1.DecoratorTypes.PROP:
                entity.schema.$hooks.on("groups", (prev, givenGroups) => {
                    if (!prev) {
                        if (matchGroups_1.matchGroups(groups, givenGroups)) {
                            return true;
                        }
                    }
                    return prev;
                });
                break;
            case core_1.DecoratorTypes.PARAM:
                entity.parameter.groups = groups;
                break;
        }
    });
}
exports.Groups = Groups;
//# sourceMappingURL=groups.js.map

/***/ }),

/***/ 34459:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hidden = void 0;
const core_1 = __webpack_require__(92267);
/**
 * Disable documentation for the class and his endpoint.
 *
 * ````typescript
 * @Controller('/')
 * export class Ctrl {
 *
 *   @Get('/')
 *   @Hidden()
 *   hiddenRoute(){
 *
 *   }
 * }
 *
 * @Controller('/')
 * @Hidden()
 * export class Ctrl {
 *   @Get('/')
 *   hiddenRoute() {
 *
 *   }
 *   @Get('/2')
 *   hiddenRoute2() {
 *
 *   }
 * }
 * ```
 *
 * @decorator
 * @ignore
 */
function Hidden() {
    return core_1.StoreSet("hidden", true);
}
exports.Hidden = Hidden;
//# sourceMappingURL=hidden.js.map

/***/ }),

/***/ 45632:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ignore = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * @ignore
 */
const defaultCB = (value, ctx) => ctx.mongoose !== true;
/**
 * Ignore the property when JsonMapper serialize the class to a Plain Object JavaScript.
 *
 * ::: warning
 * Swagger will not generate documentation for the ignored property.
 * :::
 *
 * ```typescript
 * class User {
 *   @Ignore()
 *   _id: string;
 *
 *   @Property()
 *   firstName: string;
 *
 *   @Property()
 *   lastName: string;
 *
 *   @Ignore((value, ctx) => !ctx.mongoose) // don't ignore prop only if mongoose
 *   password: string;
 * }
 * ```
 *
 * The controller:
 * ```typescript
 * import {Post, Controller, BodyParams} from "@tsed/common";
 * import {Person} from "../models/Person";
 *
 * @Controller("/")
 * export class UsersCtrl {
 *   @Get("/")
 *   get(): User {
 *     const user = new User();
 *     user._id = "12345";
 *     user.firstName = "John";
 *     user.lastName = "Doe";
 *     user.password = "secretpassword";
 *     return
 *   }
 * }
 * ```
 *
 * The expected json object:
 *
 * ```json
 * {
 *  "firstName": "John",
 *  "lastName": "Doe"
 * }
 * ```
 * @param cb Callback to know if the property must be ignored
 * @decorator
 * @validation
 * @swagger
 * @schema
 */
function Ignore(cb = defaultCB) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.schema.ignore(cb);
    });
}
exports.Ignore = Ignore;
//# sourceMappingURL=ignore.js.map

/***/ }),

/***/ 20173:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set integer type.
 *
 * ::: warning
 * For v6 user, use @@Integer@@ from @tsed/schema instead of @@Integer@@ from @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Integer()
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "integer"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array of multiple types
 *
 * ```typescript
 * class Model {
 *    @Integer()
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "integer"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Integer() {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.type("integer");
    });
}
exports.Integer = Integer;
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ 14984:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonEntityFn = void 0;
const domain_1 = __webpack_require__(11277);
/**
 * Decorator util to compose another decorator. See @@Description@@ decorator implementation for more details.
 *
 * ## Usage
 *
 * ```typescript
 * export function Description(description: any) {
 *   return JsonEntityFn((entity: JsonEntityStore, args: DecoratorParameters) => {
 *       entity.itemSchema.description(description)
 *   });
 * }
 * ```
 *
 * @param fn
 * @decorator
 * @utils
 * @model
 */
function JsonEntityFn(fn) {
    return (...parameters) => {
        const result = fn(domain_1.JsonEntityStore.from(...parameters), parameters);
        if (typeof result === "function") {
            result(...parameters);
        }
    };
}
exports.JsonEntityFn = JsonEntityFn;
//# sourceMappingURL=jsonEntityFn.js.map

/***/ }),

/***/ 77325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxLength = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
 *
 * The length of a string instance is defined as the number of its characters as defined by [RFC 7159](http://json-schema.org/latest/json-schema-validation.html#RFC7159).
 *
 * ::: warning
 * The value of maxLength MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MaxLength@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MaxLength(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "maxLength": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @MaxLength(10)
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "maxLength": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maxLength The maximum length allowed
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function MaxLength(maxLength) {
    if (maxLength < 0) {
        throw new Error("The value of maxLength MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.maxLength(maxLength);
    });
}
exports.MaxLength = MaxLength;
//# sourceMappingURL=maxLength.js.map

/***/ }),

/***/ 91937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Max = exports.Maximum = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The value of `maximum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is less than or exactly equal to `maximum`.
 *
 * ::: warning
 * For v6 user, use @@Maximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Maximum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Maximum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "maximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maximum The maximum value allowed
 * @param {boolean} exclusive Same effect as ExclusiveMaximum decorator.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Maximum(maximum, exclusive = false) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        exclusive ? store.itemSchema.exclusiveMaximum(maximum) : store.itemSchema.maximum(maximum);
    });
}
exports.Maximum = Maximum;
/**
 * The value of `maximum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is less than or exactly equal to `maximum`.
 *
 * ::: warning
 * For v6 user, use @@Maximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Max(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Max(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "maximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maximum The maximum value allowed
 * @param {boolean} exclusive Same effect as ExclusiveMaximum decorator.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Max(maximum, exclusive = false) {
    return Maximum(maximum, exclusive);
}
exports.Max = Max;
//# sourceMappingURL=maximum.js.map

/***/ }),

/***/ 62905:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MinLength = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 *
 * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
 *
 * The length of a string instance is defined as the number of its characters as defined by [RFC 7159](http://json-schema.org/latest/json-schema-validation.html#RFC7159).
 *
 * ::: warning
 * The value of minLength MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinLength@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MinLength(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "maxLength": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @MinLength(10)
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "minLength": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minLength
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function MinLength(minLength) {
    if (minLength < 0) {
        throw new Error("The value of minLength MUST be a non-negative integer.");
    }
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.minLength(minLength);
    });
}
exports.MinLength = MinLength;
//# sourceMappingURL=minLength.js.map

/***/ }),

/***/ 77852:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Min = exports.Minimum = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The value of `minimum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to `minimum`.
 *
 * ::: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@Minimum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Minimum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "minimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Minimum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "minimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minimum The minimum value allowed
 * @param {boolean} exclusive
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Minimum(minimum, exclusive = false) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        exclusive ? store.itemSchema.exclusiveMinimum(minimum) : store.itemSchema.minimum(minimum);
    });
}
exports.Minimum = Minimum;
/**
 * The value of `minimum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to `minimum`.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Min(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "minimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Min(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "minimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @alias Minimum
 * @param minimum The minimum value allowed
 * @param exclusive
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Min(minimum, exclusive = false) {
    return Minimum(minimum, exclusive);
}
exports.Min = Min;
//# sourceMappingURL=minimum.js.map

/***/ }),

/***/ 3726:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MultipleOf = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * A numeric instance is valid only if division by this keyword's value results in an integer.
 *
 * ::: warning
 * The value of `multipleOf` MUST be a number, strictly greater than 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MultipleOf@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MultipleOf(2)
 *    property: Number;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "multipleOf": 2
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(number)
 *    @MultipleOf(2)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "multipleOf": 2
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} multipleOf The multiple value allowed
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function MultipleOf(multipleOf) {
    if (multipleOf <= 0) {
        throw new Error("The value of multipleOf MUST be a number, strictly greater than 0.");
    }
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.multipleOf(multipleOf);
    });
}
exports.MultipleOf = MultipleOf;
//# sourceMappingURL=multipleOf.js.map

/***/ }),

/***/ 7634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Name = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add a name metadata on the decorated element.
 *
 * ## Examples
 * ### On parameters
 *
 * ```typescript
 * async myMethod(@Name("nameOf") @PathParams("id") id: string): Promise<Model>  {
 *
 * }
 * ```
 *
 * ### On parameters
 *
 * ```typescript
 * @Name("AliasName")
 * @Controller("/")
 * class ModelCtrl {
 *
 * }
 * ```
 *
 * @param name
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @classDecorator
 * @operation
 */
function Name(name) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (core_1.decoratorTypeOf(args)) {
            case core_1.DecoratorTypes.CLASS:
                store.schema.name(name);
                break;
            case core_1.DecoratorTypes.PARAM:
                store.parameter.name(name);
                break;
            default:
                store.parent.schema.addAlias(args[1], name);
        }
    });
}
exports.Name = Name;
//# sourceMappingURL=name.js.map

/***/ }),

/***/ 21968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Nullable = void 0;
const core_1 = __webpack_require__(92267);
const any_1 = __webpack_require__(34351);
const property_1 = __webpack_require__(70814);
/**
 * Set field as nullable.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Nullable(Date)
 *    property: Date | null;
 *
 *    @Nullable(String, Number, Boolean)
 *    property: string | number | boolean | null;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Nullable(type, ...types) {
    types = [type, ...types];
    return core_1.useDecorators(types.length === 1 && property_1.Property(types[0]), any_1.Any(null, ...types));
}
exports.Nullable = Nullable;
//# sourceMappingURL=nullable.js.map

/***/ }),

/***/ 13569:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OneOf = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 *
 * ::: warning
 * OneOf isn't supported by OS2
 * :::
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param oneOf
 */
function OneOf(...oneOf) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.itemSchema.oneOf(oneOf);
    });
}
exports.OneOf = OneOf;
//# sourceMappingURL=oneOf.js.map

/***/ }),

/***/ 42519:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Optional = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add optional annotation on Property or Parameter.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Optional() {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                store.parameter.required(false);
                break;
            case core_1.DecoratorTypes.PROP:
                store.parentSchema.removeRequired(store.propertyName);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Optional, args);
        }
    });
}
exports.Optional = Optional;
//# sourceMappingURL=optional.js.map

/***/ }),

/***/ 60819:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pattern = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * The pattern and Pattern Properties keywords use regular expressions to express constraints.
 * The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that complete syntax is not widely supported, therefore it is recommended that you stick to the subset of that syntax described below.
 *
 * ::: warning
 * For v6 user, use @@Pattern@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * A single unicode character (other than the special characters below) matches itself.
 *
 * * `^`: Matches only at the beginning of the string.
 * * `$`: Matches only at the end of the string.
 * * `(...)`: Group a series of regular expressions into a single regular expression.
 * * `|`: Matches either the regular expression preceding or following the | symbol.
 * * `[abc]`: Matches any of the characters inside the square brackets.
 * * `[a-z]`: Matches the range of characters.
 * * `[^abc]`: Matches any character not listed.
 * * `[^a-z]`: Matches any character outside of the range.
 * * `+`: Matches one or more repetitions of the preceding regular expression.
 * * `*`: Matches zero or more repetitions of the preceding regular expression.
 * * `?`: Matches zero or one repetitions of the preceding regular expression.
 * * `+?`, *?`, ??`: The `*`, `+`, and `?` qualifiers are all greedy; they match as much text as possible. Sometimes this behavior isn’t desired and you want to match as few characters as possible.
 * * `{x}`: Match exactly x occurrences of the preceding regular expression.
 * * `{x,y}`: Match at least x and at most y occurrences of the preceding regular expression.
 * * `{x,}`: Match x occurrences or more of the preceding regular expression.
 * * `{x}?`, {x,y}?, {x,}?`: Lazy versions of the above expressions.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Pattern("^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$")
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string;
 * }
 * ```
 *
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(string)
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *         "type": "string",
 *         "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} pattern
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Pattern(pattern) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.pattern(pattern);
    });
}
exports.Pattern = Pattern;
//# sourceMappingURL=pattern.js.map

/***/ }),

/***/ 70814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Property = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Declare a new property on a model.
 *
 * @param type
 * @decorator
 * @validation
 * @swagger
 * @schema
 */
function Property(type) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        if (type) {
            store.itemSchema.type(type);
        }
    });
}
exports.Property = Property;
//# sourceMappingURL=property.js.map

/***/ }),

/***/ 25071:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadOnly = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set the property as readOnly.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function ReadOnly(readOnly = true) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.readOnly(readOnly);
    });
}
exports.ReadOnly = ReadOnly;
//# sourceMappingURL=readOnly.js.map

/***/ }),

/***/ 11228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Required = void 0;
const allow_1 = __webpack_require__(95301);
const optional_1 = __webpack_require__(42519);
/**
 * Add required annotation on Property or Parameter.
 *
 * The @@Required@@ decorator can be used on two cases.
 *
 * To decorate a parameters:
 *
 * ```typescript
 * @Post("/")
 * async method(@Required() @BodyParams("field") field: string) {}
 * ```
 *
 * To decorate a model:
 *
 * ```typescript
 * class Model {
 *   @Required()
 *   field: string;
 * }
 * ```
 *
 * ::: tip
 * Required will throw a BadRequest when the given value is `null`, an empty string or `undefined`.
 * :::
 *
 * ### Allow values
 *
 * In some case, you didn't want trigger a BadRequest when the value is an empty string for example.
 * The decorator `@Allow()`, allow you to configure a value list for which there will be no exception.
 *
 * ```typescript
 * class Model {
 *   @Allow("") // add automatically required flag
 *   field: string;
 * }
 * ```
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function Required(required = true, ...allowedRequiredValues) {
    return required ? allow_1.Allow(...allowedRequiredValues) : optional_1.Optional();
}
exports.Required = Required;
//# sourceMappingURL=required.js.map

/***/ }),

/***/ 57403:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequiredGroups = void 0;
const core_1 = __webpack_require__(92267);
const matchGroups_1 = __webpack_require__(46517);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Apply groups validation strategy for required property.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */
function RequiredGroups(...groups) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        if (entity.decoratorType === core_1.DecoratorTypes.PROP) {
            entity.parent.schema.$hooks.on("requiredGroups", (required, givenGroups) => {
                if (matchGroups_1.matchGroups(groups, givenGroups)) {
                    return required.filter((key) => key !== entity.propertyKey);
                }
                return required;
            });
        }
    });
}
exports.RequiredGroups = RequiredGroups;
//# sourceMappingURL=requiredGroups.js.map

/***/ }),

/***/ 13609:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.For = exports.Schema = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Write data formatted to JsonSchema.
 *
 * ## Example
 *
 * ```typescript
 * @Schema({title: "test"})
 * class Model {
 *    @Schema({formatMinimum: "1987-10-24"})
 *    @Format("date")
 *    birthDate: Date
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "title": "test",
 *   "properties": {
 *     "birthdate": {
 *        "type": "string",
 *        "format": "date",
 *        "formatMinimum": "1987-10-24"
 *     }
 *   }
 * }
 * ```
 *
 * @param partialSchema
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */
function Schema(partialSchema) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        Object.entries(partialSchema).forEach(([key, value]) => {
            entity.schema.set(key, value);
        });
    });
}
exports.Schema = Schema;
/**
 * Apply specific schema depending on the spec version
 * @param specType
 * @param schema
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */
function For(specType, schema) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.schema.set(specType, schema);
    });
}
exports.For = For;
//# sourceMappingURL=schema.js.map

/***/ }),

/***/ 40827:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Title = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add title metadata on the decorated element.
 *
 * ::: warning
 * For v6 user, use @@Title@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Title("title")
 *    id: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "id": {
 *        "type": "string",
 *        "title": "title"
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} title
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */
function Title(title) {
    return jsonEntityFn_1.JsonEntityFn((entity) => {
        entity.schema.title(title);
    });
}
exports.Title = Title;
//# sourceMappingURL=title.js.map

/***/ }),

/***/ 1118:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteOnly = void 0;
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set the property as WriteOnly.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */
function WriteOnly(writeOnly = true) {
    return jsonEntityFn_1.JsonEntityFn((store) => {
        store.itemSchema.writeOnly(writeOnly);
    });
}
exports.WriteOnly = WriteOnly;
//# sourceMappingURL=writeOnly.js.map

/***/ }),

/***/ 23492:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonEntityComponent = void 0;
const JsonEntityStore_1 = __webpack_require__(28718);
/**
 * Declare a new JsonEntityStore class for a specific decorator type.
 *
 * @ignore
 * @param type
 * @decorator
 */
function JsonEntityComponent(type) {
    return (target) => {
        JsonEntityStore_1.JsonEntityStore.entities.set(type, target);
    };
}
exports.JsonEntityComponent = JsonEntityComponent;
//# sourceMappingURL=jsonEntityComponent.js.map

/***/ }),

/***/ 7971:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericOf = void 0;
const core_1 = __webpack_require__(92267);
const JsonEntityStore_1 = __webpack_require__(28718);
const from_1 = __webpack_require__(91540);
/**
 * @ignore
 */
function isEnum(type) {
    return core_1.isObject(type) && !("toJSON" in type);
}
/**
 * Set the types of a Generic class.
 *
 * ## Example
 *
 * ```typescript
 * class Product {
 *   @Property()
 *   label: string;
 * }
 *
 * @Generics("T")
 * class Paginated<T> {
 *   @CollectionOf("T")
 *   data: T[];
 *
 *   @Property()
 *   totalCount: number;
 * }
 *
 * class Payload {
 *    @GenericOf(Product)
 *    products: Paginated<Product>;
 * }
 * ```
 *
 * ## Example with nested generics
 *
 * ```typescript
 * class Product {
 *   @Property()
 *   label: string;
 * }
 *
 * @Generics("T")
 * class Paginated<T> {
 *   @CollectionOf("T")
 *   data: T[];
 *
 *   @Property()
 *   totalCount: number;
 * }
 *
 * @Generics("D")
 * class Submission<D> {
 *   @Property()
 *   _id: string;
 *
 *   @Property("D")
 *   data: D;
 * }
 *
 * class Payload {
 *    @GenericOf(Submissions).Nested(Product)
 *    submissions: Paginated<Submission<Product>>;
 * }
 * ```
 *
 * @param {Type<any>[]} generics
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @generics
 */
function GenericOf(...generics) {
    const nestedGenerics = [
        generics.map((type) => {
            if (isEnum(type)) {
                return from_1.string().enum(Object.values(type));
            }
            return type;
        })
    ];
    const decorator = (...args) => {
        const store = JsonEntityStore_1.JsonEntityStore.from(...args);
        store.nestedGenerics = nestedGenerics;
    };
    decorator.Nested = (...generics) => {
        nestedGenerics.push(generics);
        return decorator;
    };
    return decorator;
}
exports.GenericOf = GenericOf;
//# sourceMappingURL=genericOf.js.map

/***/ }),

/***/ 34397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Generics = void 0;
const JsonEntityStore_1 = __webpack_require__(28718);
/**
 * Define generics list. This list is used by @@GenericOf@@ and the @@getJsonSchema@@ function to build the correct JsonSchema.
 *
 * See @@GenericOf@@ decorator for more details.
 *
 * @param generics
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @generics
 */
function Generics(...generics) {
    return (target) => {
        const storedSchema = JsonEntityStore_1.JsonEntityStore.from(target);
        storedSchema.schema.genericLabels = generics;
    };
}
exports.Generics = Generics;
//# sourceMappingURL=generics.js.map

/***/ }),

/***/ 78245:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(28203);
// collections
tslib_1.__exportStar(__webpack_require__(36733), exports);
tslib_1.__exportStar(__webpack_require__(43004), exports);
tslib_1.__exportStar(__webpack_require__(18453), exports);
tslib_1.__exportStar(__webpack_require__(96171), exports);
tslib_1.__exportStar(__webpack_require__(26052), exports);
tslib_1.__exportStar(__webpack_require__(83841), exports);
tslib_1.__exportStar(__webpack_require__(20230), exports);
// generics
tslib_1.__exportStar(__webpack_require__(34397), exports);
tslib_1.__exportStar(__webpack_require__(7971), exports);
// operations
tslib_1.__exportStar(__webpack_require__(40486), exports);
tslib_1.__exportStar(__webpack_require__(32216), exports);
tslib_1.__exportStar(__webpack_require__(90685), exports);
tslib_1.__exportStar(__webpack_require__(56269), exports);
tslib_1.__exportStar(__webpack_require__(48001), exports);
tslib_1.__exportStar(__webpack_require__(40205), exports);
tslib_1.__exportStar(__webpack_require__(50502), exports);
tslib_1.__exportStar(__webpack_require__(28704), exports);
tslib_1.__exportStar(__webpack_require__(90777), exports);
tslib_1.__exportStar(__webpack_require__(4704), exports);
tslib_1.__exportStar(__webpack_require__(8358), exports);
tslib_1.__exportStar(__webpack_require__(33545), exports);
tslib_1.__exportStar(__webpack_require__(52200), exports);
tslib_1.__exportStar(__webpack_require__(7663), exports);
// common
tslib_1.__exportStar(__webpack_require__(77173), exports);
tslib_1.__exportStar(__webpack_require__(95301), exports);
tslib_1.__exportStar(__webpack_require__(34351), exports);
tslib_1.__exportStar(__webpack_require__(20173), exports);
tslib_1.__exportStar(__webpack_require__(46383), exports);
tslib_1.__exportStar(__webpack_require__(1460), exports);
tslib_1.__exportStar(__webpack_require__(19701), exports);
tslib_1.__exportStar(__webpack_require__(51922), exports);
tslib_1.__exportStar(__webpack_require__(88993), exports);
tslib_1.__exportStar(__webpack_require__(79052), exports);
tslib_1.__exportStar(__webpack_require__(88086), exports);
tslib_1.__exportStar(__webpack_require__(55759), exports);
tslib_1.__exportStar(__webpack_require__(13625), exports);
tslib_1.__exportStar(__webpack_require__(23048), exports);
tslib_1.__exportStar(__webpack_require__(60819), exports);
tslib_1.__exportStar(__webpack_require__(45632), exports);
tslib_1.__exportStar(__webpack_require__(91937), exports);
tslib_1.__exportStar(__webpack_require__(77325), exports);
tslib_1.__exportStar(__webpack_require__(77852), exports);
tslib_1.__exportStar(__webpack_require__(62905), exports);
tslib_1.__exportStar(__webpack_require__(3726), exports);
tslib_1.__exportStar(__webpack_require__(7634), exports);
tslib_1.__exportStar(__webpack_require__(11228), exports);
tslib_1.__exportStar(__webpack_require__(57403), exports);
tslib_1.__exportStar(__webpack_require__(70814), exports);
tslib_1.__exportStar(__webpack_require__(34459), exports);
tslib_1.__exportStar(__webpack_require__(40827), exports);
tslib_1.__exportStar(__webpack_require__(13609), exports);
tslib_1.__exportStar(__webpack_require__(13569), exports);
tslib_1.__exportStar(__webpack_require__(12062), exports);
tslib_1.__exportStar(__webpack_require__(41191), exports);
tslib_1.__exportStar(__webpack_require__(14984), exports);
tslib_1.__exportStar(__webpack_require__(42519), exports);
tslib_1.__exportStar(__webpack_require__(1118), exports);
tslib_1.__exportStar(__webpack_require__(25071), exports);
tslib_1.__exportStar(__webpack_require__(14134), exports);
tslib_1.__exportStar(__webpack_require__(21968), exports);
tslib_1.__exportStar(__webpack_require__(23492), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32216:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Consumes = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add consumes metadata on the decorated element.
 *
 * ## Examples
 *
 * ```typescript
 * class Model {
 *    @Consumes("application/x-www-form-urlencoded")
 *    id: string;
 * }
 * ```
 *
 * @param consumes
 * @decorator
 * @swagger
 * @classDecorator
 * @operation
 */
function Consumes(...consumes) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.METHOD:
                store.operation.consumes(consumes);
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(args[0], Consumes(...consumes));
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Consumes, args);
        }
    });
}
exports.Consumes = Consumes;
//# sourceMappingURL=consumes.js.map

/***/ }),

/***/ 90685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContentType = void 0;
const returns_1 = __webpack_require__(90777);
/**
 * Sets the Content-Type HTTP header to the MIME type as determined by mime.lookup() for the specified type.
 * If type contains the “/” character, then it sets the `Content-Type` to type.
 *
 * ```typescript
 *  @ContentType('.html');              // => 'text/html'
 *  @ContentType('html');               // => 'text/html'
 *  @ContentType('json');               // => 'application/json'
 *  @ContentType('application/json');   // => 'application/json'
 *  @ContentType('png');                // => image/png
 *  private myMethod() {}
 * ```
 *
 * @param type
 * @decorator
 * @operation
 * @response
 * @headers
 */
function ContentType(type) {
    return returns_1.Returns().ContentType(type);
}
exports.ContentType = ContentType;
//# sourceMappingURL=contentType.js.map

/***/ }),

/***/ 40486:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deprecated = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add deprecated metadata on the decorated element.
 *
 * ## Examples
 *
 * ```typescript
 *
 * @Deprecated()
 * class MyCtrl {
 *   @Deprecated()
 *   @Get("/")
 *   method(){
 *   }
 * }
 * ```
 *
 * @param deprecated
 * @decorator
 * @swagger
 * @schema
 * @operation
 */
function Deprecated(deprecated = true) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.METHOD:
                store.operation.deprecated(deprecated);
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(args[0], Deprecated(deprecated));
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Deprecated, args);
        }
    });
}
exports.Deprecated = Deprecated;
//# sourceMappingURL=deprecated.js.map

/***/ }),

/***/ 8358:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Header = void 0;
const returns_1 = __webpack_require__(90777);
/**
 * Sets the response’s HTTP header field to value. To set multiple fields at once, pass an object as the parameter.
 *
 * ```typescript
 * @Header('Content-Type', 'text/plain');
 * private myMethod() {}
 *
 * @Status(204)
 * @Header({
 *   "Content-Type": "text/plain",
 *   "Content-Length": 123,
 *   "ETag": {
 *     "value": "12345",
 *     "description": "header description"
 *   }
 * })
 * private myMethod() {}
 * ```
 *
 * This example will produce the swagger responses object:
 *
 * ```json
 * {
 *   "responses": {
 *     "204": {
 *       "description": "Description",
 *       "headers": {
 *          "Content-Type": {
 *             "type": "string"
 *          },
 *          "Content-Length": {
 *             "type": "number"
 *          },
 *          "ETag": {
 *             "type": "string",
 *             "description": "header description"
 *          }
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @decorator
 * @operation
 * @response
 */
function Header(headers, value) {
    if (value !== undefined) {
        headers = { [headers]: value };
    }
    return returns_1.Returns().Headers(headers);
}
exports.Header = Header;
//# sourceMappingURL=header.js.map

/***/ }),

/***/ 56269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.In = void 0;
const core_1 = __webpack_require__(92267);
const domain_1 = __webpack_require__(11277);
/**
 * Add a input parameter.
 *
 * ::: warning
 * Don't use decorator with Ts.ED application to decorate parameters. Use @@BodyParams@@, @@PathParams@@, etc... instead.
 * But you can use this decorator on Method, to add extra in parameters like Authorization header.
 *
 * ```typescript
 * @Controller("/")
 * class MyController {
 *    @Get("/")
 *    @In("header").Type(String).Name("Authorization").Required()
 *    method() {
 *    }
 *  }
 * ```
 * :::
 *
 * @param inType
 * @decorator
 * @swagger
 * @schema
 * @input
 * @operation
 */
function In(inType) {
    const jsonParameter = new domain_1.JsonParameter();
    const schema = {};
    const decorator = (target, propertyKey, index) => {
        const store = domain_1.JsonEntityStore.from(target, propertyKey, index);
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                store.parameter.in(inType);
                break;
            case core_1.DecoratorTypes.METHOD:
                jsonParameter.in(inType);
                store.operation.addParameter(-1, jsonParameter);
                jsonParameter.schema(domain_1.JsonSchema.from(schema));
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(target, decorator);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(In, [target, propertyKey, index]);
        }
    };
    decorator.Type = (type) => {
        schema.type = type;
        return decorator;
    };
    decorator.Name = (name) => {
        jsonParameter.name(name);
        return decorator;
    };
    decorator.Description = (description) => {
        jsonParameter.description(description);
        return decorator;
    };
    decorator.Required = (required = true) => {
        jsonParameter.required(required);
        return decorator;
    };
    decorator.Pattern = (pattern) => {
        return decorator.Schema({ pattern: pattern.toString() });
    };
    decorator.Schema = (_schema) => {
        Object.assign(schema, _schema);
        return decorator;
    };
    return decorator;
}
exports.In = In;
//# sourceMappingURL=in.js.map

/***/ }),

/***/ 48001:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationId = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set a swagger operationId explicitly.
 *
 * @param operationId
 * @decorator
 * @swagger
 * @schema
 * @operation
 */
function OperationId(operationId) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        if (store.decoratorType !== core_1.DecoratorTypes.METHOD) {
            throw new core_1.UnsupportedDecoratorType(OperationId, args);
        }
        store.operation.operationId(operationId);
    });
}
exports.OperationId = OperationId;
//# sourceMappingURL=operationId.js.map

/***/ }),

/***/ 40205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationPath = exports.OperationMethods = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
var OperationMethods;
(function (OperationMethods) {
    OperationMethods["ALL"] = "ALL";
    OperationMethods["GET"] = "GET";
    OperationMethods["POST"] = "POST";
    OperationMethods["PUT"] = "PUT";
    OperationMethods["PATCH"] = "PATCH";
    OperationMethods["HEAD"] = "HEAD";
    OperationMethods["DELETE"] = "DELETE";
    OperationMethods["OPTIONS"] = "OPTIONS";
    OperationMethods["CUSTOM"] = "CUSTOM";
})(OperationMethods = exports.OperationMethods || (exports.OperationMethods = {}));
/**
 * Declare new Operation with his path and http method.
 *
 * ::: warning
 * Don't use decorator with Ts.ED application.
 *
 * Use theses decorators instead:
 *
 * <ApiList query="status.includes('decorator') && status.includes('httpMethod')" />
 *
 * :::
 *
 * @param method
 * @param path
 * @decorator
 * @swagger
 * @schema
 * @operation
 */
function OperationPath(method, path = "/") {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        if (store.decoratorType !== core_1.DecoratorTypes.METHOD) {
            throw new core_1.UnsupportedDecoratorType(OperationPath, args);
        }
        store.operation.addOperationPath(method.toUpperCase(), path);
    });
}
exports.OperationPath = OperationPath;
//# sourceMappingURL=operationPath.js.map

/***/ }),

/***/ 50502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Set class path to expose all endpoints
 *
 * ::: warning
 * Don't use this decorator to change the path if you develop your application with Ts.ED.
 * :::
 *
 * @param path
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */
function Path(path) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        if (store.decoratorType !== core_1.DecoratorTypes.CLASS) {
            throw new core_1.UnsupportedDecoratorType(Path, args);
        }
        store.path = path;
    });
}
exports.Path = Path;
//# sourceMappingURL=path.js.map

/***/ }),

/***/ 28704:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Produces = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add produces metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * class Model {
 *    @Produces("text/html")
 *    id: string;
 * }
 * ```
 *
 * ::: warning
 * For openspec v3 prefer `@Returns().ContentType()` usage (see @@Returns@@).
 * :::
 *
 * @param produces
 * @decorator
 * @swagger
 * @methodDecorator
 * @classDecorator
 * @operation
 * @response
 */
function Produces(...produces) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.METHOD:
                store.operation.produces(produces);
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(args[0], Produces(...produces));
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Produces, args);
        }
    });
}
exports.Produces = Produces;
//# sourceMappingURL=produces.js.map

/***/ }),

/***/ 90777:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Returns = void 0;
const core_1 = __webpack_require__(92267);
const httpStatusMessages_1 = __webpack_require__(1755);
const DecoratorContext_1 = __webpack_require__(59394);
const JsonEntityStore_1 = __webpack_require__(28718);
const JsonSchema_1 = __webpack_require__(70676);
const defineStatusModel_1 = __webpack_require__(74466);
const from_1 = __webpack_require__(91540);
const isSuccessStatus_1 = __webpack_require__(84852);
const mapHeaders_1 = __webpack_require__(18532);
/**
 * @ignore
 */
function isEnum(type) {
    return core_1.isObject(type) && !("toJSON" in type);
}
function mapGenerics(types) {
    return types.map((type) => {
        if (isEnum(type)) {
            return from_1.string().enum(Object.values(type));
        }
        return type;
    });
}
/**
 * @ignore
 */
class ReturnDecoratorContext extends DecoratorContext_1.DecoratorContext {
    constructor({ status, model }) {
        super();
        this.methods = [
            "contentType",
            "description",
            "examples",
            "type",
            "status",
            "of",
            "nested",
            "header",
            "headers",
            "schema",
            "title",
            "groups"
        ];
        this.set("status", status);
        this.set("model", model);
        if (status && httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]) {
            this.set("description", httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]);
            if (!model) {
                this.model(defineStatusModel_1.getStatusModel(+status));
            }
        }
    }
    type(model) {
        return this.model(model);
    }
    model(model) {
        this.set("model", model);
        return this;
    }
    status(status) {
        this.set("status", status);
        return this;
    }
    headers(headers) {
        this.set("headers", {
            ...(this.get("headers") || {}),
            ...mapHeaders_1.mapHeaders(headers)
        });
        return this;
    }
    header(key, value) {
        return this.headers({ [key]: value });
    }
    groups(...groups) {
        this.set("groups", groups);
        return this;
    }
    nested(...generics) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.checkCollection(model);
        this.addAction((ctx) => {
            this.get("schema").nestedGenerics.push(mapGenerics(generics));
        });
        return this;
    }
    of(...types) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.addAction(() => {
            const schema = this.get("schema");
            if (core_1.isCollection(model)) {
                schema === null || schema === void 0 ? void 0 : schema.itemSchema({ type: types[0] });
            }
            else {
                schema === null || schema === void 0 ? void 0 : schema.nestedGenerics.push(mapGenerics(types));
            }
        });
        return this;
    }
    schema(partial) {
        this.addAction(() => {
            const schema = this.get("schema");
            schema.assign(partial);
        });
        return this;
    }
    examples(examples) {
        this.set("examples", core_1.isString(examples) ? [examples] : examples);
        return this;
    }
    title(title) {
        return this.schema({ title });
    }
    checkPrimitive(model) {
        if (core_1.isPrimitiveOrPrimitiveClass(model)) {
            throw new Error("Returns.Of cannot be used with the following primitive classes: String, Number, Boolean");
        }
    }
    checkCollection(model) {
        if (core_1.isCollection(model)) {
            throw new Error("Returns.Nested cannot be used with the following classes: Map, Set, Array, String, Number, Boolean");
        }
    }
    getContentType() {
        const model = this.get("model");
        let contentType = this.get("contentType");
        if (model && !core_1.isPlainObject(model) && !core_1.isPrimitiveOrPrimitiveClass(model)) {
            contentType = contentType || "application/json";
        }
        return contentType;
    }
    getStatus() {
        return this.get("status") || "default";
    }
    onInit(args, decorator) {
        const type = core_1.decoratorTypeOf(args);
        switch (type) {
            case core_1.DecoratorTypes.METHOD:
                this.store = JsonEntityStore_1.JsonEntityStore.from(...args);
                if (this.store.operation) {
                    this.map();
                }
                break;
            case core_1.DecoratorTypes.CLASS:
                this.decoratorType = core_1.DecoratorTypes.CLASS;
                core_1.decorateMethodsOf(args[0], decorator);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Returns, args);
        }
    }
    map() {
        const model = this.get("model");
        const { store, decoratorType } = this;
        const operation = this.store.operation;
        const currentStatus = this.getStatus();
        const response = operation.ensureResponseOf(currentStatus);
        const contentType = this.getContentType();
        let { description = response.get("description") } = this.toObject();
        if (description) {
            description = decoratorType === core_1.DecoratorTypes.CLASS ? response.get("description") || description : description;
            response.description(description);
        }
        const headers = this.getMergedKey("headers", response.get("headers"));
        if (headers) {
            response.headers(headers);
        }
        this.mapMedia(response);
        if (isSuccessStatus_1.isSuccessStatus(this.get("status")) || currentStatus === "default") {
            if (model) {
                store.type = model;
            }
        }
        // additional info for OS2
        contentType && operation.addProduce(contentType);
        // run additional actions
        return this.runActions();
    }
    mapMedia(response) {
        const contentType = this.getContentType();
        const model = this.get("model");
        const media = response.getMedia(contentType || "*/*");
        const schema = media.get("schema") || new JsonSchema_1.JsonSchema({ type: model });
        model && schema.type(model);
        this.set("schema", schema);
        media.schema(schema);
        media.groups = this.get("groups");
        const examples = this.get("examples");
        if (examples) {
            media.examples(examples);
        }
        return media;
    }
}
function Returns(status, model) {
    const context = new ReturnDecoratorContext({
        status,
        model
    });
    return context.build();
}
exports.Returns = Returns;
//# sourceMappingURL=returns.js.map

/***/ }),

/***/ 33545:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Security = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add security metadata on the decorated method.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    @Security("write:calendars")
 *    async method() {}
 * }
 * ```
 *
 * @param name
 * @param scopes
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */
function Security(name, ...scopes) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.METHOD:
                store.operation.addSecurityScopes(name, scopes);
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(args[0], Security(name, ...scopes));
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Security, args);
        }
    });
}
exports.Security = Security;
//# sourceMappingURL=security.js.map

/***/ }),

/***/ 4704:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Status = void 0;
const returns_1 = __webpack_require__(90777);
/**
 * Add responses documentation for a specific status code.
 *
 * ## Usage
 *
 * Ts.ED v6 API introducing the chaining decorator concept.
 * Now a decorator like Returns can be used with another decorators like Description.
 *
 * ```typescript
 * import {Returns} from "@tsed/schema";
 *
 * @Controller("/")
 * class MyController {
 *   @Status(404, String).Description("Not Found")
 *   @Status(200, Model).Description("Success")
 *   async myMethod(): Promise<Model> {}
 * }
 * ```
 *
 * ::: tip
 * TypeScript and your IDE will discover automatically the chained decorators. But for more details you can look on @@ReturnsChainedDecorators@@ interface, to know
 * what chained decorators are available under Returns decorator.
 * :::
 *
 * This example will produce this documentation in swagger:
 *
 * ```json
 * {
 *   "responses": {
 *     "404": {
 *       "description": "Description",
 *       "schema": {"type": "string"}
 *     },
 *     "2OO": {
 *       "description": "Description",
 *       "schema": {"$ref": "..."}
 *     }
 *   }
 * }
 * ```
 *
 * ### Declaring a generic model
 *
 * Sometime, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is why we need to
 * declare explicitly the generic models with the decorators.
 *
 * One of the generic's usage, can be a paginated list. With Returns decorator it's now possible to declare generic type and generate the appropriate OpenSpec documentation.
 *
 * Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:
 *
 * ```typescript
 * @Generics("T")
 * class Pagination<T> {
 *  @CollectionOf("T")
 *  data: T[];
 *
 *  @Property()
 *  totalCount: number;
 * }
 * ```
 *
 * Now, we need a model to be used with the generic Pagination model:
 *
 * ```typescript
 * class Product {
 *  @Property()
 *  id: string;
 *
 *  @Property()
 *  title: string;
 * }
 * ```
 *
 * Finally, we can use our models on a method as following:
 *
 * ```typescript
 * class Controller {
 *   @OperationPath("POST", "/")
 *   @Status(200, Pagination).Of(Product).Description("description")
 *   async method(): Promise<Pagination<Product> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * ### Declaring a nested generics models <Badge text="6+"/>
 *
 * It's also possible to declare a nested generics models in order to have this type `Pagination<Submission<Product>>`:
 *
 * ```typescript
 * import {Generics, Property, Returns} from "@tsed/schema";
 * import {Post} from "@tsed/common";
 *
 * class Controller {
 *   @Post("/")
 *   @Status(200, Pagination).Of(Submission).Nested(Product).Description("description")
 *   async method(): Promise<Pagination<Submission<Product>> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * And here is the Submission model:
 *
 * ```typescript
 * import {Generics, Property} from "@tsed/schema";
 *
 * @Generics("T")
 * class Submission<T> {
 *   @Property()
 *   _id: string;
 *   @Property("T")
 *   data: T;
 * }
 * ```
 *
 * @param status
 * @param model
 * @decorator
 * @swagger
 * @schema
 * @response
 * @operation
 */
function Status(status, model) {
    return returns_1.Returns(status, model);
}
exports.Status = Status;
//# sourceMappingURL=status.js.map

/***/ }),

/***/ 7663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Summary = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
/**
 * Add summary metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * class Model {
 *    @Summary("summary")
 *    id: string;
 * }
 * ```
 *
 * @param summary
 * @decorator
 * @swagger
 * @schema
 * @operation
 */
function Summary(summary) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        if (store.decoratorType !== core_1.DecoratorTypes.METHOD) {
            throw new core_1.UnsupportedDecoratorType(Summary, args);
        }
        store.operation.summary(summary);
    });
}
exports.Summary = Summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 52200:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tags = void 0;
const core_1 = __webpack_require__(92267);
const jsonEntityFn_1 = __webpack_require__(14984);
function mapTags(tags) {
    return tags.map((tag) => {
        if (typeof tag === "string") {
            return {
                name: tag
            };
        }
        return tag;
    });
}
/**
 * Add tags metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class MyController {
 *  @Tags("api")
 *  get() {}
 * }
 * ```
 *
 * @param tags
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */
function Tags(...tags) {
    return jsonEntityFn_1.JsonEntityFn((store, args) => {
        switch (store.decoratorType) {
            case core_1.DecoratorTypes.METHOD:
                store.operation.addTags(mapTags(tags));
                break;
            case core_1.DecoratorTypes.CLASS:
                core_1.decorateMethodsOf(args[0], Tags(...tags));
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Tags, args);
        }
    });
}
exports.Tags = Tags;
//# sourceMappingURL=tags.js.map

/***/ }),

/***/ 59394:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecoratorContext = void 0;
const core_1 = __webpack_require__(92267);
const change_case_1 = __webpack_require__(54672);
/**
 * @ignore
 */
class DecoratorContext extends Map {
    constructor() {
        super(...arguments);
        this.actions = [];
    }
    addAction(cb) {
        this.actions.push(cb);
        return this;
    }
    build() {
        const decorator = (...args) => this.onInit(args, decorator);
        const wrap = (cb) => {
            return (...args) => {
                cb(...args);
                return decorator;
            };
        };
        const wrapKey = (key) => {
            return wrap((...values) => {
                key in this ? this[key](...values) : this.set(key, values[0]);
            });
        };
        this.methods.forEach((name) => {
            decorator[change_case_1.pascalCase(name)] = wrapKey(name);
        });
        return decorator;
    }
    toObject() {
        return [...this.entries()].reduce((obj, [key, value]) => {
            return {
                ...obj,
                [key]: value
            };
        }, {});
    }
    getMergedKey(key, defaultValue) {
        let value = this.get(key) || defaultValue;
        if (!value) {
            return;
        }
        if (this.decoratorType === core_1.DecoratorTypes.CLASS) {
            value = {
                ...value,
                ...(defaultValue || {})
            };
        }
        return {
            ...(defaultValue || {}),
            ...value
        };
    }
    runActions() {
        this.actions.forEach((action) => {
            action(this);
        });
        return this;
    }
}
exports.DecoratorContext = DecoratorContext;
//# sourceMappingURL=DecoratorContext.js.map

/***/ }),

/***/ 16668:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapAliasedProperties = void 0;
/**
 * @ignore
 */
function mapAliasedProperties(value, alias) {
    return Object.entries(value).reduce((properties, [key, value]) => {
        key = alias.get(key) || key;
        properties[key] = value;
        return properties;
    }, {});
}
exports.mapAliasedProperties = mapAliasedProperties;
//# sourceMappingURL=JsonAliasMap.js.map

/***/ }),

/***/ 28718:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonEntityStore = void 0;
const core_1 = __webpack_require__(92267);
const JsonOperation_1 = __webpack_require__(78634);
const JsonParameter_1 = __webpack_require__(93200);
const JsonSchema_1 = __webpack_require__(70676);
const getSchema = (type) => {
    if (core_1.isCollection(type) || !core_1.isClass(type)) {
        return JsonSchema_1.JsonSchema.from({
            type
        });
    }
    return JsonEntityStore.from(type).schema;
};
class JsonEntityStore extends core_1.Entity {
    constructor(options) {
        super(options);
        this.isStore = true;
        /**
         * List of children JsonEntityStore (properties or methods or params)
         */
        this.children = new Map();
        /**
         * Path used to generate open spec.
         */
        this.path = "/";
        this.store = options.store;
        /* istanbul ignore next */
        if (options.children) {
            this.children = options.children;
        }
        this.build();
    }
    /**
     * Return the JsonSchema
     */
    get schema() {
        return this._schema;
    }
    /**
     * Return the JsonOperation
     */
    get operation() {
        return this._operation;
    }
    /**
     * Return the JsonParameter
     */
    get parameter() {
        return this._parameter;
    }
    get nestedGenerics() {
        switch (this.decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                return this.parameter.nestedGenerics;
            default:
                return this.schema.nestedGenerics;
        }
    }
    set nestedGenerics(nestedGenerics) {
        switch (this.decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                this.parameter.nestedGenerics = nestedGenerics;
                break;
            default:
                this.schema.nestedGenerics = nestedGenerics;
                break;
        }
    }
    /**
     *
     * @returns {Type<any>}
     */
    get type() {
        return this._type;
    }
    /**
     * Get original type without transformation
     * @param value
     */
    set type(value) {
        this._type = value;
        this.build();
    }
    /**
     * Return the itemSchema computed type. if the type is a function used for recursive model, the function will be called to
     * get the right type.
     */
    get computedType() {
        return this.itemSchema.getComputedType();
    }
    get itemSchema() {
        return this.isCollection ? this.schema.itemSchema() : this.schema;
    }
    get parentSchema() {
        return this.parent.schema;
    }
    get parent() {
        const { target, propertyKey, decoratorType } = this;
        switch (decoratorType) {
            case core_1.DecoratorTypes.PARAM:
                return JsonEntityStore.fromMethod(target, propertyKey);
            case core_1.DecoratorTypes.METHOD:
            case core_1.DecoratorTypes.PROP:
                return JsonEntityStore.from(target);
        }
        return this;
    }
    /**
     * Return the required state.
     * @returns {boolean}
     */
    get required() {
        switch (this.decoratorType) {
            case core_1.DecoratorTypes.PROP:
                return this.parent.schema.isRequired(this.propertyKey);
            case core_1.DecoratorTypes.PARAM:
                return this.parameter.get("required");
        }
        return false;
    }
    /**
     * Change the state of the required data.
     * @param value
     */
    set required(value) {
        switch (this.decoratorType) {
            case core_1.DecoratorTypes.PROP:
                if (value) {
                    this.parent.schema.addRequired(this.propertyKey);
                }
                else {
                    this.parent.schema.removeRequired(this.propertyKey);
                }
                break;
            case core_1.DecoratorTypes.PARAM:
                this.parameter.required(value);
                break;
        }
    }
    get allowedRequiredValues() {
        return this.schema.$allow;
    }
    /**
     *
     * @param args
     */
    static from(...args) {
        const store = core_1.Store.from(...args);
        if (!store.has(JsonEntityStore)) {
            const entityStore = JsonEntityStore.entities.get(core_1.decoratorTypeOf(args)) || JsonEntityStore;
            const jsonSchemaStore = new entityStore({
                store,
                target: args[0],
                propertyKey: args[1],
                index: typeof args[2] === "number" ? args[2] : undefined,
                descriptor: typeof args[2] === "object" ? args[2] : undefined
            });
            store.set(JsonEntityStore, jsonSchemaStore);
        }
        return store.get(JsonEntityStore);
    }
    static fromMethod(target, propertyKey) {
        return this.from(target, propertyKey, core_1.descriptorOf(target, propertyKey));
    }
    getResponseOptions(contentType = "application/json") {
        var _a, _b;
        const media = (_b = (_a = this.operation) === null || _a === void 0 ? void 0 : _a.getResponseOf(this.statusCode)) === null || _b === void 0 ? void 0 : _b.getMedia(contentType, false);
        if (media && media.has("schema")) {
            const schema = media.get("schema");
            return { type: schema.getComputedItemType(), groups: media.groups };
        }
        return { type: this.type };
    }
    /**
     * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
     * @param value
     * @returns {boolean}
     */
    isRequired(value) {
        return this.required && [undefined, null, ""].includes(value) && !this.allowedRequiredValues.includes(value);
    }
    build() {
        if (!this._type) {
            let type;
            switch (this.decoratorType) {
                case core_1.DecoratorTypes.PARAM:
                    type = core_1.Metadata.getParamTypes(this.target, this.propertyKey)[this.index];
                    break;
                case core_1.DecoratorTypes.CLASS:
                    type = this.target;
                    break;
                case core_1.DecoratorTypes.PROP:
                    type = core_1.Metadata.getType(this.target, this.propertyKey);
                    break;
                case core_1.DecoratorTypes.METHOD:
                    type = core_1.Metadata.getReturnType(this.target, this.propertyKey);
                    type = core_1.isPromise(type) ? undefined : type;
                    break;
            }
            if (core_1.isCollection(type)) {
                this.collectionType = type;
            }
            else {
                this._type = type;
            }
        }
        this._type = this._type || Object;
        switch (this.decoratorType) {
            default:
                this._schema = JsonSchema_1.JsonSchema.from();
                break;
            case core_1.DecoratorTypes.CLASS:
                this._schema = JsonSchema_1.JsonSchema.from({
                    type: this.type
                });
                break;
            case core_1.DecoratorTypes.METHOD:
                this._operation = this.createOperation();
                break;
            case core_1.DecoratorTypes.PARAM:
                this._parameter = this.createParameter();
                break;
            case core_1.DecoratorTypes.PROP:
                this._schema = this.createProperty();
                break;
        }
    }
    createProperty() {
        const parentStore = this.parent;
        const properties = parentStore.schema.get("properties");
        let schema = properties[this.propertyName];
        if (!schema) {
            parentStore.children.set(this.propertyName, this);
            schema = JsonSchema_1.JsonSchema.from({
                type: this.collectionType || this.type
            });
            if (this.collectionType) {
                schema.itemSchema(this.type);
            }
        }
        parentStore.schema.addProperty(this.propertyName, schema);
        return schema;
    }
    createOperation() {
        const parentStore = this.parent;
        // response schema of the method
        let operation = this.operation;
        if (!operation) {
            operation = new JsonOperation_1.JsonOperation();
            parentStore.children.set(this.propertyName, this);
        }
        if (core_1.isCollection(this._type)) {
            this.collectionType = this._type;
            // @ts-ignore
            delete this._type;
        }
        this._schema = JsonSchema_1.JsonSchema.from({
            type: this.collectionType || this.type
        });
        if (this.collectionType) {
            this._schema.itemSchema(this.type);
        }
        parentStore.schema.addProperty(this.propertyName, this.schema);
        return operation;
    }
    createParameter() {
        var _a;
        const parentStore = this.parent;
        let parameter = this.parameter;
        if (!parameter) {
            parameter = new JsonParameter_1.JsonParameter();
            parentStore.children.set(this.index, this);
            this._schema = getSchema(this.collectionType || this.type);
            parameter.schema(this._schema);
            if (this.collectionType) {
                this._schema.itemSchema(getSchema(this.type));
            }
            (_a = parentStore.operation) === null || _a === void 0 ? void 0 : _a.addParameter(this.index, parameter);
        }
        return parameter;
    }
}
exports.JsonEntityStore = JsonEntityStore;
JsonEntityStore.entities = new Map();
//# sourceMappingURL=JsonEntityStore.js.map

/***/ }),

/***/ 46382:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonFormatTypes = void 0;
var JsonFormatTypes;
(function (JsonFormatTypes) {
    JsonFormatTypes["DATE_TIME"] = "date-time";
    JsonFormatTypes["DATE"] = "date";
    JsonFormatTypes["TIME"] = "time";
    JsonFormatTypes["EMAIL"] = "email";
    JsonFormatTypes["HOSTNAME"] = "hostname";
    JsonFormatTypes["IPV4"] = "ipv4";
    JsonFormatTypes["IPV6"] = "ipv6";
    JsonFormatTypes["URI"] = "uri";
    JsonFormatTypes["URL"] = "url";
    JsonFormatTypes["URI_REF"] = "uri-reference";
    JsonFormatTypes["URI_TEMPLATE"] = "uri-template";
    JsonFormatTypes["JSON_POINTER"] = "json-pointer";
    JsonFormatTypes["RELATIVE_JSON_POINTER"] = "relative-json-pointer";
    JsonFormatTypes["UUID"] = "uuid";
    JsonFormatTypes["REGEX"] = "regex";
})(JsonFormatTypes = exports.JsonFormatTypes || (exports.JsonFormatTypes = {}));
//# sourceMappingURL=JsonFormatTypes.js.map

/***/ }),

/***/ 28275:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonLazyRef = void 0;
const core_1 = __webpack_require__(92267);
const serializeJsonSchema_1 = __webpack_require__(34787);
const JsonEntityStore_1 = __webpack_require__(28718);
class JsonLazyRef {
    constructor(getType) {
        this.getType = getType;
    }
    get target() {
        return this.getType();
    }
    get schema() {
        return JsonEntityStore_1.JsonEntityStore.from(this.getType()).schema;
    }
    get name() {
        return core_1.nameOf(this.getType());
    }
    toJSON(options) {
        return this.getType() && serializeJsonSchema_1.serializeJsonSchema(this.schema, options);
    }
}
exports.JsonLazyRef = JsonLazyRef;
//# sourceMappingURL=JsonLazyRef.js.map

/***/ }),

/***/ 71196:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonMap = void 0;
const core_1 = __webpack_require__(92267);
const serializeJsonSchema_1 = __webpack_require__(34787);
class JsonMap extends Map {
    constructor(obj = {}) {
        super();
        this.assign(obj);
    }
    assign(obj = {}) {
        Object.entries(obj).forEach(([key, value]) => {
            if (core_1.isFunction(this[key])) {
                this[key](value);
            }
            else {
                this.set(key, value);
            }
        });
        return this;
    }
    toJSON(options = {}) {
        return serializeJsonSchema_1.serializeMap(this, options);
    }
}
exports.JsonMap = JsonMap;
//# sourceMappingURL=JsonMap.js.map

/***/ }),

/***/ 78634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonOperation = void 0;
const core_1 = __webpack_require__(92267);
const httpStatusMessages_1 = __webpack_require__(1755);
const isSuccessStatus_1 = __webpack_require__(84852);
const JsonMap_1 = __webpack_require__(71196);
const JsonParameterTypes_1 = __webpack_require__(70111);
const JsonRequestBody_1 = __webpack_require__(36999);
const JsonResponse_1 = __webpack_require__(20321);
const JsonSchema_1 = __webpack_require__(70676);
const SpecTypes_1 = __webpack_require__(89186);
class JsonOperation extends JsonMap_1.JsonMap {
    constructor(obj = {}) {
        super({ parameters: [], responses: new JsonMap_1.JsonMap(), ...obj });
        this.operationPaths = new Map();
    }
    get response() {
        return this.getResponses().get(this.getStatus().toString());
    }
    get status() {
        return this._status;
    }
    tags(tags) {
        super.set("tags", tags);
        return this;
    }
    addTags(tags) {
        tags = core_1.uniqBy([...(this.get("tags") || []), ...tags], "name");
        return this.tags(tags);
    }
    summary(summary) {
        super.set("summary", summary);
        return this;
    }
    operationId(operationId) {
        this.set("operationId", operationId);
        return this;
    }
    responses(responses) {
        this.set("responses", responses);
        return this;
    }
    defaultStatus(status) {
        this._status = status;
    }
    getStatus() {
        return this._status || 200;
    }
    addResponse(statusCode, response) {
        if (isSuccessStatus_1.isSuccessStatus(statusCode) && !this._status) {
            const res = this.getResponseOf(200);
            this.getResponses().set(statusCode.toString(), res).delete("200");
            this.defaultStatus(Number(statusCode));
        }
        const currentCode = statusCode === "default" ? this.getStatus().toString() : statusCode.toString();
        const currentResponse = this.getResponses().get(currentCode);
        if (!currentResponse) {
            response.status = Number(currentCode);
            this.getResponses().set(currentCode, response);
        }
        else {
            response.forEach((value, key) => {
                if (!["content"].includes(key)) {
                    currentResponse.set(key, core_1.deepMerge(currentResponse.get(key), value));
                }
            });
            currentResponse.status = Number(currentCode);
        }
        return this;
    }
    getResponses() {
        return this.get("responses");
    }
    getResponseOf(status) {
        return (status === "default" ? this.response : this.getResponses().get(String(status))) || new JsonResponse_1.JsonResponse();
    }
    ensureResponseOf(status) {
        this.addResponse(status, this.getResponseOf(status));
        return this.getResponseOf(status);
    }
    getHeadersOf(status) {
        return this.getResponseOf(status).get("headers") || {};
    }
    getContentTypeOf(status) {
        return [...this.getResponseOf(status).get("content").keys()].slice(-1)[0];
    }
    security(security) {
        this.set("security", security);
        return this;
    }
    addSecurityScopes(name, scopes) {
        const security = this.get("security") || {};
        security[name] = core_1.uniq([...(security[name] || []), ...scopes]);
        return this.security(security);
    }
    description(description) {
        super.set("description", description);
        return this;
    }
    deprecated(deprecated) {
        super.set("deprecated", deprecated);
        return this;
    }
    parameters(parameters) {
        super.set("parameters", parameters);
        return this;
    }
    addParameter(index, parameter) {
        if (index === -1) {
            index = this.get("parameters").length;
        }
        this.get("parameters")[index] = parameter;
    }
    consumes(consumes) {
        super.set("consumes", consumes);
        return this;
    }
    produces(produces) {
        super.set("produces", produces);
        return this;
    }
    addProduce(produce) {
        const produces = core_1.uniq([].concat(this.get("produces"), produce)).filter(Boolean);
        this.set("produces", produces);
    }
    addOperationPath(method, path, options = {}) {
        this.operationPaths.set(String(method) + String(path), {
            ...options,
            method,
            path
        });
        return this;
    }
    toJSON(options = {}) {
        const operation = super.toJSON({ ...options, ignore: ["parameters"] });
        const bodyParameters = [];
        const parameters = [];
        if (operation.security) {
            operation.security = [].concat(operation.security);
        }
        this.get("parameters").forEach((parameter) => {
            if (!JsonParameterTypes_1.isParameterType(this.get("in"))) {
                if (parameter.get("in")) {
                    if ([JsonParameterTypes_1.JsonParameterTypes.BODY, JsonParameterTypes_1.JsonParameterTypes.FILES].includes(parameter.get("in"))) {
                        bodyParameters.push(parameter);
                    }
                    else {
                        parameters.push(...[].concat(parameter.toJSON(options)));
                    }
                }
            }
        });
        operation.parameters = parameters.filter(Boolean);
        if (this.get("responses").size === 0) {
            operation.responses = {
                "200": {
                    description: httpStatusMessages_1.HTTP_STATUS_MESSAGES[200]
                }
            };
        }
        if (bodyParameters.length) {
            const parameter = buildSchemaFromBodyParameters(bodyParameters, options);
            if (options.specType === SpecTypes_1.SpecTypes.OPENAPI) {
                operation.requestBody = toRequestBody(this, parameter).toJSON(options);
            }
            else {
                operation.parameters.push(toJsonParameter(parameter));
            }
        }
        if (options.specType === SpecTypes_1.SpecTypes.OPENAPI) {
            delete operation.consumes;
            delete operation.produces;
        }
        return operation;
    }
}
exports.JsonOperation = JsonOperation;
function toRequestBody(operation, { schema, in: _, ...props }) {
    var _a;
    const requestBody = new JsonRequestBody_1.JsonRequestBody(props);
    const consumes = ((_a = operation.get("consumes")) === null || _a === void 0 ? void 0 : _a.length) ? operation.get("consumes") : ["application/json"];
    consumes.forEach((consume) => {
        requestBody.addContent(consume, schema);
    });
    return requestBody;
}
function toJsonParameter(parameter) {
    return {
        in: JsonParameterTypes_1.JsonParameterTypes.BODY,
        name: JsonParameterTypes_1.JsonParameterTypes.BODY,
        ...parameter
    };
}
function buildSchemaFromBodyParameters(parameters, options) {
    let schema = new JsonSchema_1.JsonSchema();
    const props = {};
    const refs = [];
    let propsLength = 0;
    parameters.forEach((parameter) => {
        const name = parameter.getName();
        Array.from(parameter.entries())
            .filter(([key]) => !["in", "name"].includes(key))
            .forEach(([key, value]) => {
            if (props[key] === undefined) {
                props[key] = value;
            }
        });
        const jsonParameter = parameter.toJSON(options);
        if (name) {
            schema.addProperty(name, jsonParameter.schema || {
                type: jsonParameter.type
            });
            if (parameter.get("required")) {
                schema.addRequired(name);
            }
            propsLength++;
        }
        else {
            refs.push(jsonParameter);
        }
    });
    if (propsLength) {
        schema.type("object");
        return { schema: schema.toJSON(options), required: false, ...props };
    }
    if (refs.length === 1) {
        return refs[0];
    }
    if (refs.length > 0) {
        schema.allOf(refs);
    }
    return { schema: schema.toJSON(options), required: false, ...props };
}
//# sourceMappingURL=JsonOperation.js.map

/***/ }),

/***/ 93200:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonParameter = void 0;
const core_1 = __webpack_require__(92267);
const generics_1 = __webpack_require__(98500);
const serializeJsonSchema_1 = __webpack_require__(34787);
const JsonMap_1 = __webpack_require__(71196);
const JsonParameterTypes_1 = __webpack_require__(70111);
const SpecTypes_1 = __webpack_require__(89186);
const IGNORE_OS2_PROPS = ["example", "examples", "title"];
class JsonParameter extends JsonMap_1.JsonMap {
    constructor() {
        super(...arguments);
        this.nestedGenerics = [];
    }
    getName() {
        const name = this.get("name");
        if (this.get("in") === "files") {
            return name.split(".")[0];
        }
        return name;
    }
    name(name) {
        this.set("name", name);
        return this;
    }
    description(description) {
        this.set("description", description);
        return this;
    }
    in(inType, expression = "") {
        this.set("in", JsonParameterTypes_1.formatParameterType(inType));
        this.expression = expression;
        return this;
    }
    required(required) {
        this.set("required", required);
        return this;
    }
    schema(schema) {
        this.$schema = schema;
        return this;
    }
    toJSON(options = {}) {
        if (!JsonParameterTypes_1.isParameterType(this.get("in"))) {
            return null;
        }
        const schemasContainer = core_1.toMap(options.schemas || {});
        return this.build({ ...options, groups: this.groups }, schemasContainer);
    }
    build(options, schemasContainer) {
        const { type, schema, ...parameter } = super.toJSON(options);
        const jsonSchema = serializeJsonSchema_1.serializeItem(this.$schema, {
            ...options,
            ...generics_1.popGenerics(this)
        });
        parameter.required = parameter.required || this.get("in") === JsonParameterTypes_1.JsonParameterTypes.PATH;
        if (this.get("in") === JsonParameterTypes_1.JsonParameterTypes.FILES) {
            const isOpenApi = options.specType === SpecTypes_1.SpecTypes.OPENAPI;
            const schema = {
                type: isOpenApi ? "string" : "file",
                format: isOpenApi ? "binary" : undefined,
                oneOf: undefined
            };
            if (jsonSchema.type === "array") {
                jsonSchema.items = core_1.cleanObject({
                    ...jsonSchema.items,
                    ...schema
                });
                parameter.schema = jsonSchema;
            }
            else {
                parameter.schema = core_1.cleanObject({
                    ...jsonSchema,
                    ...schema
                });
            }
            return parameter;
        }
        if (options.specType === SpecTypes_1.SpecTypes.OPENAPI) {
            if (["query"].includes(this.get("in")) && jsonSchema.$ref) {
                return this.refToParameters(parameter, options, schemasContainer);
            }
        }
        if (options.specType === SpecTypes_1.SpecTypes.SWAGGER) {
            if (!jsonSchema.$ref && Object.keys(jsonSchema).length === 1) {
                parameter.type = jsonSchema.type;
                return parameter;
            }
            if (["formData", "query"].includes(this.get("in"))) {
                if (jsonSchema.$ref) {
                    return this.refToParameters(parameter, options, schemasContainer);
                }
                if (jsonSchema.type === "array") {
                    const { minLength, ...props } = jsonSchema;
                    return core_1.cleanObject({
                        ...parameter,
                        ...props,
                        type: "array",
                        collectionFormat: "multi",
                        items: {
                            type: "string"
                        }
                    }, IGNORE_OS2_PROPS);
                }
            }
            if (this.get("in") !== "body") {
                return core_1.cleanObject({
                    ...parameter,
                    ...jsonSchema
                }, IGNORE_OS2_PROPS);
            }
        }
        parameter.schema = jsonSchema;
        return parameter;
    }
    refToParameters(parameter, options, schemasContainer) {
        const schema = options.schemas[this.$schema.getName()];
        if (options.schemas[this.$schema.getName()] && !schemasContainer.has(this.$schema.getName())) {
            delete options.schemas[this.$schema.getName()];
        }
        return Object.entries(schema.properties || {}).reduce((params, [key, { description, ...prop }]) => {
            if (options.specType === SpecTypes_1.SpecTypes.OPENAPI) {
                return [
                    ...params,
                    core_1.cleanObject({
                        ...parameter,
                        name: key,
                        required: (schema.required || []).includes(key),
                        description,
                        schema: prop
                    })
                ];
            }
            return [
                ...params,
                core_1.cleanObject({
                    ...parameter,
                    name: key,
                    required: (schema.required || []).includes(key),
                    description,
                    ...prop
                })
            ];
        }, []);
    }
}
exports.JsonParameter = JsonParameter;
//# sourceMappingURL=JsonParameter.js.map

/***/ }),

/***/ 70111:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isParameterType = exports.formatParameterType = exports.JsonParameterTypes = void 0;
var JsonParameterTypes;
(function (JsonParameterTypes) {
    JsonParameterTypes["BODY"] = "body";
    JsonParameterTypes["PATH"] = "path";
    JsonParameterTypes["QUERY"] = "query";
    JsonParameterTypes["HEADER"] = "header";
    JsonParameterTypes["COOKIES"] = "cookie";
    JsonParameterTypes["FILES"] = "files";
})(JsonParameterTypes = exports.JsonParameterTypes || (exports.JsonParameterTypes = {}));
/**
 * @ignore
 */
function formatParameterType(type) {
    return String(type).toLowerCase().replace("raw_", "").replace("cookies", "cookie");
}
exports.formatParameterType = formatParameterType;
/**
 * @ignore
 */
function isParameterType(type) {
    return Object.values(JsonParameterTypes).includes(formatParameterType(type));
}
exports.isParameterType = isParameterType;
//# sourceMappingURL=JsonParameterTypes.js.map

/***/ }),

/***/ 36999:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonRequestBody = void 0;
const toJsonMapCollection_1 = __webpack_require__(33423);
const JsonMap_1 = __webpack_require__(71196);
class JsonRequestBody extends JsonMap_1.JsonMap {
    constructor(obj = {}) {
        super(obj);
        this.content(obj.content || {});
    }
    description(description) {
        this.set("description", description);
        return this;
    }
    content(content) {
        this.set("content", toJsonMapCollection_1.toJsonMapCollection(content));
        return this;
    }
    addContent(mediaType, schema) {
        const content = this.get("content");
        const mediaContent = new JsonMap_1.JsonMap();
        mediaContent.set("schema", schema);
        content.set(mediaType, mediaContent);
        return this;
    }
    required(required) {
        this.set("required", required);
        return this;
    }
}
exports.JsonRequestBody = JsonRequestBody;
//# sourceMappingURL=JsonRequestBody.js.map

/***/ }),

/***/ 20321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonResponse = exports.JsonMedia = void 0;
const core_1 = __webpack_require__(92267);
const mapHeaders_1 = __webpack_require__(18532);
const toJsonMapCollection_1 = __webpack_require__(33423);
const JsonMap_1 = __webpack_require__(71196);
const SpecTypes_1 = __webpack_require__(89186);
class JsonMedia extends JsonMap_1.JsonMap {
    constructor() {
        super(...arguments);
        this.groups = [];
    }
    schema(schema) {
        this.set("schema", schema);
        return this;
    }
    examples(examples) {
        this.set("examples", examples);
        return this;
    }
    toJSON(options = {}) {
        return super.toJSON({ ...options, groups: this.groups });
    }
}
exports.JsonMedia = JsonMedia;
class JsonResponse extends JsonMap_1.JsonMap {
    constructor(obj = {}) {
        super(obj);
        this.content(obj.content || {});
    }
    description(description) {
        this.set("description", description);
        return this;
    }
    headers(headers) {
        this.set("headers", mapHeaders_1.mapHeaders(headers));
        return this;
    }
    content(content) {
        this.set("content", toJsonMapCollection_1.toJsonMapCollection(content, JsonMedia));
        return this;
    }
    getContent() {
        return this.get("content");
    }
    getMedia(mediaType, create = true) {
        var _a;
        create && this.addMedia(mediaType);
        return (_a = this.getContent()) === null || _a === void 0 ? void 0 : _a.get(mediaType);
    }
    addMedia(mediaType) {
        const content = this.get("content");
        if (!content.has(mediaType)) {
            content.set(mediaType, new JsonMedia());
        }
        return this;
    }
    toJSON(options = {}) {
        const response = super.toJSON(options);
        if (this.status === 204) {
            delete response.content;
        }
        if (options.specType === SpecTypes_1.SpecTypes.OPENAPI && response.headers) {
            Object.entries(response.headers).forEach(([key, { type, ...props }]) => {
                response.headers[key] = {
                    ...props,
                    schema: {
                        type
                    }
                };
            });
        }
        if (options.specType !== SpecTypes_1.SpecTypes.OPENAPI && response.content) {
            const key = Object.keys(response.content)[0];
            return core_1.cleanObject({
                ...response,
                ...response.content[key],
                content: undefined
            });
        }
        return response;
    }
}
exports.JsonResponse = JsonResponse;
//# sourceMappingURL=JsonResponse.js.map

/***/ }),

/***/ 70676:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsonSchema = void 0;
const core_1 = __webpack_require__(92267);
const getComputedType_1 = __webpack_require__(76120);
const getJsonType_1 = __webpack_require__(22759);
const mapToJsonSchema_1 = __webpack_require__(75043);
const serializeJsonSchema_1 = __webpack_require__(34787);
const toJsonRegex_1 = __webpack_require__(91701);
function mapProperties(properties) {
    // istanbul ignore next
    if (properties instanceof JsonSchema) {
        return properties;
    }
    return Object.entries(properties).reduce((properties, [key, schema]) => {
        properties[toJsonRegex_1.toJsonRegex(key)] = core_1.isArray(schema) ? schema.map(mapToJsonSchema_1.mapToJsonSchema) : mapToJsonSchema_1.mapToJsonSchema(schema);
        return properties;
    }, {});
}
class JsonSchema extends Map {
    // protected _specs: Map<SpecTypes, any> = new Map();
    constructor(obj = {}) {
        super();
        this.$hooks = new core_1.Hooks();
        this.$required = new Set();
        this.$allow = [];
        this.$forwardGroups = false;
        this._nullable = false;
        this._nestedGenerics = [];
        this._alias = new Map();
        this._isGeneric = false;
        this._isCollection = false;
        this._ref = false;
        if (obj) {
            this.assign(obj);
        }
    }
    get alias() {
        return this._alias;
    }
    get nestedGenerics() {
        return this._nestedGenerics;
    }
    set nestedGenerics(value) {
        this._nestedGenerics = value;
    }
    get genericLabels() {
        return this._genericLabels;
    }
    set genericLabels(value) {
        this._genericLabels = value;
    }
    get nullable() {
        return this._nullable || this.$allow.includes(null);
    }
    set nullable(value) {
        this._nullable = value;
    }
    get isClass() {
        return core_1.isClass(this.class) && ![Map, Array, Set, Object, Date, Boolean, Number, String].includes(this._target);
    }
    /**
     * Current schema is a collection
     */
    get isCollection() {
        return this._isCollection;
    }
    /**
     * Current schema is a generic
     */
    get isGeneric() {
        return this._isGeneric;
    }
    /**
     * Current schema has generics items
     */
    get hasGenerics() {
        return !!(this.nestedGenerics && this.nestedGenerics.length);
    }
    get genericType() {
        return this.get("$ref");
    }
    get class() {
        return this.getComputedType();
    }
    get canRef() {
        return this._ref;
    }
    static from(obj = {}) {
        return new JsonSchema(obj);
    }
    itemSchema(obj = {}) {
        this._itemSchema = this._itemSchema || mapToJsonSchema_1.mapToJsonSchema(obj);
        this._itemSchema.assign(obj);
        return this._itemSchema;
    }
    getAliasOf(property) {
        return this._alias.get(property);
    }
    addAlias(property, alias) {
        this._alias.set(property, alias);
        this._alias.set(alias, property);
        return this;
    }
    removeAlias(property) {
        const alias = this._alias.get(property);
        alias && this._alias.delete(alias);
        this._alias.delete(property);
        return this;
    }
    $id($id) {
        super.set("$id", $id);
        return this;
    }
    $ref($ref) {
        super.set("$ref", $ref);
        return this;
    }
    $schema($schema) {
        super.set("$schema", $schema);
        return this;
    }
    /**
     * Create a ref and use name to sharing schema
     * @param name
     */
    label(name) {
        this._ref = true;
        super.set("name", name);
        return this;
    }
    name(name) {
        super.set("name", name);
        return this;
    }
    ignore(cb) {
        if (typeof cb === "boolean") {
            const bool = cb;
            cb = () => bool;
        }
        this.$hooks.on("ignore", cb);
        return this;
    }
    /**
     * This keyword can be used to supply a default JSON value associated with a particular schema.
     * It is RECOMMENDED that a default value be valid against the associated schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.3
     */
    default(value) {
        super.set("default", value);
        return this;
    }
    /**
     * More readible form of a one-element "enum"
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.24
     */
    const(value) {
        super.set("const", value);
        return this;
    }
    /**
     * This attribute is a string that provides a full description of the of purpose the instance property.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
     */
    description(description) {
        super.set("description", description);
        return this;
    }
    /**
     * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
     * If "items" is an array of schemas, validation succeeds if every instance element
     * at a position greater than the size of "items" validates against "additionalItems".
     * Otherwise, "additionalItems" MUST be ignored, as the "items" schema
     * (possibly the default value of an empty schema) is applied to all elements.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.10
     */
    additionalItems(additionalItems) {
        super.set("additionalItems", mapToJsonSchema_1.mapToJsonSchema(additionalItems));
        return this;
    }
    /**
     * An array instance is valid against "contains" if at least one of its elements is valid against the given schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.14
     */
    contains(contains) {
        super.set("contains", mapToJsonSchema_1.mapToJsonSchema(contains));
        return this;
    }
    /**
     * Array of examples with no validation effect the value of "default" is usable as an example without repeating it under this keyword
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4
     */
    examples(examples) {
        super.set("examples", examples);
        return this;
    }
    /**
     * Array of examples with no validation effect the value of "default" is usable as an example without repeating it under this keyword
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4
     */
    example(...examples) {
        return this.examples(examples);
    }
    /**
     * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.9
     */
    items(items) {
        super.set("items", (this._itemSchema = mapToJsonSchema_1.mapToJsonSchema(items)));
        return this;
    }
    /**
     * Must be a non-negative integer.
     * An array instance is valid against "maxItems" if its size is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.11
     */
    maxItems(maxItems) {
        super.set("maxItems", maxItems);
        return this;
    }
    /**
     * Must be a non-negative integer.
     * An array instance is valid against "maxItems" if its size is greater than, or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.12
     */
    minItems(minItems) {
        super.set("minItems", minItems);
        return this;
    }
    /**
     * If this keyword has boolean value false, the instance validates successfully.
     * If it has boolean value true, the instance validates successfully if all of its elements are unique.
     * Omitting this keyword has the same behavior as a value of false.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.13
     */
    uniqueItems(uniqueItems) {
        super.set("uniqueItems", uniqueItems);
        return this;
    }
    /**
     * Must be a non-negative integer.
     * An object instance is valid against "maxProperties" if its number of properties is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.15
     */
    maxProperties(maxProperties) {
        super.set("maxProperties", maxProperties);
        return this;
    }
    /**
     * Must be a non-negative integer.
     * An object instance is valid against "maxProperties" if its number of properties is greater than,
     * or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.16
     */
    minProperties(minProperties) {
        super.set("minProperties", minProperties);
        return this;
    }
    allow(...allow) {
        this.$allow.push(...allow);
        return this;
    }
    /**
     * Elements of this array must be unique.
     * An object instance is valid against this keyword if every item in the array is the name of a property in the instance.
     * Omitting this keyword has the same behavior as an empty array.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.17
     */
    required(required = true) {
        if (core_1.isArray(required)) {
            this.$required.clear();
            required.forEach((value) => this.$required.add(value));
        }
        else {
            const schema = this.clone();
            schema.$selfRequired = required;
            return schema;
        }
        return this;
    }
    addRequired(property) {
        this.$required.add(property);
        return this;
    }
    removeRequired(property) {
        this.$required.delete(property);
        return this;
    }
    isRequired(property) {
        return this.$required.has(property);
    }
    /**
     * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.
     * Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value,
     * the child instance for that name successfully validates against the corresponding schema.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.18
     */
    properties(properties) {
        super.set("properties", mapProperties(properties));
        return this;
    }
    addProperty(key, schema) {
        const properties = this.get("properties") || {};
        properties[key] = schema;
        super.set("properties", mapProperties(properties));
        return this;
    }
    /**
     * This attribute is an object that defines the schema for a set of property names of an object instance.
     * The name of each property of this attribute's object is a regular expression pattern in the ECMA 262, while the value is a schema.
     * If the pattern matches the name of a property on the instance object, the value of the instance's property
     * MUST be valid against the pattern name's schema value.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.19
     */
    patternProperties(patternProperties) {
        super.set("patternProperties", mapProperties(patternProperties));
        return this;
    }
    /**
     * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.
     * If specified, the value MUST be a schema or a boolean.
     * If false is provided, no additional properties are allowed beyond the properties defined in the schema.
     * The default value is an empty schema which allows any value for additional properties.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20
     */
    additionalProperties(additionalProperties) {
        super.set("additionalProperties", mapToJsonSchema_1.mapToJsonSchema(additionalProperties));
        return this;
    }
    /**
     * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.
     * If specified, the value MUST be a schema or a boolean.
     * If false is provided, no additional properties are allowed beyond the properties defined in the schema.
     * The default value is an empty schema which allows any value for additional properties.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20
     * @alias additionalProperties
     * @param unknown
     */
    unknown(unknown = true) {
        return this.additionalProperties(unknown);
    }
    /**
     * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.
     * Each property specifies a dependency.
     * If the dependency value is an array, each element in the array must be unique.
     * Omitting this keyword has the same behavior as an empty object.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.21
     */
    dependencies(dependencies) {
        super.set("dependencies", mapProperties(dependencies));
        return this;
    }
    /**
     * Takes a schema which validates the names of all properties rather than their values.
     * Note the property name that the schema is testing will always be a string.
     * Omitting this keyword has the same behavior as an empty schema.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.22
     */
    propertyNames(propertyNames) {
        super.set("propertyNames", mapToJsonSchema_1.mapToJsonSchema(propertyNames));
        return this;
    }
    /**
     * This provides an enumeration of all possible values that are valid
     * for the instance property. This MUST be an array, and each item in
     * the array represents a possible value for the instance value. If
     * this attribute is defined, the instance value MUST be one of the
     * values in the array in order for the schema to be valid.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.23
     */
    enum(enumValues) {
        super.set("enum", core_1.uniq(enumValues));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.1
     */
    definitions(definitions) {
        super.set("definitions", mapProperties(definitions));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
     */
    allOf(allOf) {
        super.set("allOf", allOf.map(mapToJsonSchema_1.mapToJsonSchema));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
     */
    anyOf(anyOf) {
        super.set("anyOf", anyOf.map(mapToJsonSchema_1.mapToJsonSchema));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
     */
    oneOf(oneOf) {
        super.set("oneOf", oneOf.map(mapToJsonSchema_1.mapToJsonSchema));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.29
     */
    not(not) {
        super.set("not", mapToJsonSchema_1.mapToJsonSchema(not));
        return this;
    }
    /**
     * Must be strictly greater than 0.
     * A numeric instance is valid only if division by this keyword's value results in an integer.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.1
     */
    multipleOf(multipleOf) {
        super.set("multipleOf", multipleOf);
        return this;
    }
    /**
     * Representing an inclusive upper limit for a numeric instance.
     * This keyword validates only if the instance is less than or exactly equal to "maximum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.2
     */
    maximum(maximum) {
        super.set("maximum", maximum);
        return this;
    }
    /**
     * Representing an exclusive upper limit for a numeric instance.
     * This keyword validates only if the instance is strictly less than (not equal to) to "exclusiveMaximum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.3
     */
    exclusiveMaximum(exclusiveMaximum) {
        super.set("exclusiveMaximum", exclusiveMaximum);
        return this;
    }
    /**
     * Representing an inclusive lower limit for a numeric instance.
     * This keyword validates only if the instance is greater than or exactly equal to "minimum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.4
     */
    minimum(minimum) {
        super.set("minimum", minimum);
        return this;
    }
    /**
     * Representing an exclusive lower limit for a numeric instance.
     * This keyword validates only if the instance is strictly greater than (not equal to) to "exclusiveMinimum".
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.5
     */
    exclusiveMinimum(exclusiveMinimum) {
        super.set("exclusiveMinimum", exclusiveMinimum);
        return this;
    }
    /**
     * Must be a non-negative integer.
     * A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.6
     */
    maxLength(maxLength) {
        super.set("maxLength", maxLength);
        return this;
    }
    /**
     * Must be a non-negative integer.
     * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
     * Omitting this keyword has the same behavior as a value of 0.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.7
     */
    minLength(minLength) {
        super.set("minLength", minLength);
        return this;
    }
    /**
     * Should be a valid regular expression, according to the ECMA 262 regular expression dialect.
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.8
     */
    pattern(pattern) {
        super.set("pattern", toJsonRegex_1.toJsonRegex(pattern));
        return this;
    }
    /**
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8
     */
    format(format) {
        super.set("format", format);
        return this;
    }
    /**
     * A single type, or a union of simple types
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.25
     */
    type(type) {
        switch (type) {
            case Map:
                super.set("type", getJsonType_1.getJsonType(type));
                this._target = type;
                this._isCollection = true;
                if (!this.has("additionalProperties")) {
                    super.set("additionalProperties", this.itemSchema({}));
                }
                break;
            case Array:
                super.set("type", getJsonType_1.getJsonType(type));
                this._target = type;
                this._isCollection = true;
                if (!this.has("items")) {
                    super.set("items", this.itemSchema({}));
                }
                break;
            case Set:
                super.set("type", getJsonType_1.getJsonType(type));
                this._target = type;
                this._isCollection = true;
                this.uniqueItems(true);
                if (!this.has("items")) {
                    super.set("items", this.itemSchema({}));
                }
                break;
            case "integer":
                super.set("type", getJsonType_1.getJsonType(type));
                this.integer();
                break;
            case Object:
            case Date:
            case Boolean:
            case Number:
            case String:
                super.set("type", getJsonType_1.getJsonType(type));
                this._target = type;
                if (!this.has("properties")) {
                    super.set("properties", {});
                }
                break;
            default:
                if (core_1.isClass(type) || core_1.isFunction(type)) {
                    super.set("type", undefined);
                    this._target = type;
                    if (!this.has("properties")) {
                        super.set("properties", {});
                    }
                }
                else {
                    const jsonType = getJsonType_1.getJsonType(type);
                    if (jsonType === "generic") {
                        this._isGeneric = true;
                        super.set("$ref", type);
                    }
                    else {
                        super.set("type", jsonType);
                    }
                }
        }
        return this;
    }
    any(...types) {
        types = core_1.uniq(types.length ? types : ["integer", "number", "string", "boolean", "array", "object", "null"]).map(getJsonType_1.getJsonType);
        if (types.includes("null")) {
            this.nullable = true;
        }
        this.type(types.length === 1 ? types[0] : types);
        return this;
    }
    integer() {
        super.set("type", "integer");
        super.set("multipleOf", 1.0);
        return this;
    }
    /**
     * This attribute is a string that provides a short description of the instance property.
     *
     * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
     */
    title(title) {
        super.set("title", title);
        return this;
    }
    readOnly(readOnly) {
        super.set("readOnly", readOnly);
        return this;
    }
    writeOnly(readOnly) {
        super.set("writeOnly", readOnly);
        return this;
    }
    customKey(key, value) {
        super.set(`#${key}`, value);
        return this;
    }
    toObject(options) {
        return this.toJSON(options);
    }
    toJSON(options) {
        let addDef = false;
        if (!options) {
            addDef = true;
            options = { schemas: {} };
        }
        const schema = serializeJsonSchema_1.serializeJsonSchema(this, options);
        if (addDef && options.schemas && Object.keys(options.schemas).length) {
            schema.definitions = options.schemas;
        }
        return schema;
    }
    assign(obj = {}) {
        const entries = obj instanceof JsonSchema ? [...obj.entries()] : Object.entries(obj);
        entries.forEach(([key, value]) => {
            this.set(key, value);
        });
        if (obj instanceof JsonSchema) {
            this.$selfRequired = obj.$selfRequired;
            obj.$required.forEach((key) => {
                this.$required.add(key);
            });
            this._ref = obj._ref;
            this._alias = new Map(this._alias.entries());
            obj._genericLabels && (this._genericLabels = [...obj._genericLabels]);
            this._nestedGenerics = obj._nestedGenerics.map((item) => [...item]);
            this._target = obj._target;
            this._isGeneric = obj._isGeneric;
            this._isCollection = obj._isCollection;
            this._ref = obj._ref;
            super.set("type", obj.get("type"));
        }
        return this;
    }
    set(key, value) {
        if (key in this) {
            core_1.isFunction(this[key]) && this[key](value);
        }
        else {
            super.set(key, value);
        }
        return this;
    }
    /**
     * Return the itemSchema computed type.
     * If the type is a function used for recursive model,
     * the function will be called to get the right type.
     */
    getComputedType() {
        return getComputedType_1.getComputedType(this._target);
    }
    getComputedItemType() {
        return this._itemSchema ? this._itemSchema.getComputedType() : this.getComputedType();
    }
    /**
     * Return the Json type as string
     */
    getJsonType() {
        return this.get("type") || getJsonType_1.getJsonType(this.getComputedType());
    }
    getTarget() {
        return this._target;
    }
    /**
     * Get the symbolic name of the entity
     */
    getName() {
        return this.get("name") || (this._target ? core_1.nameOf(core_1.classOf(this.getComputedType())) : "");
    }
    clone() {
        return new JsonSchema(this);
    }
}
exports.JsonSchema = JsonSchema;
//# sourceMappingURL=JsonSchema.js.map

/***/ }),

/***/ 89186:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpecTypes = void 0;
var SpecTypes;
(function (SpecTypes) {
    SpecTypes["JSON"] = "jsonschema";
    SpecTypes["SWAGGER"] = "swagger2";
    SpecTypes["OPENAPI"] = "openapi3";
})(SpecTypes = exports.SpecTypes || (exports.SpecTypes = {}));
//# sourceMappingURL=SpecTypes.js.map

/***/ }),

/***/ 11277:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(28203);
tslib_1.__exportStar(__webpack_require__(71196), exports);
tslib_1.__exportStar(__webpack_require__(78634), exports);
tslib_1.__exportStar(__webpack_require__(93200), exports);
tslib_1.__exportStar(__webpack_require__(36999), exports);
tslib_1.__exportStar(__webpack_require__(20321), exports);
tslib_1.__exportStar(__webpack_require__(70676), exports);
tslib_1.__exportStar(__webpack_require__(46382), exports);
tslib_1.__exportStar(__webpack_require__(89186), exports);
tslib_1.__exportStar(__webpack_require__(28718), exports);
tslib_1.__exportStar(__webpack_require__(70111), exports);
tslib_1.__exportStar(__webpack_require__(28275), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54168:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.alterIgnore = void 0;
/**
 * @ignore
 * @param schema
 * @param options
 */
function alterIgnore(schema, options) {
    var _a, _b;
    let result = (_a = schema === null || schema === void 0 ? void 0 : schema.$hooks) === null || _a === void 0 ? void 0 : _a.alter("ignore", false, [options]);
    if (result) {
        return result;
    }
    if (options.groups !== false) {
        return (_b = schema === null || schema === void 0 ? void 0 : schema.$hooks) === null || _b === void 0 ? void 0 : _b.alter("groups", false, [options.groups]);
    }
    return result;
}
exports.alterIgnore = alterIgnore;
//# sourceMappingURL=alterIgnore.js.map

/***/ }),

/***/ 30021:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.alterRequiredGroups = void 0;
/**
 * @ignore
 */
function alterRequiredGroups(required, schema, options) {
    var _a;
    if (options.groups !== false) {
        return (_a = schema === null || schema === void 0 ? void 0 : schema.$hooks) === null || _a === void 0 ? void 0 : _a.alter("requiredGroups", required, [options.groups]);
    }
    return required;
}
exports.alterRequiredGroups = alterRequiredGroups;
//# sourceMappingURL=alterRequiredGroups.js.map

/***/ }),

/***/ 96804:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(28203);
tslib_1.__exportStar(__webpack_require__(1755), exports);
tslib_1.__exportStar(__webpack_require__(47432), exports);
tslib_1.__exportStar(__webpack_require__(22759), exports);
tslib_1.__exportStar(__webpack_require__(14725), exports);
tslib_1.__exportStar(__webpack_require__(18079), exports);
tslib_1.__exportStar(__webpack_require__(34167), exports);
tslib_1.__exportStar(__webpack_require__(81507), exports);
tslib_1.__exportStar(__webpack_require__(98500), exports);
tslib_1.__exportStar(__webpack_require__(18532), exports);
tslib_1.__exportStar(__webpack_require__(84852), exports);
tslib_1.__exportStar(__webpack_require__(91540), exports);
tslib_1.__exportStar(__webpack_require__(74466), exports);
tslib_1.__exportStar(__webpack_require__(11277), exports);
tslib_1.__exportStar(__webpack_require__(54168), exports);
tslib_1.__exportStar(__webpack_require__(86781), exports);
tslib_1.__exportStar(__webpack_require__(78245), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96347:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=IgnoreCallback.js.map

/***/ }),

/***/ 53657:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=JsonHookContext.js.map

/***/ }),

/***/ 60116:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=JsonOpenSpec.js.map

/***/ }),

/***/ 51311:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=JsonSchemaOptions.js.map

/***/ }),

/***/ 86781:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(28203);
tslib_1.__exportStar(__webpack_require__(51311), exports);
tslib_1.__exportStar(__webpack_require__(60116), exports);
tslib_1.__exportStar(__webpack_require__(96347), exports);
tslib_1.__exportStar(__webpack_require__(53657), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1096:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPath = void 0;
/**
 * Return a sanitized path
 * @param path
 * @ignore
 */
function buildPath(path) {
    return path.split("/").filter(Boolean).join("/");
}
exports.buildPath = buildPath;
//# sourceMappingURL=buildPath.js.map

/***/ }),

/***/ 63003:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concatParameters = void 0;
/**
 * @ignore
 */
function concatParameters(parameters, operation) {
    return parameters
        .map((param) => {
        const f = operation.parameters.find((p) => p.in === param.in && p.name === param.name);
        return f || param;
    })
        .concat(...operation.parameters.filter((param) => param.in !== "path"));
}
exports.concatParameters = concatParameters;
//# sourceMappingURL=concatParameters.js.map

/***/ }),

/***/ 40201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRef = exports.createRefName = void 0;
const change_case_1 = __webpack_require__(54672);
const SpecTypes_1 = __webpack_require__(89186);
/**
 * ignore
 * @param options
 */
function getHost(options) {
    const { host = `#/${options.specType === "openapi3" ? "components/schemas" : "definitions"}` } = options;
    return host;
}
/**
 * @ignore
 */
function createRefName(name, options) {
    if (options.groups && options.groups.length) {
        return change_case_1.pascalCase(`${name} ${options.groups.join(" ")}`);
    }
    return name;
}
exports.createRefName = createRefName;
/**
 * @ignore
 */
function createRef(name, schema, options) {
    const host = getHost(options);
    const ref = {
        $ref: `${host}/${name}`
    };
    if (schema.nullable) {
        switch (options.specType) {
            case SpecTypes_1.SpecTypes.OPENAPI:
                return {
                    nullable: true,
                    allOf: [ref]
                };
            case SpecTypes_1.SpecTypes.JSON:
                return {
                    oneOf: [{ type: "null" }, ref]
                };
            case SpecTypes_1.SpecTypes.SWAGGER: // unsupported
                break;
        }
    }
    return ref;
}
exports.createRef = createRef;
//# sourceMappingURL=createRef.js.map

/***/ }),

/***/ 74466:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStatusModel = exports.defineStatusModel = void 0;
const statusesModel = new Map();
function defineStatusModel(status, model) {
    statusesModel.set(status, model);
}
exports.defineStatusModel = defineStatusModel;
function getStatusModel(status) {
    return statusesModel.get(status);
}
exports.getStatusModel = getStatusModel;
//# sourceMappingURL=defineStatusModel.js.map

/***/ }),

/***/ 91540:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lazyRef = exports.allOf = exports.oneOf = exports.anyOf = exports.any = exports.object = exports.set = exports.map = exports.array = exports.url = exports.uri = exports.email = exports.time = exports.datetime = exports.date = exports.boolean = exports.string = exports.integer = exports.number = exports.from = void 0;
const core_1 = __webpack_require__(92267);
const domain_1 = __webpack_require__(11277);
const JsonLazyRef_1 = __webpack_require__(28275);
const JsonSchema_1 = __webpack_require__(70676);
/**
 * Create a new model from the given type.
 *
 * ```typescript
 * from(String)
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function from(type = Object) {
    if (core_1.isClass(type)) {
        const { schema } = domain_1.JsonEntityStore.from(type);
        schema.properties = function properties(obj) {
            Object.entries(obj).forEach(([propertyKey, propSchema]) => {
                domain_1.JsonEntityStore.from(type.prototype, propertyKey).schema.assign(propSchema);
            });
            return this;
        };
        return schema;
    }
    return JsonSchema_1.JsonSchema.from({ type });
}
exports.from = from;
/**
 * Declare a new number model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function number() {
    return from(Number);
}
exports.number = number;
/**
 * Declare a new integer model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function integer() {
    return from(Number).integer();
}
exports.integer = integer;
/**
 * Declare a new string model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function string() {
    return from(String);
}
exports.string = string;
/**
 * Declare a new boolean model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function boolean() {
    return from(Boolean);
}
exports.boolean = boolean;
/**
 * Declare a new string model with `format: date`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function date() {
    return from(Date).format(domain_1.JsonFormatTypes.DATE);
}
exports.date = date;
/**
 * Declare a new string model with `format: datetime`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function datetime() {
    return from(Date).format(domain_1.JsonFormatTypes.DATE_TIME);
}
exports.datetime = datetime;
/**
 * Declare a new string model with `format: time`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function time() {
    return from(Date).format(domain_1.JsonFormatTypes.TIME);
}
exports.time = time;
/**
 * Declare a new string model with `format: email`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function email() {
    return from(String).format(domain_1.JsonFormatTypes.EMAIL);
}
exports.email = email;
/**
 * Declare a new string model with `format: uri`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function uri() {
    return from(String).format(domain_1.JsonFormatTypes.URI);
}
exports.uri = uri;
/**
 * Declare a new string model with `format: url`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function url() {
    return from(String).format(domain_1.JsonFormatTypes.URL);
}
exports.url = url;
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "array"
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function array() {
    return from(Array);
}
exports.array = array;
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "object",
 *   "additionalProperties": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function map() {
    return from(Map).unknown(true);
}
exports.map = map;
/**
 * Declare a new array model with `uniqueItems: true`.
 *
 * ```json
 * {
 *   "type": "array",
 *   "uniqueItems": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function set() {
    return from(Array).uniqueItems(true);
}
exports.set = set;
/**
 * Declare a new object model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function object(properties = {}) {
    return from(Object).properties(properties);
}
exports.object = object;
/**
 * Declare a model with any type (By default: `integer`, `number`, `string`, `boolean`, `array`, `object`, `null`)
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */
function any(...types) {
    return from().any(...types);
}
exports.any = any;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 * @schemaFunctional
 */
function anyOf(...anyOf) {
    return from().anyOf(anyOf);
}
exports.anyOf = anyOf;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 */
function oneOf(...oneOf) {
    return from().oneOf(oneOf);
}
exports.oneOf = oneOf;
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 * @schemaFunctional
 */
function allOf(...allOf) {
    return from().allOf(allOf);
}
exports.allOf = allOf;
/**
 * Declare a sub schema which will be resolved later. Use this function when you have a circular reference between two schemes.
 *
 * @schemaFunctional
 */
function lazyRef(cb) {
    try {
        // solve issue with a self referenced model
        if (cb()) {
            // type is already accessible
            return domain_1.JsonEntityStore.from(cb()).schema;
        }
    }
    catch (er) { }
    return new JsonLazyRef_1.JsonLazyRef(cb);
}
exports.lazyRef = lazyRef;
//# sourceMappingURL=from.js.map

/***/ }),

/***/ 98500:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.popGenerics = exports.mapGenericsOptions = exports.getGenericsMap = void 0;
/**
 * @ignore
 * @param genericLabels
 * @param genericTypes
 */
function getGenericsMap(genericLabels, genericTypes) {
    return genericLabels.reduce((map, item, index) => map.set(item, genericTypes[index]), new Map());
}
exports.getGenericsMap = getGenericsMap;
/**
 * @ignore
 * @param options
 */
function mapGenericsOptions(options) {
    if (options.genericLabels && options.genericTypes) {
        const { genericLabels, genericTypes, ...ops } = options;
        return {
            ...ops,
            generics: getGenericsMap(genericLabels, genericTypes)
        };
    }
    return options;
}
exports.mapGenericsOptions = mapGenericsOptions;
/**
 * @ignore
 * @param value
 */
function popGenerics(value) {
    const [genericTypes, ...out] = value.nestedGenerics;
    return {
        genericTypes,
        nestedGenerics: out
    };
}
exports.popGenerics = popGenerics;
//# sourceMappingURL=generics.js.map

/***/ }),

/***/ 76120:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getComputedType = void 0;
const core_1 = __webpack_require__(92267);
/**
 * @ignore
 */
function getComputedType(target) {
    if (core_1.isPromise(target)) {
        return Object;
    }
    if (core_1.isClass(target) ||
        core_1.isSymbol(target) ||
        core_1.isPrimitiveOrPrimitiveClass(target) ||
        core_1.isClassObject(target) ||
        core_1.isDate(target) ||
        core_1.isCollection(target)) {
        return core_1.classOf(target);
    }
    if (core_1.isArrowFn(target)) {
        return target();
    }
    return target;
}
exports.getComputedType = getComputedType;
//# sourceMappingURL=getComputedType.js.map

/***/ }),

/***/ 17634:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInheritedStores = void 0;
const core_1 = __webpack_require__(92267);
const getJsonEntityStore_1 = __webpack_require__(45316);
/**
 * Return store and his inherited stores
 * @param target
 * @ignore
 */
function getInheritedStores(target) {
    const store = target.isStore ? target : getJsonEntityStore_1.getJsonEntityStore(target);
    if (!store.$inherited) {
        store.$inherited = core_1.ancestorsOf(store.target)
            .reverse()
            .reduce((context, model) => {
            return context.set(model, getJsonEntityStore_1.getJsonEntityStore(model));
        }, new Map());
    }
    return store.$inherited;
}
exports.getInheritedStores = getInheritedStores;
//# sourceMappingURL=getInheritedStores.js.map

/***/ }),

/***/ 45316:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJsonEntityStore = void 0;
/**
 * Proxy to avoid circular ref
 * @param target
 * @ignore
 */
function getJsonEntityStore(target) {
    return (__webpack_require__(28718).JsonEntityStore.from)(target);
}
exports.getJsonEntityStore = getJsonEntityStore;
//# sourceMappingURL=getJsonEntityStore.js.map

/***/ }),

/***/ 67936:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJsonPathParameters = void 0;
/**
 * @ignore
 */
function getVariable(subpath) {
    const [prefix, right] = subpath.split("=");
    const splited = (right || prefix).split(".");
    const name = splited.splice(0, 1)[0];
    return {
        prefix: right && prefix ? `${prefix}=` : "",
        name,
        postfix: splited.length ? `.${splited.join(".")}` : ""
    };
}
/**
 * @ignore
 */
function getJsonPathParameters(base, path = "") {
    if (path instanceof RegExp) {
        path = path.toString().replace(/^\//, "").replace(/\/$/, "").replace(/\\/, "");
    }
    const params = [];
    const paths = [];
    let isOptional = false;
    let current = "";
    `${base}${path}`
        .replace(/\((.*)\)/gi, "")
        .split("/")
        .filter((o) => !!o)
        .map((key) => {
        const subpath = key.replace(":", "").replace("?", "");
        if (key.includes(":")) {
            const optional = key.includes("?");
            // Append previous config
            if (optional && !isOptional) {
                isOptional = true;
                paths.push({
                    path: current,
                    parameters: [].concat(params)
                });
            }
            const { prefix, name, postfix } = getVariable(subpath);
            current += `/${prefix}{${name}}${postfix}`;
            params.push({
                in: "path",
                name,
                type: "string",
                required: true
            });
            if (optional && isOptional) {
                paths.push({
                    path: current,
                    parameters: [].concat(params)
                });
            }
        }
        else {
            current += `/${key}`;
        }
    });
    return paths.length
        ? paths
        : [
            {
                path: current,
                parameters: [].concat(params)
            }
        ];
}
exports.getJsonPathParameters = getJsonPathParameters;
//# sourceMappingURL=getJsonPathParameters.js.map

/***/ }),

/***/ 47432:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJsonSchema = void 0;
const JsonEntityStore_1 = __webpack_require__(28718);
const SpecTypes_1 = __webpack_require__(89186);
const serializeJsonSchema_1 = __webpack_require__(34787);
/**
 * @ignore
 */
const CACHE_KEY = "$cache:schemes";
/**
 * @ignore
 */
function getKey(options) {
    return JSON.stringify(options);
}
/**
 * @ignore
 */
function get(entity, options) {
    const cache = entity.store.get(CACHE_KEY) || new Map();
    const key = getKey(options);
    if (!cache.has(key)) {
        const schema = serializeJsonSchema_1.serializeJsonSchema(entity.schema, options);
        if (Object.keys(options.schemas).length) {
            schema.definitions = options.schemas;
        }
        cache.set(key, schema);
    }
    entity.store.set(CACHE_KEY, cache);
    return cache.get(key);
}
function getJsonSchema(model, options = {}) {
    options = {
        endpoint: true,
        groups: [],
        ...options,
        specType: options.specType || SpecTypes_1.SpecTypes.JSON,
        schemas: {}
    };
    const entity = model instanceof JsonEntityStore_1.JsonEntityStore ? model : JsonEntityStore_1.JsonEntityStore.from(model);
    return get(entity, options);
}
exports.getJsonSchema = getJsonSchema;
//# sourceMappingURL=getJsonSchema.js.map

/***/ }),

/***/ 22759:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getJsonType = exports.JSON_TYPES = void 0;
const core_1 = __webpack_require__(92267);
/**
 * @ignore
 */
exports.JSON_TYPES = ["string", "number", "integer", "boolean", "object", "array", "null", "any"];
function getJsonType(value) {
    if (value === null) {
        return "null";
    }
    if (core_1.isPrimitiveOrPrimitiveClass(value)) {
        if (exports.JSON_TYPES.indexOf(value) > -1) {
            return value;
        }
        if (typeof value === "string") {
            if (value === "file") {
                return "file";
            }
            return "generic";
        }
        return core_1.primitiveOf(value);
    }
    if (value === Array) {
        return "array";
    }
    if (core_1.isArray(value)) {
        return value.map(getJsonType);
    }
    if (value === Set) {
        return "array";
    }
    if (core_1.isDate(value)) {
        return "string";
    }
    return "object";
}
exports.getJsonType = getJsonType;
//# sourceMappingURL=getJsonType.js.map

/***/ }),

/***/ 18079:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOperationsStores = void 0;
const getInheritedStores_1 = __webpack_require__(17634);
const getJsonEntityStore_1 = __webpack_require__(45316);
/**
 * @ignore
 */
function getOperationsStores(target) {
    const store = target.isStore ? target : getJsonEntityStore_1.getJsonEntityStore(target);
    if (!store.$operations) {
        const stores = getInheritedStores_1.getInheritedStores(store);
        store.$operations = new Map();
        stores.forEach((currentStore) => {
            currentStore.children.forEach((propStore) => {
                if (propStore.operation && !store.$operations.has(propStore.propertyKey)) {
                    store.$operations.set(propStore.propertyKey, propStore);
                }
            });
        });
    }
    return store.$operations;
}
exports.getOperationsStores = getOperationsStores;
//# sourceMappingURL=getOperationsStores.js.map

/***/ }),

/***/ 14725:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProperties = exports.getPropertiesStores = void 0;
const alterIgnore_1 = __webpack_require__(54168);
const getInheritedStores_1 = __webpack_require__(17634);
const getJsonEntityStore_1 = __webpack_require__(45316);
/**
 * Return the list of properties including properties from inherited classes
 * @param target
 * @ignore
 */
function getPropertiesStores(target) {
    const store = target.isStore ? target : getJsonEntityStore_1.getJsonEntityStore(target);
    if (!store.$properties) {
        const stores = getInheritedStores_1.getInheritedStores(store);
        store.$properties = new Map();
        stores.forEach((currentStore) => {
            currentStore.children.forEach((propStore) => {
                if (!store.$properties.has(propStore.propertyKey)) {
                    store.$properties.set(propStore.propertyKey, propStore);
                }
            });
        });
    }
    return store.$properties;
}
exports.getPropertiesStores = getPropertiesStores;
/**
 * @ignore
 */
function getProperties(target, options = {}) {
    const stores = getPropertiesStores(target);
    const map = new Map();
    stores.forEach((store, key) => {
        if (!options.withIgnoredProps) {
            if (alterIgnore_1.alterIgnore(store.itemSchema, options)) {
                return;
            }
        }
        map.set(key, store);
    });
    return map;
}
exports.getProperties = getProperties;
//# sourceMappingURL=getPropertiesStores.js.map

/***/ }),

/***/ 76679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRequiredProperties = void 0;
const core_1 = __webpack_require__(92267);
const alterRequiredGroups_1 = __webpack_require__(30021);
function applyStringRule(obj, propSchema) {
    if (!(propSchema === null || propSchema === void 0 ? void 0 : propSchema.$allow.includes(""))) {
        if ([].concat(propSchema === null || propSchema === void 0 ? void 0 : propSchema.get("type")).includes("string")) {
            const minLength = obj === null || obj === void 0 ? void 0 : obj.minLength;
            // Disallow empty string
            if (minLength === undefined) {
                return {
                    ...obj,
                    minLength: 1
                };
            }
        }
    }
    return obj;
}
function mapRequiredProps(obj, schema, options = {}) {
    const { useAlias } = options;
    const props = Object.keys(obj.properties || {});
    return (keys, key) => {
        const aliasedKey = useAlias ? schema.alias.get(key) || key : key;
        if (props.includes(aliasedKey)) {
            const propSchema = schema.get("properties")[key];
            const serializeSchema = obj.properties[aliasedKey];
            obj.properties[aliasedKey] = applyStringRule(serializeSchema, propSchema); // applyNullRule(applyStringRule(serializeSchema, propSchema), propSchema);
            // obj.properties[aliasedKey] = mapNullableType(obj.properties[aliasedKey]);
            return keys.concat(aliasedKey);
        }
        return keys;
    };
}
function extractRequiredProps(obj, schema, options) {
    let required = obj.required || [];
    required = [...required, ...schema.$required];
    if (schema.get("properties")) {
        required = Object.entries(schema.get("properties")).reduce((required, [key, prop]) => {
            if (prop && prop.$selfRequired !== undefined) {
                return prop.$selfRequired ? required.concat(key) : required.filter((k) => k === key);
            }
            return required;
        }, required);
    }
    return alterRequiredGroups_1.alterRequiredGroups(core_1.uniq(required), schema, options);
}
/**
 * @ignore
 */
function getRequiredProperties(obj, schema, options) {
    if (options.groups && options.groups.includes("partial")) {
        return obj;
    }
    let required = extractRequiredProps(obj, schema, options);
    required = core_1.uniq(required).reduce(mapRequiredProps(obj, schema, options), []);
    if (required.length) {
        return {
            ...obj,
            required
        };
    }
    return obj;
}
exports.getRequiredProperties = getRequiredProperties;
//# sourceMappingURL=getRequiredProperties.js.map

/***/ }),

/***/ 34167:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSpec = void 0;
const core_1 = __webpack_require__(92267);
const JsonEntityStore_1 = __webpack_require__(28718);
const SpecTypes_1 = __webpack_require__(89186);
const buildPath_1 = __webpack_require__(1096);
const getOperationsStores_1 = __webpack_require__(18079);
const mergeOperation_1 = __webpack_require__(8338);
const operationIdFormatter_1 = __webpack_require__(17227);
/**
 * @ignore
 */
const caches = new Map();
/**
 * @ignore
 */
function get(model, options, cb) {
    if (!caches.has(model)) {
        caches.set(model, new Map());
    }
    const cache = caches.get(model);
    const key = JSON.stringify(options);
    if (!cache.has(key)) {
        cache.set(key, cb());
    }
    return cache.get(key);
}
/**
 * Return the swagger or open spec for the given class.
 * @param model
 * @param options
 */
function getSpec(model, options = { specType: SpecTypes_1.SpecTypes.SWAGGER }) {
    if (!options.specType) {
        options.specType = SpecTypes_1.SpecTypes.SWAGGER;
    }
    options = {
        ...options,
        operationIdFormatter: options.operationIdFormatter || operationIdFormatter_1.operationIdFormatter(options.operationIdPattern),
        root: false,
        specType: options.specType
    };
    return get(model, options, () => {
        const store = JsonEntityStore_1.JsonEntityStore.from(model);
        const { specType = SpecTypes_1.SpecTypes.SWAGGER, schemas = {}, paths = {}, rootPath = "/", tags = [] } = options;
        const ctrlPath = store.path;
        const defaultTags = core_1.cleanObject({
            name: store.schema.getName(),
            description: store.schema.get("description")
        });
        const specJson = { paths };
        getOperationsStores_1.getOperationsStores(model).forEach((operationStore) => {
            if (operationStore.store.get("hidden")) {
                return;
            }
            const operation = operationStore.operation.toJSON({ ...options, specType, schemas });
            operationStore.operation.operationPaths.forEach(({ path, method }) => {
                if (method) {
                    mergeOperation_1.mergeOperation(specJson, operation, {
                        rootPath: buildPath_1.buildPath(rootPath + ctrlPath),
                        path,
                        method,
                        defaultTags,
                        tags,
                        specType,
                        operationId: (path) => options.operationIdFormatter(operationStore.parent.schema.get("name") || operationStore.parent.targetName, operationStore.propertyName, path)
                    });
                }
            });
        });
        specJson.tags = core_1.uniqBy(tags, "name");
        if (Object.keys(schemas).length) {
            if (specType === SpecTypes_1.SpecTypes.OPENAPI) {
                specJson.components = {
                    schemas
                };
            }
            else {
                specJson.definitions = schemas;
            }
        }
        return specJson;
    });
}
exports.getSpec = getSpec;
//# sourceMappingURL=getSpec.js.map

/***/ }),

/***/ 84852:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSuccessStatus = void 0;
const isSuccessStatus = (code) => Number(code) && 200 <= Number(code) && Number(code) < 300;
exports.isSuccessStatus = isSuccessStatus;
//# sourceMappingURL=isSuccessStatus.js.map

/***/ }),

/***/ 18532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapHeaders = void 0;
const core_1 = __webpack_require__(92267);
/**
 * Map input header to a standard open spec header
 * @param headers
 * @ignore
 */
function mapHeaders(headers) {
    return Object.keys(headers).reduce((newHeaders, key) => {
        const value = headers[key];
        let type = typeof value;
        let options = {
            example: value
        };
        if (type === "object") {
            options = value;
            options.example = options.value === undefined ? options.example : options.value;
            delete options.value;
            type = typeof options.example;
        }
        options.type = options.type || type;
        newHeaders[key] = core_1.cleanObject(options);
        return newHeaders;
    }, {});
}
exports.mapHeaders = mapHeaders;
//# sourceMappingURL=mapHeaders.js.map

/***/ }),

/***/ 41661:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapNullableType = void 0;
const core_1 = __webpack_require__(92267);
const SpecTypes_1 = __webpack_require__(89186);
function mapNullableType(obj, schema, options) {
    if (!schema.nullable) {
        return obj;
    }
    let types = [].concat(obj.type).filter((type) => type !== "null");
    switch (options.specType) {
        case SpecTypes_1.SpecTypes.SWAGGER:
        case SpecTypes_1.SpecTypes.JSON:
            obj.type = ["null", ...types];
            break;
        case SpecTypes_1.SpecTypes.OPENAPI:
            if (types.length > 1) {
                obj.oneOf = types.map((type) => {
                    return core_1.cleanObject({ type, nullable: true });
                }, []);
            }
            else {
                obj.type = types[0];
                obj.nullable = true;
            }
    }
    return obj;
}
exports.mapNullableType = mapNullableType;
//# sourceMappingURL=mapNullableType.js.map

/***/ }),

/***/ 75043:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToJsonSchema = void 0;
const core_1 = __webpack_require__(92267);
const JsonEntityStore_1 = __webpack_require__(28718);
const JsonLazyRef_1 = __webpack_require__(28275);
const JsonSchema_1 = __webpack_require__(70676);
function mapToJsonSchema(item) {
    if (core_1.isArray(item)) {
        return item.map(mapToJsonSchema);
    }
    if (item instanceof JsonEntityStore_1.JsonEntityStore || item instanceof JsonSchema_1.JsonSchema || item instanceof JsonLazyRef_1.JsonLazyRef) {
        return item;
    }
    if (core_1.classOf(item) !== Object && core_1.isClass(item)) {
        return JsonEntityStore_1.JsonEntityStore.from(item).schema;
    }
    if (core_1.isObject(item)) {
        return JsonSchema_1.JsonSchema.from(item);
    }
    return item;
}
exports.mapToJsonSchema = mapToJsonSchema;
//# sourceMappingURL=mapToJsonSchema.js.map

/***/ }),

/***/ 46517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchGroups = void 0;
const tslib_1 = __webpack_require__(28203);
const micromatch_1 = tslib_1.__importDefault(__webpack_require__(87213));
/**
 * @ignore
 */
function matchGroups(groups, compareWith = []) {
    const groupsExcludes = groups.filter((group) => group.startsWith("!")).map((group) => group.replace("!", ""));
    const groupsIncludes = groups.filter((group) => !group.startsWith("!"));
    if (groupsExcludes.length) {
        if (compareWith.length && micromatch_1.default(groupsExcludes, compareWith).length) {
            return true;
        }
    }
    if (groupsIncludes.length) {
        return !micromatch_1.default(groups.filter((group) => !group.startsWith("!")), compareWith).length;
    }
    return false;
}
exports.matchGroups = matchGroups;
//# sourceMappingURL=matchGroups.js.map

/***/ }),

/***/ 8338:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeOperation = void 0;
const SpecTypes_1 = __webpack_require__(89186);
const concatParameters_1 = __webpack_require__(63003);
const getJsonPathParameters_1 = __webpack_require__(67936);
/**
 * @ignore
 */
function mergeOperation(obj, operation, { rootPath, specType, operationId, defaultTags, tags, path, method }) {
    const pathParameters = getJsonPathParameters_1.getJsonPathParameters(rootPath, path).map(({ path, parameters }) => {
        path = path ? path : "/";
        if (specType === SpecTypes_1.SpecTypes.OPENAPI) {
            parameters = parameters.map(({ type, ...param }) => {
                return {
                    ...param,
                    schema: {
                        type
                    }
                };
            });
        }
        return { path, parameters };
    });
    return pathParameters.reduce((obj, { path, parameters }) => {
        var _a;
        parameters = concatParameters_1.concatParameters(parameters, operation);
        path = path ? path : "/";
        const operationTags = ((_a = operation.tags) === null || _a === void 0 ? void 0 : _a.length) ? operation.tags : [defaultTags];
        obj.paths[path] = {
            ...obj.paths[path],
            [method.toLowerCase()]: {
                operationId: operation.operationId || operationId(path),
                ...operation,
                tags: operationTags.map(({ name }) => name),
                parameters
            }
        };
        tags.push(...operationTags);
        return obj;
    }, obj);
}
exports.mergeOperation = mergeOperation;
//# sourceMappingURL=mergeOperation.js.map

/***/ }),

/***/ 81507:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeSpec = exports.tagsReducer = exports.security = exports.parameters = exports.schemesReducer = void 0;
const core_1 = __webpack_require__(92267);
/**
 * @ignore
 */
exports.schemesReducer = core_1.mergeReducerBuilder((current, value) => (current.type && current.type === value.type) || (current.$ref && current.$ref === value.$ref));
/**
 * @ignore
 */
exports.parameters = core_1.mergeReducerBuilder((current, value) => current.in === value.in && current.name === value.name);
/**
 * @ignore
 */
exports.security = core_1.mergeReducerBuilder((current, value) => {
    return !!Object.keys(value).find((key) => !!current[key]);
});
/**
 * @ignore
 */
exports.tagsReducer = core_1.mergeReducerBuilder((current, value) => current.name === value.name);
/**
 * @ignore
 */
const SPEC_REDUCERS = {
    security: exports.security,
    parameters: exports.parameters,
    oneOf: exports.schemesReducer,
    anyOf: exports.schemesReducer,
    allOf: exports.schemesReducer,
    tags: exports.tagsReducer
};
/**
 * Merge two spec
 * @param spec
 * @param input
 */
function mergeSpec(spec, input) {
    return core_1.cleanObject(core_1.deepMerge(spec, input, {
        reducers: SPEC_REDUCERS
    }));
}
exports.mergeSpec = mergeSpec;
//# sourceMappingURL=mergeSpec.js.map

/***/ }),

/***/ 17227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.operationIdFormatter = void 0;
const change_case_1 = __webpack_require__(54672);
const DEFAULT_PATTERN = "%c.%m";
/**
 * @ignore
 */
function operationIdFormatter(pattern = "") {
    const OPERATION_IDS = new Map();
    const transform = (name, propertyKey) => {
        const str = (pattern || DEFAULT_PATTERN).replace(/%c/, name).replace(/%m/, propertyKey);
        return pattern === "" ? change_case_1.camelCase(str) : str;
    };
    return (name, propertyKey, path = "") => {
        const operationId = transform(name, propertyKey);
        const operationKey = name + propertyKey;
        if (!OPERATION_IDS.has(operationKey)) {
            OPERATION_IDS.set(operationKey, 0);
            return operationId;
        }
        // try with paths
        const result = path.match(/{(\w+)}/gi);
        if (result) {
            const operationKey = name + propertyKey + result[0];
            if (!OPERATION_IDS.has(operationKey)) {
                OPERATION_IDS.set(operationKey, 0);
                return change_case_1.camelCase(`${operationId} By ${result}`);
            }
        }
        const id = OPERATION_IDS.get(operationKey) + 1;
        OPERATION_IDS.set(operationKey, id);
        return `${operationId}_${id}`;
    };
}
exports.operationIdFormatter = operationIdFormatter;
//# sourceMappingURL=operationIdFormatter.js.map

/***/ }),

/***/ 34787:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeJsonSchema = exports.serializeGenerics = exports.serializeAny = exports.serializeLazyRef = exports.serializeObject = exports.serializeMap = exports.serializeInherited = exports.serializeItem = exports.serializeClass = void 0;
const core_1 = __webpack_require__(92267);
const getJsonType_1 = __webpack_require__(22759);
const JsonAliasMap_1 = __webpack_require__(16668);
const JsonLazyRef_1 = __webpack_require__(28275);
const SpecTypes_1 = __webpack_require__(89186);
const alterIgnore_1 = __webpack_require__(54168);
const createRef_1 = __webpack_require__(40201);
const generics_1 = __webpack_require__(98500);
const getInheritedStores_1 = __webpack_require__(17634);
const getJsonEntityStore_1 = __webpack_require__(45316);
const getRequiredProperties_1 = __webpack_require__(76679);
const mapNullableType_1 = __webpack_require__(41661);
/**
 * @ignore
 */
const IGNORES = ["name", "$required", "$hooks", "_nestedGenerics", SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER, SpecTypes_1.SpecTypes.JSON];
/**
 * @ignore
 */
const IGNORES_OPENSPEC = ["const"];
const IGNORES_OS2 = ["writeOnly", "readOnly"];
/**
 * @ignore
 */
function isEmptyProperties(key, value) {
    return typeof value === "object" && ["items", "properties", "additionalProperties"].includes(key) && Object.keys(value).length === 0;
}
/**
 * @ignore
 */
function shouldMapAlias(key, value, useAlias) {
    return typeof value === "object" && useAlias && ["properties", "additionalProperties"].includes(key);
}
/**
 * @ignore
 */
function serializeClass(value, options = {}) {
    const store = getJsonEntityStore_1.getJsonEntityStore(value.class);
    const name = createRef_1.createRefName(store.schema.getName() || value.getName(), options);
    if (value.hasGenerics) {
        // Inline generic
        const { type, properties, additionalProperties, items, ...props } = value.toJSON(options);
        const schema = {
            ...serializeAny(store.schema, {
                ...options,
                ...generics_1.popGenerics(value),
                root: false
            }),
            ...props
        };
        if (schema.title) {
            const name = createRef_1.createRefName(schema.title, options);
            options.schemas[name] = schema;
            delete schema.title;
            return createRef_1.createRef(name, value, options);
        }
        return schema;
    }
    if (options.schemas && !options.schemas[name]) {
        options.schemas[name] = {}; // avoid infinite calls
        options.schemas[name] = serializeAny(store.schema, generics_1.mapGenericsOptions({
            ...options,
            root: false
        }));
    }
    return createRef_1.createRef(name, value, options);
}
exports.serializeClass = serializeClass;
/**
 * @ignore
 */
function toRef(value, schema, options) {
    const name = createRef_1.createRefName(value.getName(), options);
    options.schemas[value.getName()] = schema;
    return createRef_1.createRef(name, value, options);
}
/**
 * @ignore
 */
function serializeItem(value, options) {
    return value && value.isClass ? serializeClass(value, options) : serializeAny(value, options);
}
exports.serializeItem = serializeItem;
/**
 * @ignore
 */
function serializeInherited(obj, target, options = {}) {
    const stores = Array.from(getInheritedStores_1.getInheritedStores(target).entries()).filter(([model]) => core_1.classOf(model) !== core_1.classOf(target));
    if (stores.length) {
        const schema = stores.reduce((obj, [, store]) => {
            return core_1.deepMerge(obj, serializeJsonSchema(store.schema, options));
        }, {});
        obj = core_1.deepMerge(schema, obj);
    }
    return obj;
}
exports.serializeInherited = serializeInherited;
/**
 * Serialize class which inherit from Map like JsonMap, JsonOperation, JsonParameter.
 * @param input
 * @param ignore
 * @param options
 * @ignore
 */
function serializeMap(input, { ignore = [], ...options } = {}) {
    options = generics_1.mapGenericsOptions(options);
    return Array.from(input.entries()).reduce((obj, [key, value]) => {
        if (ignore.includes(key)) {
            return obj;
        }
        obj[key] = serializeItem(value, options);
        return obj;
    }, {});
}
exports.serializeMap = serializeMap;
/**
 * Serialize Any object to a json schema
 * @param input
 * @param options
 * @ignore
 */
function serializeObject(input, options) {
    const { specType, operationIdFormatter, root, schemas, genericTypes, nestedGenerics, useAlias, genericLabels, ...ctx } = options;
    return Object.entries(input).reduce((obj, [key, value]) => {
        if (options.withIgnoredProps !== false && !alterIgnore_1.alterIgnore(value, ctx)) {
            // remove groups to avoid bad schema generation over children models
            obj[key] = serializeItem(value, { ...options, groups: (value === null || value === void 0 ? void 0 : value.$forwardGroups) ? options.groups : undefined });
        }
        return obj;
    }, core_1.isArray(input) ? [] : {});
}
exports.serializeObject = serializeObject;
/**
 * @ignore
 */
function serializeLazyRef(input, options) {
    var _a;
    const name = input.name;
    if ((_a = options.$refs) === null || _a === void 0 ? void 0 : _a.find((t) => t === input.target)) {
        return createRef_1.createRef(name, input.schema, options);
    }
    options.$refs = [...(options.$refs || []), input.target];
    const schema = input.toJSON(generics_1.mapGenericsOptions(options));
    return toRef(input.schema, schema, options);
}
exports.serializeLazyRef = serializeLazyRef;
/**
 * @ignore
 */
function serializeAny(input, options = {}) {
    options.schemas = options.schemas || {};
    if (typeof input !== "object" || input === null) {
        return input;
    }
    if (input instanceof JsonLazyRef_1.JsonLazyRef) {
        return serializeLazyRef(input, options);
    }
    if ("toJSON" in input) {
        const schema = input.toJSON(generics_1.mapGenericsOptions(options));
        return input.canRef ? toRef(input, schema, options) : schema;
    }
    return serializeObject(input, options);
}
exports.serializeAny = serializeAny;
/**
 * @ignore
 */
function serializeGenerics(obj, options) {
    const { generics } = options;
    if (generics && obj.$ref) {
        if (generics.has(obj.$ref)) {
            let type = generics.get(obj.$ref);
            if (core_1.isPrimitiveClass(type)) {
                return {
                    type: getJsonType_1.getJsonType(type)
                };
            }
            if (type === Date) {
                return {
                    type: "string",
                    format: "date-time"
                };
            }
            if (type.toJSON) {
                return type.toJSON({
                    ...options,
                    generics: undefined
                });
            }
            if (type === Object) {
                return {
                    type: "object"
                };
            }
            if (core_1.isClass(type)) {
                const model = {
                    class: type
                };
                if (options.nestedGenerics.length === 0) {
                    return serializeClass(model, {
                        ...options,
                        generics: undefined
                    });
                }
                const store = getJsonEntityStore_1.getJsonEntityStore(model.class);
                return serializeJsonSchema(store.schema, {
                    ...options,
                    ...generics_1.popGenerics(options),
                    root: false
                });
            }
        }
    }
    return obj;
}
exports.serializeGenerics = serializeGenerics;
/**
 * @ignore
 */
function shouldSkipKey(key, { specType = SpecTypes_1.SpecTypes.JSON, customKeys = false }) {
    return (IGNORES.includes(key) ||
        (key.startsWith("#") && (customKeys === false || specType !== SpecTypes_1.SpecTypes.JSON)) ||
        (specType === SpecTypes_1.SpecTypes.SWAGGER && IGNORES_OS2.includes(key)) ||
        (specType !== SpecTypes_1.SpecTypes.JSON && IGNORES_OPENSPEC.includes(key)));
}
/**
 * Convert JsonSchema instance to plain json object
 * @param schema
 * @param options
 * @ignore
 */
function serializeJsonSchema(schema, options = {}) {
    const { useAlias = true, schemas = {}, genericTypes } = options;
    let obj = [...schema.entries()].reduce((item, [key, value]) => {
        if (shouldSkipKey(key, options)) {
            return item;
        }
        key = key.replace(/^#/, "");
        if (key === "type") {
            value = schema.getJsonType();
        }
        if (key === "examples" && core_1.isObject(value) && [SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER].includes(options.specType)) {
            key = "example";
            value = Object.values(value)[0];
        }
        if (value) {
            if (value.isClass) {
                value = serializeClass(value, {
                    ...options,
                    useAlias,
                    schemas
                });
            }
            else {
                value = serializeAny(value, {
                    ...options,
                    useAlias,
                    schemas,
                    genericTypes,
                    genericLabels: schema.genericLabels
                });
            }
        }
        if (isEmptyProperties(key, value)) {
            return item;
        }
        if (shouldMapAlias(key, value, useAlias)) {
            value = JsonAliasMap_1.mapAliasedProperties(value, schema.alias);
        }
        item[key] = value;
        return item;
    }, {});
    if (schema.isClass) {
        obj = serializeInherited(obj, schema.getComputedType(), { ...options, root: false, schemas });
    }
    obj = serializeGenerics(obj, { ...options, root: false, schemas });
    if (schema.has(options.specType)) {
        obj = {
            ...obj,
            ...schema.get(options.specType).toJSON(options)
        };
    }
    obj = getRequiredProperties_1.getRequiredProperties(obj, schema, { ...options, useAlias });
    obj = mapNullableType_1.mapNullableType(obj, schema, options);
    if ((obj.oneOf || obj.allOf || obj.anyOf) && !(obj.items || obj.properties)) {
        delete obj.type;
    }
    return obj;
}
exports.serializeJsonSchema = serializeJsonSchema;
//# sourceMappingURL=serializeJsonSchema.js.map

/***/ }),

/***/ 33423:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJsonMapCollection = void 0;
const JsonMap_1 = __webpack_require__(71196);
/**
 * @ignore
 */
function toJsonMapCollection(content, klass = JsonMap_1.JsonMap) {
    return Object.entries(content).reduce((content, [key, value]) => {
        content.set(key, new klass(value));
        return content;
    }, new JsonMap_1.JsonMap());
}
exports.toJsonMapCollection = toJsonMapCollection;
//# sourceMappingURL=toJsonMapCollection.js.map

/***/ }),

/***/ 91701:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJsonRegex = void 0;
/**
 * @ignore
 * @param pattern
 */
function toJsonRegex(pattern) {
    return String(pattern).replace(/^(\/)(.*)(\/)$/, "$2");
}
exports.toJsonRegex = toJsonRegex;
//# sourceMappingURL=toJsonRegex.js.map

/***/ }),

/***/ 87213:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const util = __webpack_require__(43335);
const braces = __webpack_require__(95234);
const picomatch = __webpack_require__(4763);
const utils = __webpack_require__(53338);
const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),

/***/ 28203:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": function() { return /* binding */ __extends; },
/* harmony export */   "__assign": function() { return /* binding */ __assign; },
/* harmony export */   "__rest": function() { return /* binding */ __rest; },
/* harmony export */   "__decorate": function() { return /* binding */ __decorate; },
/* harmony export */   "__param": function() { return /* binding */ __param; },
/* harmony export */   "__metadata": function() { return /* binding */ __metadata; },
/* harmony export */   "__awaiter": function() { return /* binding */ __awaiter; },
/* harmony export */   "__generator": function() { return /* binding */ __generator; },
/* harmony export */   "__createBinding": function() { return /* binding */ __createBinding; },
/* harmony export */   "__exportStar": function() { return /* binding */ __exportStar; },
/* harmony export */   "__values": function() { return /* binding */ __values; },
/* harmony export */   "__read": function() { return /* binding */ __read; },
/* harmony export */   "__spread": function() { return /* binding */ __spread; },
/* harmony export */   "__spreadArrays": function() { return /* binding */ __spreadArrays; },
/* harmony export */   "__spreadArray": function() { return /* binding */ __spreadArray; },
/* harmony export */   "__await": function() { return /* binding */ __await; },
/* harmony export */   "__asyncGenerator": function() { return /* binding */ __asyncGenerator; },
/* harmony export */   "__asyncDelegator": function() { return /* binding */ __asyncDelegator; },
/* harmony export */   "__asyncValues": function() { return /* binding */ __asyncValues; },
/* harmony export */   "__makeTemplateObject": function() { return /* binding */ __makeTemplateObject; },
/* harmony export */   "__importStar": function() { return /* binding */ __importStar; },
/* harmony export */   "__importDefault": function() { return /* binding */ __importDefault; },
/* harmony export */   "__classPrivateFieldGet": function() { return /* binding */ __classPrivateFieldGet; },
/* harmony export */   "__classPrivateFieldSet": function() { return /* binding */ __classPrivateFieldSet; }
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),

/***/ 95234:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const stringify = __webpack_require__(33026);
const compile = __webpack_require__(33528);
const expand = __webpack_require__(38873);
const parse = __webpack_require__(31623);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ 33528:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const fill = __webpack_require__(47305);
const utils = __webpack_require__(12012);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ 58514:
/***/ (function(module) {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ 38873:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const fill = __webpack_require__(47305);
const stringify = __webpack_require__(33026);
const utils = __webpack_require__(12012);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ 31623:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const stringify = __webpack_require__(33026);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(58514);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ 33026:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const utils = __webpack_require__(12012);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ 12012:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),

/***/ 54672:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "camelCase": function() { return /* reexport */ camelCase; },
  "camelCaseTransform": function() { return /* reexport */ camelCaseTransform; },
  "camelCaseTransformMerge": function() { return /* reexport */ camelCaseTransformMerge; },
  "capitalCase": function() { return /* reexport */ capitalCase; },
  "capitalCaseTransform": function() { return /* reexport */ capitalCaseTransform; },
  "constantCase": function() { return /* reexport */ constantCase; },
  "dotCase": function() { return /* reexport */ dotCase; },
  "headerCase": function() { return /* reexport */ headerCase; },
  "noCase": function() { return /* reexport */ noCase; },
  "paramCase": function() { return /* reexport */ paramCase; },
  "pascalCase": function() { return /* reexport */ pascalCase; },
  "pascalCaseTransform": function() { return /* reexport */ pascalCaseTransform; },
  "pascalCaseTransformMerge": function() { return /* reexport */ pascalCaseTransformMerge; },
  "pathCase": function() { return /* reexport */ pathCase; },
  "sentenceCase": function() { return /* reexport */ sentenceCase; },
  "sentenceCaseTransform": function() { return /* reexport */ sentenceCaseTransform; },
  "snakeCase": function() { return /* reexport */ snakeCase; }
});

;// CONCATENATED MODULE: ../../node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || from);
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

;// CONCATENATED MODULE: ../../node_modules/lower-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var SUPPORTED_LOCALE = {
    tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    az: {
        regexp: /\u0130/g,
        map: {
            İ: "\u0069",
            I: "\u0131",
            İ: "\u0069",
        },
    },
    lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
            I: "\u0069\u0307",
            J: "\u006A\u0307",
            Į: "\u012F\u0307",
            Ì: "\u0069\u0307\u0300",
            Í: "\u0069\u0307\u0301",
            Ĩ: "\u0069\u0307\u0303",
        },
    },
};
/**
 * Localized lower case.
 */
function localeLowerCase(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return lowerCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return lowerCase(str);
}
/**
 * Lower case as a function.
 */
function lowerCase(str) {
    return str.toLowerCase();
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/no-case/dist.es2015/index.js

// Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
// Remove all non-word characters.
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
/**
 * Normalize the string into something other libraries can manipulate easier.
 */
function noCase(input, options) {
    if (options === void 0) { options = {}; }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    // Trim the delimiter from around the output string.
    while (result.charAt(start) === "\0")
        start++;
    while (result.charAt(end - 1) === "\0")
        end--;
    // Transform each token independently.
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
}
/**
 * Replace `re` in the input string with the replacement value.
 */
function replace(input, re, value) {
    if (re instanceof RegExp)
        return input.replace(re, value);
    return re.reduce(function (input, re) { return input.replace(re, value); }, input);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/pascal-case/dist.es2015/index.js


function pascalCaseTransform(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCaseTransformMerge(input) {
    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
}
function pascalCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/camel-case/dist.es2015/index.js


function camelCaseTransform(input, index) {
    if (index === 0)
        return input.toLowerCase();
    return pascalCaseTransform(input, index);
}
function camelCaseTransformMerge(input, index) {
    if (index === 0)
        return input.toLowerCase();
    return pascalCaseTransformMerge(input);
}
function camelCase(input, options) {
    if (options === void 0) { options = {}; }
    return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/upper-case-first/dist.es2015/index.js
/**
 * Upper case the first character of an input string.
 */
function upperCaseFirst(input) {
    return input.charAt(0).toUpperCase() + input.substr(1);
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/capital-case/dist.es2015/index.js



function capitalCaseTransform(input) {
    return upperCaseFirst(input.toLowerCase());
}
function capitalCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: " ", transform: capitalCaseTransform }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/upper-case/dist.es2015/index.js
/**
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 */
var dist_es2015_SUPPORTED_LOCALE = {
    tr: {
        regexp: /[\u0069]/g,
        map: {
            i: "\u0130",
        },
    },
    az: {
        regexp: /[\u0069]/g,
        map: {
            i: "\u0130",
        },
    },
    lt: {
        regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
        map: {
            i̇: "\u0049",
            j̇: "\u004A",
            į̇: "\u012E",
            i̇̀: "\u00CC",
            i̇́: "\u00CD",
            i̇̃: "\u0128",
        },
    },
};
/**
 * Localized upper case.
 */
function localeUpperCase(str, locale) {
    var lang = dist_es2015_SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
        return upperCase(str.replace(lang.regexp, function (m) { return lang.map[m]; }));
    return upperCase(str);
}
/**
 * Upper case as a function.
 */
function upperCase(str) {
    return str.toUpperCase();
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/constant-case/dist.es2015/index.js



function constantCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "_", transform: upperCase }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/dot-case/dist.es2015/index.js


function dotCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: "." }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/header-case/dist.es2015/index.js


function headerCase(input, options) {
    if (options === void 0) { options = {}; }
    return capitalCase(input, __assign({ delimiter: "-" }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/param-case/dist.es2015/index.js


function paramCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "-" }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/path-case/dist.es2015/index.js


function pathCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "/" }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/sentence-case/dist.es2015/index.js



function sentenceCaseTransform(input, index) {
    var result = input.toLowerCase();
    if (index === 0)
        return upperCaseFirst(result);
    return result;
}
function sentenceCase(input, options) {
    if (options === void 0) { options = {}; }
    return noCase(input, __assign({ delimiter: " ", transform: sentenceCaseTransform }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/snake-case/dist.es2015/index.js


function snakeCase(input, options) {
    if (options === void 0) { options = {}; }
    return dotCase(input, __assign({ delimiter: "_" }, options));
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ../../node_modules/change-case/dist.es2015/index.js











//# sourceMappingURL=index.js.map

/***/ }),

/***/ 92644:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var object        = __webpack_require__(73565)
  , stringifiable = __webpack_require__(5570)
  , forOf         = __webpack_require__(31949);

module.exports = function (text, style) {
	var result = "";
	text = stringifiable(text);
	object(style);
	forOf(text, function (char) { result += style[char] || char; });
	return result;
};


/***/ }),

/***/ 33050:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


var d              = __webpack_require__(45214)
  , assign         = __webpack_require__(24185)
  , forEach        = __webpack_require__(69506)
  , map            = __webpack_require__(99591)
  , primitiveSet   = __webpack_require__(19343)
  , setPrototypeOf = __webpack_require__(16907)
  , memoize        = __webpack_require__(23556)
  , memoizeMethods = __webpack_require__(64711)
  , sgr            = __webpack_require__(46918)
  , supportsColor  = __webpack_require__(4945);

var mods           = sgr.mods
  , join           = Array.prototype.join
  , defineProperty = Object.defineProperty
  , max            = Math.max
  , min            = Math.min
  , variantModes   = primitiveSet("_fg", "_bg")
  , xtermMatch     = process.platform === "win32" ? __webpack_require__(90301) : null;

var getFn;

// Some use cli-color as: console.log(clc.red('Error!'));
// Which is inefficient as on each call it configures new clc object
// with memoization we reuse once created object
var memoized = memoize(function (scope, mod) {
	return defineProperty(getFn(), "_cliColorData", d(assign({}, scope._cliColorData, mod)));
});

var proto = Object.create(
	Function.prototype,
	assign(
		map(mods, function (mod) {
			return d.gs(function () { return memoized(this, mod); });
		}),
		memoizeMethods({
			// xterm (255) color
			xterm: d(function (code) {
				code = isNaN(code) ? 255 : min(max(code, 0), 255);
				return defineProperty(
					getFn(), "_cliColorData",
					d(
						assign({}, this._cliColorData, {
							_fg: [xtermMatch ? xtermMatch[code] : "38;5;" + code, 39]
						})
					)
				);
			}),
			bgXterm: d(function (code) {
				code = isNaN(code) ? 255 : min(max(code, 0), 255);
				return defineProperty(
					getFn(), "_cliColorData",
					d(
						assign({}, this._cliColorData, {
							_bg: [xtermMatch ? xtermMatch[code] + 10 : "48;5;" + code, 49]
						})
					)
				);
			})
		})
	)
);

var getEndRe = memoize(function (code) { return new RegExp("\x1b\\[" + code + "m", "g"); }, {
	primitive: true
});

getFn = function () {
	return setPrototypeOf(
		function self(/* …msg*/) {
			var start = ""
			  , end = ""
			  , msg = join.call(arguments, " ")
			  , conf = self._cliColorData
			  , hasAnsi = sgr.hasCSI(msg);
			forEach(
				conf,
				function (mod, key) {
					end = sgr(mod[1]) + end;
					start += sgr(mod[0]);
					if (hasAnsi) {
						msg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : "");
					}
				},
				null,
				true
			);
			if (!supportsColor.isColorSupported()) return msg;
			return start + msg + end;
		},
		proto
	);
};

module.exports = Object.defineProperties(getFn(), {
	xtermSupported: d(!xtermMatch),
	_cliColorData: d("", {})
});


/***/ }),

/***/ 49264:
/***/ (function(module) {

"use strict";


module.exports = "\x07";


/***/ }),

/***/ 33406:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var generate          = __webpack_require__(22318)
  , from              = __webpack_require__(73417)
  , iterable          = __webpack_require__(77486)
  , isValue           = __webpack_require__(11353)
  , stringifiable     = __webpack_require__(69416)
  , repeat            = __webpack_require__(42850)
  , getStrippedLength = __webpack_require__(76210);

var push = Array.prototype.push;

module.exports = function (inputRows/*, options*/) {
	var options = Object(arguments[1])
	  , colsMeta = []
	  , colsOptions = options.columns || []
	  , rows = [];

	from(iterable(inputRows), function (row) {
		var rowRows = [[]];
		from(iterable(row), function (cellStr, columnIndex) {
			var cellRows = stringifiable(cellStr).split("\n");
			while (cellRows.length > rowRows.length) rowRows.push(generate(columnIndex, ""));
			cellRows.forEach(function (cellRow, rowRowIndex) {
				rowRows[rowRowIndex][columnIndex] = cellRow;
			});
		});
		push.apply(rows, rowRows);
	});

	return (
		rows
			.map(function (row) {
				return from(iterable(row), function (str, index) {
					var col = colsMeta[index], strLength;
					if (!col) col = colsMeta[index] = { width: 0 };
					str = stringifiable(str);
					strLength = getStrippedLength(str);
					if (strLength > col.width) col.width = strLength;
					return { str: str, length: strLength };
				});
			})
			.map(function (row) {
				return row
					.map(function (item, index) {
						var pad, align = "left", colOptions = colsOptions && colsOptions[index];
						align = colOptions && colOptions.align === "right" ? "right" : "left";
						pad = repeat.call(" ", colsMeta[index].width - item.length);
						if (align === "left") return item.str + pad;
						return pad + item.str;
					})
					.join(isValue(options.sep) ? options.sep : " | ");
			})
			.join("\n") + "\n"
	);
};


/***/ }),

/***/ 44603:
/***/ (function(module) {

"use strict";


module.exports = {
	screen: "\x1b[2J",
	screenLeft: "\x1b[1J",
	screenRight: "\x1b[J",
	line: "\x1b[2K",
	lineLeft: "\x1b[1K",
	lineRight: "\x1b[K"
};


/***/ }),

/***/ 76210:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/*
 * get actual length of ANSI-formatted string
 */

var strip = __webpack_require__(50123);

module.exports = function (str) { return strip(str).length; };


/***/ }),

/***/ 23692:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d = __webpack_require__(45214);

module.exports = Object.defineProperties(__webpack_require__(33050), {
	windowSize: d(__webpack_require__(57185)),
	erase: d(__webpack_require__(44603)),
	move: d(__webpack_require__(62800)),
	beep: d(__webpack_require__(49264)),
	columns: d(__webpack_require__(33406)),
	strip: d(__webpack_require__(50123)),
	getStrippedLength: d(__webpack_require__(76210)),
	slice: d(__webpack_require__(46331)),
	throbber: d(__webpack_require__(83201)),
	reset: d(__webpack_require__(73702)),
	art: d(__webpack_require__(92644))
});


/***/ }),

/***/ 46918:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* CSI - control sequence introducer */
/* SGR - set graphic rendition */

var assign       = __webpack_require__(24185)
  , includes     = __webpack_require__(64623)
  , forOwn       = __webpack_require__(69506)
  , onlyKey      = __webpack_require__(52730)
  , forEachRight = __webpack_require__(96954)
  , uniq         = __webpack_require__(16536);

var CSI = "\x1b[";

var sgr = function (code) { return CSI + code + "m"; };

sgr.CSI = CSI;

var mods = assign(
	{
		// Style
		bold: { _bold: [1, 22] },
		italic: { _italic: [3, 23] },
		underline: { _underline: [4, 24] },
		blink: { _blink: [5, 25] },
		inverse: { _inverse: [7, 27] },
		strike: { _strike: [9, 29] }

		// Color
	},
	["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"].reduce(function (
		obj,
		color,
		index
	) {
		// foreground
		obj[color] = { _fg: [30 + index, 39] };
		obj[color + "Bright"] = { _fg: [90 + index, 39] };

		// background
		obj["bg" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index, 49] };
		obj["bg" + color[0].toUpperCase() + color.slice(1) + "Bright"] = { _bg: [100 + index, 49] };

		return obj;
	}, {})
);

sgr.mods = mods;

sgr.openers = {};
sgr.closers = {};

forOwn(mods, function (mod) {
	var modPair = mod[onlyKey(mod)];

	sgr.openers[modPair[0]] = modPair;
	sgr.closers[modPair[1]] = modPair;
});

sgr.openStyle = function (openedMods, code) { openedMods.push(sgr.openers[code]); };

sgr.closeStyle = function (openedMods, code) {
	forEachRight.call(openedMods, function (modPair, index) {
		if (modPair[1] === code) {
			openedMods.splice(index, 1);
		}
	});
};

/* prepend openers */
sgr.prepend = function (currentMods) {
	return currentMods.map(function (modPair) { return sgr(modPair[0]); });
};

/* complete non-closed openers with corresponding closers */
sgr.complete = function (openedMods, closerCodes) {
	closerCodes.forEach(function (code) { sgr.closeStyle(openedMods, code); });

	// mods must be closed from the last opened to first opened
	openedMods = openedMods.reverse();

	openedMods = openedMods.map(function (modPair) { return modPair[1]; });

	// one closer can close many openers (31, 32 -> 39)
	openedMods = uniq.call(openedMods);

	return openedMods.map(sgr);
};

var hasCSI = function (str) { return includes.call(str, CSI); };

sgr.hasCSI = hasCSI;

var extractCode = function (csi) {
	var code = csi.slice(2, -1);
	code = Number(code);
	return code;
};

sgr.extractCode = extractCode;

module.exports = sgr;


/***/ }),

/***/ 4945:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


// store whether supports-color mode is enabled or not.
var state = null;

// force supports-color mode
var enableColor = function () { state = true; };

// disable supports-color mode
var disableColor = function () { state = false; };

// use the NO_COLOR environment variable (default)
var autoDetectSupport = function () { state = null; };

// determine whether supports-color mode is enabled.
var isColorSupported = function () { return state === null ? !process.env.NO_COLOR : state; };

module.exports = {
	enableColor: enableColor,
	disableColor: disableColor,
	autoDetectSupport: autoDetectSupport,
	isColorSupported: isColorSupported
};


/***/ }),

/***/ 42531:
/***/ (function(module) {

"use strict";


module.exports = [
	"000000", "800000", "008000", "808000", "000080", "800080", "008080", "c0c0c0", "808080",
	"ff0000", "00ff00", "ffff00", "0000ff", "ff00ff", "00ffff", "ffffff", "000000", "00005f",
	"000087", "0000af", "0000d7", "0000ff", "005f00", "005f5f", "005f87", "005faf", "005fd7",
	"005fff", "008700", "00875f", "008787", "0087af", "0087d7", "0087ff", "00af00", "00af5f",
	"00af87", "00afaf", "00afd7", "00afff", "00d700", "00d75f", "00d787", "00d7af", "00d7d7",
	"00d7ff", "00ff00", "00ff5f", "00ff87", "00ffaf", "00ffd7", "00ffff", "5f0000", "5f005f",
	"5f0087", "5f00af", "5f00d7", "5f00ff", "5f5f00", "5f5f5f", "5f5f87", "5f5faf", "5f5fd7",
	"5f5fff", "5f8700", "5f875f", "5f8787", "5f87af", "5f87d7", "5f87ff", "5faf00", "5faf5f",
	"5faf87", "5fafaf", "5fafd7", "5fafff", "5fd700", "5fd75f", "5fd787", "5fd7af", "5fd7d7",
	"5fd7ff", "5fff00", "5fff5f", "5fff87", "5fffaf", "5fffd7", "5fffff", "870000", "87005f",
	"870087", "8700af", "8700d7", "8700ff", "875f00", "875f5f", "875f87", "875faf", "875fd7",
	"875fff", "878700", "87875f", "878787", "8787af", "8787d7", "8787ff", "87af00", "87af5f",
	"87af87", "87afaf", "87afd7", "87afff", "87d700", "87d75f", "87d787", "87d7af", "87d7d7",
	"87d7ff", "87ff00", "87ff5f", "87ff87", "87ffaf", "87ffd7", "87ffff", "af0000", "af005f",
	"af0087", "af00af", "af00d7", "af00ff", "af5f00", "af5f5f", "af5f87", "af5faf", "af5fd7",
	"af5fff", "af8700", "af875f", "af8787", "af87af", "af87d7", "af87ff", "afaf00", "afaf5f",
	"afaf87", "afafaf", "afafd7", "afafff", "afd700", "afd75f", "afd787", "afd7af", "afd7d7",
	"afd7ff", "afff00", "afff5f", "afff87", "afffaf", "afffd7", "afffff", "d70000", "d7005f",
	"d70087", "d700af", "d700d7", "d700ff", "d75f00", "d75f5f", "d75f87", "d75faf", "d75fd7",
	"d75fff", "d78700", "d7875f", "d78787", "d787af", "d787d7", "d787ff", "d7af00", "d7af5f",
	"d7af87", "d7afaf", "d7afd7", "d7afff", "d7d700", "d7d75f", "d7d787", "d7d7af", "d7d7d7",
	"d7d7ff", "d7ff00", "d7ff5f", "d7ff87", "d7ffaf", "d7ffd7", "d7ffff", "ff0000", "ff005f",
	"ff0087", "ff00af", "ff00d7", "ff00ff", "ff5f00", "ff5f5f", "ff5f87", "ff5faf", "ff5fd7",
	"ff5fff", "ff8700", "ff875f", "ff8787", "ff87af", "ff87d7", "ff87ff", "ffaf00", "ffaf5f",
	"ffaf87", "ffafaf", "ffafd7", "ffafff", "ffd700", "ffd75f", "ffd787", "ffd7af", "ffd7d7",
	"ffd7ff", "ffff00", "ffff5f", "ffff87", "ffffaf", "ffffd7", "ffffff", "080808", "121212",
	"1c1c1c", "262626", "303030", "3a3a3a", "444444", "4e4e4e", "585858", "626262", "6c6c6c",
	"767676", "808080", "8a8a8a", "949494", "9e9e9e", "a8a8a8", "b2b2b2", "bcbcbc", "c6c6c6",
	"d0d0d0", "dadada", "e4e4e4", "eeeeee"
];


/***/ }),

/***/ 90301:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var push = Array.prototype.push
  , reduce = Array.prototype.reduce
  , abs = Math.abs
  , colors
  , match
  , result
  , i;

colors = (__webpack_require__(42531).map)(function (color) {
	return {
		r: parseInt(color.slice(0, 2), 16),
		g: parseInt(color.slice(2, 4), 16),
		b: parseInt(color.slice(4), 16)
	};
});

match = colors.slice(0, 16);

module.exports = result = [];

i = 0;
while (i < 8) {
	result.push(30 + i++);
}
i = 0;
while (i < 8) {
	result.push(90 + i++);
}
push.apply(
	result,
	colors.slice(16).map(function (data) {
		var index, diff = Infinity;
		match.every(function (innerMatch, currentIndex) {
			var ndiff = reduce.call(
				"rgb",
				function (currentDiff, channel) {
					currentDiff += abs(innerMatch[channel] - data[channel]);
					return currentDiff;
				},
				0
			);
			if (ndiff < diff) {
				index = currentIndex;
				diff = ndiff;
			}
			return ndiff;
		});
		return result[index];
	})
);


/***/ }),

/***/ 62800:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d     = __webpack_require__(45214)
  , trunc = __webpack_require__(31750);

var up, down, right, left, abs = Math.abs, floor = Math.floor, max = Math.max;

var getMove = function (control) {
	return function (num) {
		num = isNaN(num) ? 0 : max(floor(num), 0);
		return num ? "\x1b[" + num + control : "";
	};
};

module.exports = Object.defineProperties(
	function (x, y) {
		x = isNaN(x) ? 0 : floor(x);
		y = isNaN(y) ? 0 : floor(y);
		return (x > 0 ? right(x) : left(-x)) + (y > 0 ? down(y) : up(-y));
	},
	{
		up: d((up = getMove("A"))),
		down: d((down = getMove("B"))),
		right: d((right = getMove("C"))),
		left: d((left = getMove("D"))),
		to: d(function (x, y) {
			x = isNaN(x) ? 1 : max(floor(x), 0) + 1;
			y = isNaN(y) ? 1 : max(floor(y), 0) + 1;
			return "\x1b[" + y + ";" + x + "H";
		}),
		lines: d(function (n) {
			var dir;
			n = trunc(n) || 0;
			dir = n >= 0 ? "E" : "F";
			n = floor(abs(n));
			return "\x1b[" + n + dir;
		}),
		top: d("\x1b[5000F"),
		bottom: d("\x1b[5000B"),
		lineBegin: d("\x1b[5000D"),
		lineEnd: d("\x1b[5000C")
	}
);


/***/ }),

/***/ 73702:
/***/ (function(module) {

"use strict";


module.exports = "\x1b[2J\x1b[0;0H";


/***/ }),

/***/ 46331:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var reAnsi        = __webpack_require__(86566)
  , stringifiable = __webpack_require__(5570)
  , length        = __webpack_require__(76210)
  , sgr           = __webpack_require__(46918)
  , max           = Math.max;

var Token = function (token) { this.token = token; };

var tokenize = function (str) {
	var match = reAnsi().exec(str);

	if (!match) {
		return [str];
	}

	var index = match.index, head, prehead, tail;

	if (index === 0) {
		head = match[0];
		tail = str.slice(head.length);

		return [new Token(head)].concat(tokenize(tail));
	}

	prehead = str.slice(0, index);
	head = match[0];
	tail = str.slice(index + head.length);

	return [prehead, new Token(head)].concat(tokenize(tail));
};

var isChunkInSlice = function (chunk, index, begin, end) {
	var endIndex = chunk.length + index;

	if (begin > endIndex) return false;
	if (end < index) return false;
	return true;
};

// eslint-disable-next-line max-lines-per-function
var sliceSeq = function (seq, begin, end) {
	var sliced = seq.reduce(
		function (state, chunk) {
			var index = state.index;

			if (chunk instanceof Token) {
				var code = sgr.extractCode(chunk.token);

				if (index <= begin) {
					if (code in sgr.openers) {
						sgr.openStyle(state.preOpeners, code);
					}
					if (code in sgr.closers) {
						sgr.closeStyle(state.preOpeners, code);
					}
				} else if (index < end) {
					if (code in sgr.openers) {
						sgr.openStyle(state.inOpeners, code);
						state.seq.push(chunk);
					} else if (code in sgr.closers) {
						state.inClosers.push(code);
						state.seq.push(chunk);
					}
				}
			} else {
				var nextChunk = "";

				if (isChunkInSlice(chunk, index, begin, end)) {
					var relBegin = Math.max(begin - index, 0)
					  , relEnd = Math.min(end - index, chunk.length);

					nextChunk = chunk.slice(relBegin, relEnd);
				}

				state.seq.push(nextChunk);
				state.index = index + chunk.length;
			}

			return state;
		},
		{
			index: 0,
			seq: [],

			// preOpeners -> [ mod ]
			// preOpeners must be prepended to the slice if they wasn't closed til the end of it
			// preOpeners must be closed if they wasn't closed til the end of the slice
			preOpeners: [],

			// inOpeners  -> [ mod ]
			// inOpeners already in the slice and must not be prepended to the slice
			// inOpeners must be closed if they wasn't closed til the end of the slice
			inOpeners: [], // opener CSI inside slice

			// inClosers -> [ code ]
			// closer CSIs for determining which pre/in-Openers must be closed
			inClosers: []
		}
	);

	sliced.seq = [].concat(
		sgr.prepend(sliced.preOpeners), sliced.seq,
		sgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)
	);

	return sliced.seq;
};

module.exports = function (str/*, begin, end*/) {
	var seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;

	str = stringifiable(str);
	len = length(str);

	if (isNaN(begin)) {
		begin = 0;
	}
	if (isNaN(end)) {
		end = len;
	}
	if (begin < 0) {
		begin = max(len + begin, 0);
	}
	if (end < 0) {
		end = max(len + end, 0);
	}

	seq = tokenize(str);
	seq = sliceSeq(seq, begin, end);
	return seq
		.map(function (chunk) {
			if (chunk instanceof Token) {
				return chunk.token;
			}

			return chunk;
		})
		.join("");
};


/***/ }),

/***/ 50123:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Strip ANSI formatting from string



var stringifiable = __webpack_require__(69416)
  , r             = __webpack_require__(86566)();

module.exports = function (str) { return stringifiable(str).replace(r, ""); };


/***/ }),

/***/ 83201:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compose      = __webpack_require__(71439)
  , callable     = __webpack_require__(82678)
  , d            = __webpack_require__(45214)
  , validTimeout = __webpack_require__(47987);

var chars = "-\\|/", l = chars.length, ThrobberIterator;

ThrobberIterator = function () {
	// no setup needed
};
Object.defineProperties(ThrobberIterator.prototype, {
	index: d(-1),
	running: d(false),
	next: d(function () {
		var str = this.running ? "\u0008" : "";
		if (!this.running) this.running = true;
		return str + chars[(this.index = (this.index + 1) % l)];
	}),
	reset: d(function () {
		if (!this.running) return "";
		this.index = -1;
		this.running = false;
		return "\u0008";
	})
});

module.exports = exports = function (write, interval/*, format*/) {
	var format = arguments[2], token, iterator = new ThrobberIterator();
	callable(write);
	interval = validTimeout(interval);
	if (format !== undefined) write = compose.call(write, callable(format));
	return {
		start: function () {
			if (token) return;
			token = setInterval(function () { write(iterator.next()); }, interval);
		},
		restart: function () {
			this.stop();
			this.start();
		},
		stop: function () {
			if (!token) return;
			clearInterval(token);
			token = null;
			write(iterator.reset());
		}
	};
};

Object.defineProperty(exports, "Iterator", (d(ThrobberIterator)));


/***/ }),

/***/ 57185:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


var d = __webpack_require__(45214);

Object.defineProperties(exports, {
	width: d.gs("ce", function () { return process.stdout.columns || 0; }),
	height: d.gs("ce", function () { return process.stdout.rows || 0; })
});


/***/ }),

/***/ 21491:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue             = __webpack_require__(14704)
  , ensureValue         = __webpack_require__(41072)
  , ensurePlainFunction = __webpack_require__(42690)
  , copy                = __webpack_require__(26884)
  , normalizeOptions    = __webpack_require__(96872)
  , map                 = __webpack_require__(99591);

var bind = Function.prototype.bind
  , defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, options) {
	var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, options*/) {
	var options = normalizeOptions(arguments[1]);
	if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
	return map(props, function (desc, name) { return define(name, desc, options); });
};


/***/ }),

/***/ 45214:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue         = __webpack_require__(14704)
  , isPlainFunction = __webpack_require__(56983)
  , assign          = __webpack_require__(24185)
  , normalizeOpts   = __webpack_require__(96872)
  , contains        = __webpack_require__(64623);

var d = (module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if (arguments.length < 2 || typeof dscr !== "string") {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
		w = contains.call(dscr, "w");
	} else {
		c = w = true;
		e = false;
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
});

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== "string") {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (!isValue(get)) {
		get = undefined;
	} else if (!isPlainFunction(get)) {
		options = get;
		get = set = undefined;
	} else if (!isValue(set)) {
		set = undefined;
	} else if (!isPlainFunction(set)) {
		options = set;
		set = undefined;
	}
	if (isValue(dscr)) {
		c = contains.call(dscr, "c");
		e = contains.call(dscr, "e");
	} else {
		c = true;
		e = false;
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};


/***/ }),

/***/ 7610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isPlainFunction = __webpack_require__(56983)
  , ensureValue     = __webpack_require__(41072)
  , isValue         = __webpack_require__(14704)
  , map             = __webpack_require__(99591)
  , contains        = __webpack_require__(64623);

var call = Function.prototype.call
  , defineProperty = Object.defineProperty
  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
  , getPrototypeOf = Object.getPrototypeOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , cacheDesc = { configurable: false, enumerable: false, writable: false, value: null }
  , define;

define = function (name, options) {
	var value, dgs, cacheName, desc, writable = false, resolvable, flat;
	options = Object(ensureValue(options));
	cacheName = options.cacheName;
	flat = options.flat;
	if (!isValue(cacheName)) cacheName = name;
	delete options.cacheName;
	value = options.value;
	resolvable = isPlainFunction(value);
	delete options.value;
	dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
	if (name !== cacheName) {
		dgs.get = function () {
			if (hasOwnProperty.call(this, cacheName)) return this[cacheName];
			cacheDesc.value = resolvable ? call.call(value, this, options) : value;
			cacheDesc.writable = writable;
			defineProperty(this, cacheName, cacheDesc);
			cacheDesc.value = null;
			if (desc) defineProperty(this, name, desc);
			return this[cacheName];
		};
	} else if (!flat) {
		dgs.get = function self() {
			var ownDesc;
			if (hasOwnProperty.call(this, name)) {
				ownDesc = getOwnPropertyDescriptor(this, name);
				// It happens in Safari, that getter is still called after property
				// was defined with a value, following workarounds that
				// While in IE11 it may happen that here ownDesc is undefined (go figure)
				if (ownDesc) {
					if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
					if (typeof ownDesc.get === "function" && ownDesc.get !== self) {
						return ownDesc.get.call(this);
					}
					return value;
				}
			}
			desc.value = resolvable ? call.call(value, this, options) : value;
			defineProperty(this, name, desc);
			desc.value = null;
			return this[name];
		};
	} else {
		dgs.get = function self() {
			var base = this, ownDesc;
			if (hasOwnProperty.call(this, name)) {
				// It happens in Safari, that getter is still called after property
				// was defined with a value, following workarounds that
				ownDesc = getOwnPropertyDescriptor(this, name);
				if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
				if (typeof ownDesc.get === "function" && ownDesc.get !== self) {
					return ownDesc.get.call(this);
				}
			}
			while (!hasOwnProperty.call(base, name)) base = getPrototypeOf(base);
			desc.value = resolvable ? call.call(value, base, options) : value;
			defineProperty(base, name, desc);
			desc.value = null;
			return base[name];
		};
	}
	dgs.set = function (value) {
		if (hasOwnProperty.call(this, name)) {
			throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
		}
		dgs.get.call(this);
		this[cacheName] = value;
	};
	if (options.desc) {
		desc = {
			configurable: contains.call(options.desc, "c"),
			enumerable: contains.call(options.desc, "e")
		};
		if (cacheName === name) {
			desc.writable = contains.call(options.desc, "w");
			desc.value = null;
		} else {
			writable = contains.call(options.desc, "w");
			desc.get = dgs.get;
			desc.set = dgs.set;
		}
		delete options.desc;
	} else if (cacheName === name) {
		desc = {
			configurable: Boolean(options.configurable),
			enumerable: Boolean(options.enumerable),
			writable: Boolean(options.writable),
			value: null
		};
	}
	delete options.configurable;
	delete options.enumerable;
	delete options.writable;
	return dgs;
};

module.exports = function (props) {
	return map(props, function (desc, name) { return define(name, desc); });
};


/***/ }),

/***/ 26939:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Inspired by Google Closure:
// http://closure-library.googlecode.com/svn/docs/
// closure_goog_array_array.js.html#goog.array.clear



var value = __webpack_require__(32977);

module.exports = function () {
	value(this).length = 0;
	return this;
};


/***/ }),

/***/ 45148:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var numberIsNaN       = __webpack_require__(31382)
  , toPosInt          = __webpack_require__(23701)
  , value             = __webpack_require__(32977)
  , indexOf           = Array.prototype.indexOf
  , objHasOwnProperty = Object.prototype.hasOwnProperty
  , abs               = Math.abs
  , floor             = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, length, fromIndex, val;
	if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);

	length = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < length; ++i) {
		if (objHasOwnProperty.call(this, i)) {
			val = this[i];
			if (numberIsNaN(val)) return i; // Jslint: ignore
		}
	}
	return -1;
};


/***/ }),

/***/ 96954:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt          = __webpack_require__(23701)
  , callable          = __webpack_require__(82678)
  , value             = __webpack_require__(32977)
  , objHasOwnProperty = Object.prototype.hasOwnProperty
  , call              = Function.prototype.call;

module.exports = function (cb/*, thisArg*/) {
	var i, self, thisArg;

	self = Object(value(this));
	callable(cb);
	thisArg = arguments[1];

	for (i = toPosInt(self.length) - 1; i >= 0; --i) {
		if (objHasOwnProperty.call(self, i)) call.call(cb, thisArg, self[i], i, self);
	}
};


/***/ }),

/***/ 16536:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var indexOf = __webpack_require__(45148)
  , filter  = Array.prototype.filter
  , isFirst;

isFirst = function (value, index) { return indexOf.call(this, value) === index; };

module.exports = function () { return filter.call(this, isFirst, this); };


/***/ }),

/***/ 73417:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(27198)() ? Array.from : __webpack_require__(54985);


/***/ }),

/***/ 27198:
/***/ (function(module) {

"use strict";


module.exports = function () {
	var from = Array.from, arr, result;
	if (typeof from !== "function") return false;
	arr = ["raz", "dwa"];
	result = from(arr);
	return Boolean(result && result !== arr && result[1] === "dwa");
};


/***/ }),

/***/ 54985:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var iteratorSymbol = (__webpack_require__(29724).iterator)
  , isArguments    = __webpack_require__(18640)
  , isFunction     = __webpack_require__(37538)
  , toPosInt       = __webpack_require__(23701)
  , callable       = __webpack_require__(82678)
  , validValue     = __webpack_require__(32977)
  , isValue        = __webpack_require__(11353)
  , isString       = __webpack_require__(13774)
  , isArray        = Array.isArray
  , call           = Function.prototype.call
  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
  , defineProperty = Object.defineProperty;

// eslint-disable-next-line complexity, max-lines-per-function
module.exports = function (arrayLike/*, mapFn, thisArg*/) {
	var mapFn = arguments[1]
	  , thisArg = arguments[2]
	  , Context
	  , i
	  , j
	  , arr
	  , length
	  , code
	  , iterator
	  , result
	  , getIterator
	  , value;

	arrayLike = Object(validValue(arrayLike));

	if (isValue(mapFn)) callable(mapFn);
	if (!this || this === Array || !isFunction(this)) {
		// Result: Plain array
		if (!mapFn) {
			if (isArguments(arrayLike)) {
				// Source: Arguments
				length = arrayLike.length;
				if (length !== 1) return Array.apply(null, arrayLike);
				arr = new Array(1);
				arr[0] = arrayLike[0];
				return arr;
			}
			if (isArray(arrayLike)) {
				// Source: Array
				arr = new Array((length = arrayLike.length));
				for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
				return arr;
			}
		}
		arr = [];
	} else {
		// Result: Non plain array
		Context = this;
	}

	if (!isArray(arrayLike)) {
		if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
			// Source: Iterator
			iterator = callable(getIterator).call(arrayLike);
			if (Context) arr = new Context();
			result = iterator.next();
			i = 0;
			while (!result.done) {
				value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, i, desc);
				} else {
					arr[i] = value;
				}
				result = iterator.next();
				++i;
			}
			length = i;
		} else if (isString(arrayLike)) {
			// Source: String
			length = arrayLike.length;
			if (Context) arr = new Context();
			for (i = 0, j = 0; i < length; ++i) {
				value = arrayLike[i];
				if (i + 1 < length) {
					code = value.charCodeAt(0);
					// eslint-disable-next-line max-depth
					if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
				}
				value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
				if (Context) {
					desc.value = value;
					defineProperty(arr, j, desc);
				} else {
					arr[j] = value;
				}
				++j;
			}
			length = j;
		}
	}
	if (length === undefined) {
		// Source: array or array-like
		length = toPosInt(arrayLike.length);
		if (Context) arr = new Context(length);
		for (i = 0; i < length; ++i) {
			value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
			if (Context) {
				desc.value = value;
				defineProperty(arr, i, desc);
			} else {
				arr[i] = value;
			}
		}
	}
	if (Context) {
		desc.value = null;
		arr.length = length;
	}
	return arr;
};


/***/ }),

/***/ 22318:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(23701)
  , value    = __webpack_require__(32977)
  , slice    = Array.prototype.slice;

module.exports = function (length/*, …fill*/) {
	var arr, currentLength;
	length = toPosInt(value(length));
	if (length === 0) return [];

	arr = arguments.length < 2 ? [undefined] : slice.call(arguments, 1, 1 + length);

	while ((currentLength = arr.length) < length) {
		arr = arr.concat(arr.slice(0, length - currentLength));
	}
	return arr;
};


/***/ }),

/***/ 64089:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var from    = __webpack_require__(73417)
  , isArray = Array.isArray;

module.exports = function (arrayLike) { return isArray(arrayLike) ? arrayLike : from(arrayLike); };


/***/ }),

/***/ 28455:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var assign            = __webpack_require__(24185)
  , isObject          = __webpack_require__(95690)
  , isValue           = __webpack_require__(11353)
  , captureStackTrace = Error.captureStackTrace;

module.exports = function (message/*, code, ext*/) {
	var err = new Error(message), code = arguments[1], ext = arguments[2];
	if (!isValue(ext)) {
		if (isObject(code)) {
			ext = code;
			code = null;
		}
	}
	if (isValue(ext)) assign(err, ext);
	if (isValue(code)) err.code = code;
	if (captureStackTrace) captureStackTrace(err, module.exports);
	return err;
};


/***/ }),

/***/ 71439:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue  = __webpack_require__(11353)
  , callable = __webpack_require__(82678)
  , aFrom    = __webpack_require__(73417);

var apply = Function.prototype.apply
  , call = Function.prototype.call
  , callFn = function (arg, fn) { return call.call(fn, this, arg); };

module.exports = function (fnIgnored/*, …fnn*/) {
	var fns, first;
	var args = aFrom(arguments);
	fns = isValue(this) ? [this].concat(args) : args;
	fns.forEach(callable);
	fns = fns.reverse();
	first = fns[0];
	fns = fns.slice(1);
	return function (argIgnored) { return fns.reduce(callFn, apply.call(first, this, arguments)); };
};


/***/ }),

/***/ 33864:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(23701);

var test = function (arg1, arg2) { return arg2; };

var desc, defineProperty, generate, mixin;

try {
	Object.defineProperty(test, "length", {
		configurable: true,
		writable: false,
		enumerable: false,
		value: 1
	});
}
catch (ignore) {}

if (test.length === 1) {
	// ES6
	desc = { configurable: true, writable: false, enumerable: false };
	defineProperty = Object.defineProperty;
	module.exports = function (fn, length) {
		length = toPosInt(length);
		if (fn.length === length) return fn;
		desc.value = length;
		return defineProperty(fn, "length", desc);
	};
} else {
	mixin = __webpack_require__(42869);
	generate = (function () {
		var cache = [];
		return function (length) {
			var args, i = 0;
			if (cache[length]) return cache[length];
			args = [];
			while (length--) args.push("a" + (++i).toString(36));
			// eslint-disable-next-line no-new-func
			return new Function(
				"fn",
				"return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
			);
		};
	})();
	module.exports = function (src, length) {
		var target;
		length = toPosInt(length);
		if (src.length === length) return src;
		target = generate(length)(src);
		try { mixin(target, src); }
		catch (ignore) {}
		return target;
	};
}


/***/ }),

/***/ 18640:
/***/ (function(module) {

"use strict";


var objToString = Object.prototype.toString
  , id = objToString.call((function () { return arguments; })());

module.exports = function (value) { return objToString.call(value) === id; };


/***/ }),

/***/ 37538:
/***/ (function(module) {

"use strict";


var objToString = Object.prototype.toString
  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);

module.exports = function (value) {
	return typeof value === "function" && isFunctionStringTag(objToString.call(value));
};


/***/ }),

/***/ 77683:
/***/ (function(module) {

"use strict";


// eslint-disable-next-line no-empty-function
module.exports = function () {};


/***/ }),

/***/ 7172:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var iteratorSymbol = (__webpack_require__(29724).iterator)
  , isValue        = __webpack_require__(11353)
  , isArrayLike    = __webpack_require__(21753);

module.exports = function (value) {
	if (!isValue(value)) return false;
	if (typeof value[iteratorSymbol] === "function") return true;
	return isArrayLike(value);
};


/***/ }),

/***/ 77486:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(95690)
  , is       = __webpack_require__(7172);

module.exports = function (value) {
	if (is(value) && isObject(value)) return value;
	throw new TypeError(value + " is not an iterable or array-like object");
};


/***/ }),

/***/ 66545:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(67333)() ? Math.sign : __webpack_require__(12183);


/***/ }),

/***/ 67333:
/***/ (function(module) {

"use strict";


module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== "function") return false;
	return sign(10) === 1 && sign(-20) === -1;
};


/***/ }),

/***/ 12183:
/***/ (function(module) {

"use strict";


module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || value === 0) return value;
	return value > 0 ? 1 : -1;
};


/***/ }),

/***/ 31750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(87843)() ? Math.trunc : __webpack_require__(70094);


/***/ }),

/***/ 87843:
/***/ (function(module) {

"use strict";


module.exports = function () {
	var trunc = Math.trunc;
	if (typeof trunc !== "function") return false;
	return trunc(13.67) === 13 && trunc(-13.67) === -13;
};


/***/ }),

/***/ 70094:
/***/ (function(module) {

"use strict";


var floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return NaN;
	value = Number(value);
	if (value === 0) return value;
	if (value === Infinity) return Infinity;
	if (value === -Infinity) return -Infinity;
	if (value > 0) return floor(value);
	return -floor(-value);
};


/***/ }),

/***/ 31382:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(23919)() ? Number.isNaN : __webpack_require__(88968);


/***/ }),

/***/ 23919:
/***/ (function(module) {

"use strict";


module.exports = function () {
	var numberIsNaN = Number.isNaN;
	if (typeof numberIsNaN !== "function") return false;
	return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
};


/***/ }),

/***/ 88968:
/***/ (function(module) {

"use strict";


module.exports = function (value) {
	// eslint-disable-next-line no-self-compare
	return value !== value;
};


/***/ }),

/***/ 66329:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var sign  = __webpack_require__(66545)
  , abs   = Math.abs
  , floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if (value === 0 || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};


/***/ }),

/***/ 23701:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(66329)
  , max       = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };


/***/ }),

/***/ 83507:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order



var callable                = __webpack_require__(82678)
  , value                   = __webpack_require__(32977)
  , bind                    = Function.prototype.bind
  , call                    = Function.prototype.call
  , keys                    = Object.keys
  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== "function") method = list[method];
		return call.call(method, list, function (key, index) {
			if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};


/***/ }),

/***/ 24185:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(98041)() ? Object.assign : __webpack_require__(42250);


/***/ }),

/***/ 98041:
/***/ (function(module) {

"use strict";


module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== "function") return false;
	obj = { foo: "raz" };
	assign(obj, { bar: "dwa" }, { trzy: "trzy" });
	return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};


/***/ }),

/***/ 42250:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keys  = __webpack_require__(98809)
  , value = __webpack_require__(32977)
  , max   = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, length = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try {
			dest[key] = src[key];
		} catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < length; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};


/***/ }),

/***/ 26884:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var aFrom  = __webpack_require__(73417)
  , assign = __webpack_require__(24185)
  , value  = __webpack_require__(32977);

module.exports = function (obj/*, propertyNames, options*/) {
	var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
	if (copy !== obj && !propertyNames) return copy;
	var result = {};
	if (propertyNames) {
		aFrom(propertyNames, function (propertyName) {
			if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
		});
	} else {
		assign(result, obj);
	}
	return result;
};


/***/ }),

/***/ 98693:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Workaround for http://code.google.com/p/v8/issues/detail?id=2804



var create = Object.create, shim;

if (!__webpack_require__(44467)()) {
	shim = __webpack_require__(12659);
}

module.exports = (function () {
	var nullObject, polyProps, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	polyProps = {};
	desc = { configurable: false, enumerable: false, writable: true, value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === "__proto__") {
			polyProps[name] = {
				configurable: true,
				enumerable: false,
				writable: true,
				value: undefined
			};
			return;
		}
		polyProps[name] = desc;
	});
	Object.defineProperties(nullObject, polyProps);

	Object.defineProperty(shim, "nullPolyfill", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: nullObject
	});

	return function (prototype, props) {
		return create(prototype === null ? nullObject : prototype, props);
	};
})();


/***/ }),

/***/ 52730:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var value                   = __webpack_require__(32977)
  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (obj) {
	var i;
	value(obj);
	for (i in obj) {
		if (objPropertyIsEnumerable.call(obj, i)) return i;
	}
	return null;
};


/***/ }),

/***/ 69506:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(83507)("forEach");


/***/ }),

/***/ 21753:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(37538)
  , isObject   = __webpack_require__(95690)
  , isValue    = __webpack_require__(11353);

module.exports = function (value) {
	return (
		(isValue(value) &&
			typeof value.length === "number" &&
			// Just checking ((typeof x === 'object') && (typeof x !== 'function'))
			// won't work right for some cases, e.g.:
			// type of instance of NodeList in Safari is a 'function'
			((isObject(value) && !isFunction(value)) || typeof value === "string")) ||
		false
	);
};


/***/ }),

/***/ 6812:
/***/ (function(module) {

"use strict";
// Deprecated



module.exports = function (obj) { return typeof obj === "function"; };


/***/ }),

/***/ 95690:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(11353);

var map = { function: true, object: true };

module.exports = function (value) { return (isValue(value) && map[typeof value]) || false; };


/***/ }),

/***/ 11353:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var _undefined = __webpack_require__(77683)(); // Support ES3 engines

module.exports = function (val) { return val !== _undefined && val !== null; };


/***/ }),

/***/ 98809:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(17696)() ? Object.keys : __webpack_require__(16056);


/***/ }),

/***/ 17696:
/***/ (function(module) {

"use strict";


module.exports = function () {
	try {
		Object.keys("primitive");
		return true;
	} catch (e) {
		return false;
	}
};


/***/ }),

/***/ 16056:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(11353);

var keys = Object.keys;

module.exports = function (object) { return keys(isValue(object) ? Object(object) : object); };


/***/ }),

/***/ 99591:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(82678)
  , forEach  = __webpack_require__(69506)
  , call     = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var result = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, targetObj, index) {
		result[key] = call.call(cb, thisArg, value, key, targetObj, index);
	});
	return result;
};


/***/ }),

/***/ 42869:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var value                    = __webpack_require__(32977)
  , defineProperty           = Object.defineProperty
  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
  , getOwnPropertyNames      = Object.getOwnPropertyNames
  , getOwnPropertySymbols    = Object.getOwnPropertySymbols;

module.exports = function (target, source) {
	var error, sourceObject = Object(value(source));
	target = Object(value(target));
	getOwnPropertyNames(sourceObject).forEach(function (name) {
		try {
			defineProperty(target, name, getOwnPropertyDescriptor(source, name));
		} catch (e) { error = e; }
	});
	if (typeof getOwnPropertySymbols === "function") {
		getOwnPropertySymbols(sourceObject).forEach(function (symbol) {
			try {
				defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
			} catch (e) { error = e; }
		});
	}
	if (error !== undefined) throw error;
	return target;
};


/***/ }),

/***/ 96872:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(11353);

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

// eslint-disable-next-line no-unused-vars
module.exports = function (opts1/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (!isValue(options)) return;
		process(Object(options), result);
	});
	return result;
};


/***/ }),

/***/ 19343:
/***/ (function(module) {

"use strict";


var forEach = Array.prototype.forEach, create = Object.create;

// eslint-disable-next-line no-unused-vars
module.exports = function (arg/*, …args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};


/***/ }),

/***/ 16907:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(44467)() ? Object.setPrototypeOf : __webpack_require__(12659);


/***/ }),

/***/ 44467:
/***/ (function(module) {

"use strict";


var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

module.exports = function (/* CustomCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== "function") return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
};


/***/ }),

/***/ 12659:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint no-proto: "off" */

// Big thanks to @WebReflection for sorting this out
// https://gist.github.com/WebReflection/5593554



var isObject         = __webpack_require__(95690)
  , value            = __webpack_require__(32977)
  , objIsPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty   = Object.defineProperty
  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if (prototype === null || isObject(prototype)) return obj;
	throw new TypeError("Prototype must be null or an object");
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, "level", {
		configurable: false,
		enumerable: false,
		writable: false,
		value: status.level
	});
})(
	(function () {
		var tmpObj1 = Object.create(null)
		  , tmpObj2 = {}
		  , set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(tmpObj1, tmpObj2);
			} catch (ignore) {}
			if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
		}

		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

		tmpObj1 = {};
		tmpObj1.__proto__ = tmpObj2;
		if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

		return false;
	})()
);

__webpack_require__(98693);


/***/ }),

/***/ 82678:
/***/ (function(module) {

"use strict";


module.exports = function (fn) {
	if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
	return fn;
};


/***/ }),

/***/ 73565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(95690);

module.exports = function (value) {
	if (!isObject(value)) throw new TypeError(value + " is not an Object");
	return value;
};


/***/ }),

/***/ 32977:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(11353);

module.exports = function (value) {
	if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
	return value;
};


/***/ }),

/***/ 5570:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var ensureValue   = __webpack_require__(32977)
  , stringifiable = __webpack_require__(69416);

module.exports = function (value) { return stringifiable(ensureValue(value)); };


/***/ }),

/***/ 69416:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(6812);

module.exports = function (stringifiable) {
	try {
		if (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();
		return String(stringifiable);
	} catch (e) {
		throw new TypeError("Passed argument cannot be stringifed");
	}
};


/***/ }),

/***/ 40528:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(6812);

module.exports = function (value) {
	try {
		if (value && isCallable(value.toString)) return value.toString();
		return String(value);
	} catch (e) {
		return "<Non-coercible to string value>";
	}
};


/***/ }),

/***/ 64623:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(50785)() ? String.prototype.contains : __webpack_require__(77062);


/***/ }),

/***/ 50785:
/***/ (function(module) {

"use strict";


var str = "razdwatrzy";

module.exports = function () {
	if (typeof str.contains !== "function") return false;
	return str.contains("dwa") === true && str.contains("foo") === false;
};


/***/ }),

/***/ 77062:
/***/ (function(module) {

"use strict";


var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};


/***/ }),

/***/ 42850:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(40972)() ? String.prototype.repeat : __webpack_require__(11465);


/***/ }),

/***/ 40972:
/***/ (function(module) {

"use strict";


var str = "foo";

module.exports = function () {
	if (typeof str.repeat !== "function") return false;
	return str.repeat(2) === "foofoo";
};


/***/ }),

/***/ 11465:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Thanks
// @rauchma http://www.2ality.com/2014/01/efficient-string-repeat.html
// @mathiasbynens https://github.com/mathiasbynens/String.prototype.repeat/blob/4a4b567def/repeat.js



var value     = __webpack_require__(32977)
  , toInteger = __webpack_require__(66329);

module.exports = function (count) {
	var str = String(value(this)), result;
	count = toInteger(count);
	if (count < 0) throw new RangeError("Count must be >= 0");
	if (!isFinite(count)) throw new RangeError("Count must be < ∞");

	result = "";
	while (count) {
		if (count % 2) result += str;
		if (count > 1) str += str;
		// eslint-disable-next-line no-bitwise
		count >>= 1;
	}
	return result;
};


/***/ }),

/***/ 13774:
/***/ (function(module) {

"use strict";


var objToString = Object.prototype.toString, id = objToString.call("");

module.exports = function (value) {
	return (
		typeof value === "string" ||
		(value &&
			typeof value === "object" &&
			(value instanceof String || objToString.call(value) === id)) ||
		false
	);
};


/***/ }),

/***/ 98797:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var safeToString = __webpack_require__(40528);

var reNewLine = /[\n\r\u2028\u2029]/g;

module.exports = function (value) {
	var string = safeToString(value);
	// Trim if too long
	if (string.length > 100) string = string.slice(0, 99) + "…";
	// Replace eventual new lines
	string = string.replace(reNewLine, function (char) {
		return JSON.stringify(char).slice(1, -1);
	});
	return string;
};


/***/ }),

/***/ 96154:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(16907)
  , contains       = __webpack_require__(64623)
  , d              = __webpack_require__(45214)
  , Symbol         = __webpack_require__(29724)
  , Iterator       = __webpack_require__(80988);

var defineProperty = Object.defineProperty, ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
	Iterator.call(this, arr);
	if (!kind) kind = "value";
	else if (contains.call(kind, "key+value")) kind = "key+value";
	else if (contains.call(kind, "key")) kind = "key";
	else kind = "value";
	defineProperty(this, "__kind__", d("", kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete ArrayIterator.prototype.constructor;

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	_resolve: d(function (i) {
		if (this.__kind__ === "value") return this.__list__[i];
		if (this.__kind__ === "key+value") return [i, this.__list__[i]];
		return i;
	})
});
defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d("c", "Array Iterator"));


/***/ }),

/***/ 31949:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(18640)
  , callable    = __webpack_require__(82678)
  , isString    = __webpack_require__(13774)
  , get         = __webpack_require__(35755);

var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;

module.exports = function (iterable, cb /*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = "array";
	else if (isString(iterable)) mode = "string";
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () {
		broken = true;
	};
	if (mode === "array") {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			return broken;
		});
		return;
	}
	if (mode === "string") {
		length = iterable.length;
		for (i = 0; i < length; ++i) {
			char = iterable[i];
			if (i + 1 < length) {
				code = char.charCodeAt(0);
				if (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};


/***/ }),

/***/ 35755:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isArguments    = __webpack_require__(18640)
  , isString       = __webpack_require__(13774)
  , ArrayIterator  = __webpack_require__(96154)
  , StringIterator = __webpack_require__(86628)
  , iterable       = __webpack_require__(22935)
  , iteratorSymbol = (__webpack_require__(29724).iterator);

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};


/***/ }),

/***/ 80988:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clear    = __webpack_require__(26939)
  , assign   = __webpack_require__(24185)
  , callable = __webpack_require__(82678)
  , value    = __webpack_require__(32977)
  , d        = __webpack_require__(45214)
  , autoBind = __webpack_require__(21491)
  , Symbol   = __webpack_require__(29724);

var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
	defineProperties(this, {
		__list__: d("w", value(list)),
		__context__: d("w", context),
		__nextIndex__: d("w", 0)
	});
	if (!context) return;
	callable(context.on);
	context.on("_add", this._onAdd);
	context.on("_delete", this._onDelete);
	context.on("_clear", this._onClear);
};

// Internal %IteratorPrototype% doesn't expose its constructor
delete Iterator.prototype.constructor;

defineProperties(
	Iterator.prototype,
	assign(
		{
			_next: d(function () {
				var i;
				if (!this.__list__) return undefined;
				if (this.__redo__) {
					i = this.__redo__.shift();
					if (i !== undefined) return i;
				}
				if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
				this._unBind();
				return undefined;
			}),
			next: d(function () {
				return this._createResult(this._next());
			}),
			_createResult: d(function (i) {
				if (i === undefined) return { done: true, value: undefined };
				return { done: false, value: this._resolve(i) };
			}),
			_resolve: d(function (i) {
				return this.__list__[i];
			}),
			_unBind: d(function () {
				this.__list__ = null;
				delete this.__redo__;
				if (!this.__context__) return;
				this.__context__.off("_add", this._onAdd);
				this.__context__.off("_delete", this._onDelete);
				this.__context__.off("_clear", this._onClear);
				this.__context__ = null;
			}),
			toString: d(function () {
				return "[object " + (this[Symbol.toStringTag] || "Object") + "]";
			})
		},
		autoBind({
			_onAdd: d(function (index) {
				if (index >= this.__nextIndex__) return;
				++this.__nextIndex__;
				if (!this.__redo__) {
					defineProperty(this, "__redo__", d("c", [index]));
					return;
				}
				this.__redo__.forEach(function (redo, i) {
					if (redo >= index) this.__redo__[i] = ++redo;
				}, this);
				this.__redo__.push(index);
			}),
			_onDelete: d(function (index) {
				var i;
				if (index >= this.__nextIndex__) return;
				--this.__nextIndex__;
				if (!this.__redo__) return;
				i = this.__redo__.indexOf(index);
				if (i !== -1) this.__redo__.splice(i, 1);
				this.__redo__.forEach(function (redo, j) {
					if (redo > index) this.__redo__[j] = --redo;
				}, this);
			}),
			_onClear: d(function () {
				if (this.__redo__) clear.call(this.__redo__);
				this.__nextIndex__ = 0;
			})
		})
	)
);

defineProperty(
	Iterator.prototype,
	Symbol.iterator,
	d(function () {
		return this;
	})
);


/***/ }),

/***/ 91951:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isArguments = __webpack_require__(18640)
  , isValue     = __webpack_require__(11353)
  , isString    = __webpack_require__(13774);

var iteratorSymbol = (__webpack_require__(29724).iterator)
  , isArray        = Array.isArray;

module.exports = function (value) {
	if (!isValue(value)) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return typeof value[iteratorSymbol] === "function";
};


/***/ }),

/***/ 86628:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols



var setPrototypeOf = __webpack_require__(16907)
  , d              = __webpack_require__(45214)
  , Symbol         = __webpack_require__(29724)
  , Iterator       = __webpack_require__(80988);

var defineProperty = Object.defineProperty, StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, "__length__", d("", str.length));
};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete StringIterator.prototype.constructor;

StringIterator.prototype = Object.create(Iterator.prototype, {
	_next: d(function () {
		if (!this.__list__) return undefined;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
		return undefined;
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];
		return char;
	})
});
defineProperty(StringIterator.prototype, Symbol.toStringTag, d("c", "String Iterator"));


/***/ }),

/***/ 22935:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isIterable = __webpack_require__(91951);

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};


/***/ }),

/***/ 29724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(3031)()
	? (__webpack_require__(6898).Symbol)
	: __webpack_require__(52086);


/***/ }),

/***/ 3031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var global     = __webpack_require__(6898)
  , validTypes = { object: true, symbol: true };

module.exports = function () {
	var Symbol = global.Symbol;
	var symbol;
	if (typeof Symbol !== "function") return false;
	symbol = Symbol("test symbol");
	try { String(symbol); }
	catch (e) { return false; }

	// Return 'true' also for polyfills
	if (!validTypes[typeof Symbol.iterator]) return false;
	if (!validTypes[typeof Symbol.toPrimitive]) return false;
	if (!validTypes[typeof Symbol.toStringTag]) return false;

	return true;
};


/***/ }),

/***/ 28841:
/***/ (function(module) {

"use strict";


module.exports = function (value) {
	if (!value) return false;
	if (typeof value === "symbol") return true;
	if (!value.constructor) return false;
	if (value.constructor.name !== "Symbol") return false;
	return value[value.constructor.toStringTag] === "Symbol";
};


/***/ }),

/***/ 30978:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d = __webpack_require__(45214);

var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;

var created = create(null);
module.exports = function (desc) {
	var postfix = 0, name, ie11BugWorkaround;
	while (created[desc + (postfix || "")]) ++postfix;
	desc += postfix || "";
	created[desc] = true;
	name = "@@" + desc;
	defineProperty(
		objPrototype,
		name,
		d.gs(null, function (value) {
			// For IE11 issue see:
			// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
			//    ie11-broken-getters-on-dom-objects
			// https://github.com/medikoo/es6-symbol/issues/12
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		})
	);
	return name;
};


/***/ }),

/***/ 34997:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d            = __webpack_require__(45214)
  , NativeSymbol = (__webpack_require__(6898).Symbol);

module.exports = function (SymbolPolyfill) {
	return Object.defineProperties(SymbolPolyfill, {
		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d(
			"", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill("hasInstance")
		),
		isConcatSpreadable: d(
			"",
			(NativeSymbol && NativeSymbol.isConcatSpreadable) ||
				SymbolPolyfill("isConcatSpreadable")
		),
		iterator: d("", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill("iterator")),
		match: d("", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill("match")),
		replace: d("", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill("replace")),
		search: d("", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill("search")),
		species: d("", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill("species")),
		split: d("", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill("split")),
		toPrimitive: d(
			"", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill("toPrimitive")
		),
		toStringTag: d(
			"", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill("toStringTag")
		),
		unscopables: d(
			"", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill("unscopables")
		)
	});
};


/***/ }),

/***/ 63669:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var d              = __webpack_require__(45214)
  , validateSymbol = __webpack_require__(19673);

var registry = Object.create(null);

module.exports = function (SymbolPolyfill) {
	return Object.defineProperties(SymbolPolyfill, {
		for: d(function (key) {
			if (registry[key]) return registry[key];
			return (registry[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d(function (symbol) {
			var key;
			validateSymbol(symbol);
			for (key in registry) {
				if (registry[key] === symbol) return key;
			}
			return undefined;
		})
	});
};


/***/ }),

/***/ 52086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// ES2015 Symbol polyfill for environments that do not (or partially) support it



var d                    = __webpack_require__(45214)
  , validateSymbol       = __webpack_require__(19673)
  , NativeSymbol         = (__webpack_require__(6898).Symbol)
  , generateName         = __webpack_require__(30978)
  , setupStandardSymbols = __webpack_require__(34997)
  , setupSymbolRegistry  = __webpack_require__(63669);

var create = Object.create
  , defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty;

var SymbolPolyfill, HiddenSymbol, isNativeSafe;

if (typeof NativeSymbol === "function") {
	try {
		String(NativeSymbol());
		isNativeSafe = true;
	} catch (ignore) {}
} else {
	NativeSymbol = null;
}

// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
	return SymbolPolyfill(description);
};

// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
	if (isNativeSafe) return NativeSymbol(description);
	symbol = create(HiddenSymbol.prototype);
	description = description === undefined ? "" : String(description);
	return defineProperties(symbol, {
		__description__: d("", description),
		__name__: d("", generateName(description))
	});
};

setupStandardSymbols(SymbolPolyfill);
setupSymbolRegistry(SymbolPolyfill);

// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d("", function () { return this.__name__; })
});

// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return "Symbol (" + validateSymbol(this).__description__ + ")"; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(
	SymbolPolyfill.prototype,
	SymbolPolyfill.toPrimitive,
	d("", function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === "symbol") return symbol;
		return symbol.toString();
	})
);
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));

// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(
	HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
);

// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(
	HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
);


/***/ }),

/***/ 19673:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(28841);

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};


/***/ }),

/***/ 47545:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var d        = __webpack_require__(45214)
  , callable = __webpack_require__(82678)

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;


/***/ }),

/***/ 15426:
/***/ (function(module) {

var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ is resolved with global context, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();


/***/ }),

/***/ 6898:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(74956)() ? globalThis : __webpack_require__(15426);


/***/ }),

/***/ 74956:
/***/ (function(module) {

"use strict";


module.exports = function () {
	if (typeof globalThis !== "object") return false;
	if (!globalThis) return false;
	return globalThis.Array === Array;
};


/***/ }),

/***/ 69378:
/***/ (function(module) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ 47305:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(43335);
const toRegexRange = __webpack_require__(21914);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ 78810:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "aU": function() { return /* binding */ r; },
  "lX": function() { return /* binding */ createBrowserHistory; },
  "q_": function() { return /* binding */ createHashHistory; },
  "PP": function() { return /* binding */ createMemoryHistory; },
  "Ep": function() { return /* binding */ I; },
  "cP": function() { return /* binding */ J; }
});

;// CONCATENATED MODULE: ../../node_modules/history/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ../../node_modules/history/index.js
var r,B=r||(r={});B.Pop="POP";B.Push="PUSH";B.Replace="REPLACE";var C= false?0:function(b){return b};function D(b,h){if(!b){"undefined"!==typeof console&&console.warn(h);try{throw Error(h);}catch(e){}}}function E(b){b.preventDefault();b.returnValue=""}
function F(){var b=[];return{get length(){return b.length},push:function(h){b.push(h);return function(){b=b.filter(function(e){return e!==h})}},call:function(h){b.forEach(function(e){return e&&e(h)})}}}function H(){return Math.random().toString(36).substr(2,8)}function I(b){var h=b.pathname;h=void 0===h?"/":h;var e=b.search;e=void 0===e?"":e;b=b.hash;b=void 0===b?"":b;e&&"?"!==e&&(h+="?"===e.charAt(0)?e:"?"+e);b&&"#"!==b&&(h+="#"===b.charAt(0)?b:"#"+b);return h}
function J(b){var h={};if(b){var e=b.indexOf("#");0<=e&&(h.hash=b.substr(e),b=b.substr(0,e));e=b.indexOf("?");0<=e&&(h.search=b.substr(e),b=b.substr(0,e));b&&(h.pathname=b)}return h}
function createBrowserHistory(b){function h(){var c=p.location,a=m.state||{};return[a.idx,C({pathname:c.pathname,search:c.search,hash:c.hash,state:a.usr||null,key:a.key||"default"})]}function e(c){return"string"===typeof c?c:I(c)}function x(c,a){void 0===a&&(a=null);return C(_extends({pathname:q.pathname,hash:"",search:""},"string"===typeof c?J(c):c,{state:a,key:H()}))}function z(c){t=c;c=h();v=c[0];q=c[1];d.call({action:t,location:q})}function A(c,a){function f(){A(c,a)}var l=r.Push,k=x(c,
a);if(!g.length||(g.call({action:l,location:k,retry:f}),!1)){var n=[{usr:k.state,key:k.key,idx:v+1},e(k)];k=n[0];n=n[1];try{m.pushState(k,"",n)}catch(G){p.location.assign(n)}z(l)}}function y(c,a){function f(){y(c,a)}var l=r.Replace,k=x(c,a);g.length&&(g.call({action:l,location:k,retry:f}),1)||(k=[{usr:k.state,key:k.key,idx:v},e(k)],m.replaceState(k[0],"",k[1]),z(l))}function w(c){m.go(c)}void 0===b&&(b={});b=b.window;var p=void 0===b?document.defaultView:b,m=p.history,u=null;p.addEventListener("popstate",
function(){if(u)g.call(u),u=null;else{var c=r.Pop,a=h(),f=a[0];a=a[1];if(g.length)if(null!=f){var l=v-f;l&&(u={action:c,location:a,retry:function(){w(-1*l)}},w(l))}else false?0:
void 0;else z(c)}});var t=r.Pop;b=h();var v=b[0],q=b[1],d=F(),g=F();null==v&&(v=0,m.replaceState(_extends({},m.state,{idx:v}),""));return{get action(){return t},get location(){return q},createHref:e,push:A,replace:y,go:w,back:function(){w(-1)},forward:function(){w(1)},listen:function(c){return d.push(c)},block:function(c){var a=g.push(c);1===g.length&&p.addEventListener("beforeunload",E);return function(){a();g.length||p.removeEventListener("beforeunload",E)}}}};
function createHashHistory(b){function h(){var a=J(m.location.hash.substr(1)),f=a.pathname,l=a.search;a=a.hash;var k=u.state||{};return[k.idx,C({pathname:void 0===f?"/":f,search:void 0===l?"":l,hash:void 0===a?"":a,state:k.usr||null,key:k.key||"default"})]}function e(){if(t)c.call(t),t=null;else{var a=r.Pop,f=h(),l=f[0];f=f[1];if(c.length)if(null!=l){var k=q-l;k&&(t={action:a,location:f,retry:function(){p(-1*k)}},p(k))}else false?0:
void 0;else A(a)}}function x(a){var f=document.querySelector("base"),l="";f&&f.getAttribute("href")&&(f=m.location.href,l=f.indexOf("#"),l=-1===l?f:f.slice(0,l));return l+"#"+("string"===typeof a?a:I(a))}function z(a,f){void 0===f&&(f=null);return C(_extends({pathname:d.pathname,hash:"",search:""},"string"===typeof a?J(a):a,{state:f,key:H()}))}function A(a){v=a;a=h();q=a[0];d=a[1];g.call({action:v,location:d})}function y(a,f){function l(){y(a,f)}var k=r.Push,n=z(a,f); false?
0:void 0;if(!c.length||(c.call({action:k,location:n,retry:l}),!1)){var G=[{usr:n.state,key:n.key,idx:q+1},x(n)];n=G[0];G=G[1];try{u.pushState(n,"",G)}catch(K){m.location.assign(G)}A(k)}}function w(a,f){function l(){w(a,f)}var k=r.Replace,n=z(a,f); false?0:void 0;c.length&&(c.call({action:k,location:n,retry:l}),1)||(n=[{usr:n.state,key:n.key,idx:q},x(n)],u.replaceState(n[0],"",n[1]),A(k))}function p(a){u.go(a)}void 0===b&&(b={});b=b.window;var m=void 0===b?document.defaultView:b,u=m.history,t=null;m.addEventListener("popstate",e);m.addEventListener("hashchange",function(){var a=h()[1];I(a)!==I(d)&&e()});var v=r.Pop;b=h();var q=b[0],d=b[1],g=F(),c=F();null==q&&(q=0,u.replaceState(_extends({},u.state,{idx:q}),""));return{get action(){return v},get location(){return d},
createHref:x,push:y,replace:w,go:p,back:function(){p(-1)},forward:function(){p(1)},listen:function(a){return g.push(a)},block:function(a){var f=c.push(a);1===c.length&&m.addEventListener("beforeunload",E);return function(){f();c.length||m.removeEventListener("beforeunload",E)}}}};
function createMemoryHistory(b){function h(d,g){void 0===g&&(g=null);return C(_extends({pathname:t.pathname,search:"",hash:""},"string"===typeof d?J(d):d,{state:g,key:H()}))}function e(d,g,c){return!q.length||(q.call({action:d,location:g,retry:c}),!1)}function x(d,g){u=d;t=g;v.call({action:u,location:t})}function z(d,g){var c=r.Push,a=h(d,g); false?0:
void 0;e(c,a,function(){z(d,g)})&&(m+=1,p.splice(m,p.length,a),x(c,a))}function A(d,g){var c=r.Replace,a=h(d,g); false?0:void 0;e(c,a,function(){A(d,g)})&&(p[m]=a,x(c,a))}function y(d){var g=Math.min(Math.max(m+d,0),p.length-1),c=r.Pop,a=p[g];e(c,a,function(){y(d)})&&(m=g,x(c,a))}void 0===b&&(b={});var w=b;b=w.initialEntries;w=w.initialIndex;var p=(void 0===
b?["/"]:b).map(function(d){var g=C(_extends({pathname:"/",search:"",hash:"",state:null,key:H()},"string"===typeof d?J(d):d)); false?0:void 0;return g}),m=Math.min(Math.max(null==w?p.length-1:w,0),p.length-1),u=r.Pop,t=p[m],v=F(),q=F();return{get index(){return m},get action(){return u},get location(){return t},createHref:function(d){return"string"===
typeof d?d:I(d)},push:z,replace:A,go:y,back:function(){y(-1)},forward:function(){y(1)},listen:function(d){return v.push(d)},block:function(d){return q.push(d)}}};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 73463:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(48570);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ 99320:
/***/ (function(module) {

module.exports = isPromise;
module.exports["default"] = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}


/***/ }),

/***/ 19522:
/***/ (function(module) {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ 77485:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 63211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ 51344:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeMax = Math.max,
    nativeNow = Date.now;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = merge;


/***/ }),

/***/ 880:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),

/***/ 17694:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(23701)

  , create = Object.create, hasOwnProperty = Object.prototype.hasOwnProperty;

module.exports = function (limit) {
	var size = 0, base = 1, queue = create(null), map = create(null), index = 0, del;
	limit = toPosInt(limit);
	return {
		hit: function (id) {
			var oldIndex = map[id], nuIndex = ++index;
			queue[nuIndex] = id;
			map[id] = nuIndex;
			if (!oldIndex) {
				++size;
				if (size <= limit) return;
				id = queue[base];
				del(id);
				return id;
			}
			delete queue[oldIndex];
			if (base !== oldIndex) return;
			while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
		},
		delete: del = function (id) {
			var oldIndex = map[id];
			if (!oldIndex) return;
			delete queue[oldIndex];
			delete map[id];
			--size;
			if (base !== oldIndex) return;
			if (!size) {
				index = 0;
				base = 1;
				return;
			}
			while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
		},
		clear: function () {
			size = 0;
			base = 1;
			queue = create(null);
			map = create(null);
			index = 0;
		}
	};
};


/***/ }),

/***/ 6237:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */

// Support for asynchronous functions



var aFrom        = __webpack_require__(73417)
  , objectMap    = __webpack_require__(99591)
  , mixin        = __webpack_require__(42869)
  , defineLength = __webpack_require__(33864)
  , nextTick     = __webpack_require__(7325);

var slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;

(__webpack_require__(39313).async) = function (tbi, conf) {
	var waiting = create(null)
	  , cache = create(null)
	  , base = conf.memoized
	  , original = conf.original
	  , currentCallback
	  , currentContext
	  , currentArgs;

	// Initial
	conf.memoized = defineLength(function (arg) {
		var args = arguments, last = args[args.length - 1];
		if (typeof last === "function") {
			currentCallback = last;
			args = slice.call(args, 0, -1);
		}
		return base.apply(currentContext = this, currentArgs = args);
	}, base);
	try { mixin(conf.memoized, base); }
	catch (ignore) {}

	// From cache (sync)
	conf.on("get", function (id) {
		var cb, context, args;
		if (!currentCallback) return;

		// Unresolved
		if (waiting[id]) {
			if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
			else waiting[id].push(currentCallback);
			currentCallback = null;
			return;
		}

		// Resolved, assure next tick invocation
		cb = currentCallback;
		context = currentContext;
		args = currentArgs;
		currentCallback = currentContext = currentArgs = null;
		nextTick(function () {
			var data;
			if (hasOwnProperty.call(cache, id)) {
				data = cache[id];
				conf.emit("getasync", id, args, context);
				apply.call(cb, data.context, data.args);
			} else {
				// Purged in a meantime, we shouldn't rely on cached value, recall
				currentCallback = cb;
				currentContext = context;
				currentArgs = args;
				base.apply(context, args);
			}
		});
	});

	// Not from cache
	conf.original = function () {
		var args, cb, origCb, result;
		if (!currentCallback) return apply.call(original, this, arguments);
		args = aFrom(arguments);
		cb = function self(err) {
			var cb, args, id = self.id;
			if (id == null) {
				// Shouldn't happen, means async callback was called sync way
				nextTick(apply.bind(self, this, arguments));
				return undefined;
			}
			delete self.id;
			cb = waiting[id];
			delete waiting[id];
			if (!cb) {
				// Already processed,
				// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
				return undefined;
			}
			args = aFrom(arguments);
			if (conf.has(id)) {
				if (err) {
					conf.delete(id);
				} else {
					cache[id] = { context: this, args: args };
					conf.emit("setasync", id, typeof cb === "function" ? 1 : cb.length);
				}
			}
			if (typeof cb === "function") {
				result = apply.call(cb, this, args);
			} else {
				cb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);
			}
			return result;
		};
		origCb = currentCallback;
		currentCallback = currentContext = currentArgs = null;
		args.push(cb);
		result = apply.call(original, this, args);
		cb.cb = origCb;
		currentCallback = cb;
		return result;
	};

	// After not from cache call
	conf.on("set", function (id) {
		if (!currentCallback) {
			conf.delete(id);
			return;
		}
		if (waiting[id]) {
			// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
			if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
			else waiting[id].push(currentCallback.cb);
		} else {
			waiting[id] = currentCallback.cb;
		}
		delete currentCallback.cb;
		currentCallback.id = id;
		currentCallback = null;
	});

	// On delete
	conf.on("delete", function (id) {
		var result;
		// If false, we don't have value yet, so we assume that intention is not
		// to memoize this call. After value is obtained we don't cache it but
		// gracefully pass to callback
		if (hasOwnProperty.call(waiting, id)) return;
		if (!cache[id]) return;
		result = cache[id];
		delete cache[id];
		conf.emit("deleteasync", id, slice.call(result.args, 1));
	});

	// On clear
	conf.on("clear", function () {
		var oldCache = cache;
		cache = create(null);
		conf.emit(
			"clearasync", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })
		);
	});
};


/***/ }),

/***/ 15950:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Call dispose callback on each cache purge



var callable   = __webpack_require__(82678)
  , forEach    = __webpack_require__(69506)
  , extensions = __webpack_require__(39313)

  , apply = Function.prototype.apply;

extensions.dispose = function (dispose, conf, options) {
	var del;
	callable(dispose);
	if ((options.async && extensions.async) || (options.promise && extensions.promise)) {
		conf.on("deleteasync", del = function (id, resultArray) {
			apply.call(dispose, null, resultArray);
		});
		conf.on("clearasync", function (cache) {
			forEach(cache, function (result, id) {
 del(id, result);
});
		});
		return;
	}
	conf.on("delete", del = function (id, result) {
 dispose(result);
});
	conf.on("clear", function (cache) {
		forEach(cache, function (result, id) {
 del(id, result);
});
	});
};


/***/ }),

/***/ 62140:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint consistent-this: 0 */

// Timeout cached values



var aFrom      = __webpack_require__(73417)
  , forEach    = __webpack_require__(69506)
  , nextTick   = __webpack_require__(7325)
  , isPromise  = __webpack_require__(99320)
  , timeout    = __webpack_require__(47987)
  , extensions = __webpack_require__(39313);

var noop = Function.prototype, max = Math.max, min = Math.min, create = Object.create;

extensions.maxAge = function (maxAge, conf, options) {
	var timeouts, postfix, preFetchAge, preFetchTimeouts;

	maxAge = timeout(maxAge);
	if (!maxAge) return;

	timeouts = create(null);
	postfix =
		(options.async && extensions.async) || (options.promise && extensions.promise)
			? "async"
			: "";
	conf.on("set" + postfix, function (id) {
		timeouts[id] = setTimeout(function () { conf.delete(id); }, maxAge);
		if (typeof timeouts[id].unref === "function") timeouts[id].unref();
		if (!preFetchTimeouts) return;
		if (preFetchTimeouts[id]) {
			if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
		}
		preFetchTimeouts[id] = setTimeout(function () {
			delete preFetchTimeouts[id];
		}, preFetchAge);
		if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
	});
	conf.on("delete" + postfix, function (id) {
		clearTimeout(timeouts[id]);
		delete timeouts[id];
		if (!preFetchTimeouts) return;
		if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
		delete preFetchTimeouts[id];
	});

	if (options.preFetch) {
		if (options.preFetch === true || isNaN(options.preFetch)) {
			preFetchAge = 0.333;
		} else {
			preFetchAge = max(min(Number(options.preFetch), 1), 0);
		}
		if (preFetchAge) {
			preFetchTimeouts = {};
			preFetchAge = (1 - preFetchAge) * maxAge;
			conf.on("get" + postfix, function (id, args, context) {
				if (!preFetchTimeouts[id]) {
					preFetchTimeouts[id] = "nextTick";
					nextTick(function () {
						var result;
						if (preFetchTimeouts[id] !== "nextTick") return;
						delete preFetchTimeouts[id];
						conf.delete(id);
						if (options.async) {
							args = aFrom(args);
							args.push(noop);
						}
						result = conf.memoized.apply(context, args);
						if (options.promise) {
							// Supress eventual error warnings
							if (isPromise(result)) {
								if (typeof result.done === "function") result.done(noop, noop);
								else result.then(noop, noop);
							}
						}
					});
				}
			});
		}
	}

	conf.on("clear" + postfix, function () {
		forEach(timeouts, function (id) { clearTimeout(id); });
		timeouts = {};
		if (preFetchTimeouts) {
			forEach(preFetchTimeouts, function (id) { if (id !== "nextTick") clearTimeout(id); });
			preFetchTimeouts = {};
		}
	});
};


/***/ }),

/***/ 50643:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Limit cache size, LRU (least recently used) algorithm.



var toPosInteger = __webpack_require__(23701)
  , lruQueue     = __webpack_require__(17694)
  , extensions   = __webpack_require__(39313);

extensions.max = function (max, conf, options) {
	var postfix, queue, hit;

	max = toPosInteger(max);
	if (!max) return;

	queue = lruQueue(max);
	postfix = (options.async && extensions.async) || (options.promise && extensions.promise)
		? "async" : "";

	conf.on("set" + postfix, hit = function (id) {
		id = queue.hit(id);
		if (id === undefined) return;
		conf.delete(id);
	});
	conf.on("get" + postfix, hit);
	conf.on("delete" + postfix, queue.delete);
	conf.on("clear" + postfix, queue.clear);
};


/***/ }),

/***/ 64168:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint max-statements: 0 */

// Support for functions returning promise



var objectMap     = __webpack_require__(99591)
  , primitiveSet  = __webpack_require__(19343)
  , ensureString  = __webpack_require__(5570)
  , toShortString = __webpack_require__(98797)
  , isPromise     = __webpack_require__(99320)
  , nextTick      = __webpack_require__(7325);

var create = Object.create
  , supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");

(__webpack_require__(39313).promise) = function (mode, conf) {
	var waiting = create(null), cache = create(null), promises = create(null);

	if (mode === true) {
		mode = null;
	} else {
		mode = ensureString(mode);
		if (!supportedModes[mode]) {
			throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
		}
	}

	// After not from cache call
	conf.on("set", function (id, ignore, promise) {
		var isFailed = false;

		if (!isPromise(promise)) {
			// Non promise result
			cache[id] = promise;
			conf.emit("setasync", id, 1);
			return;
		}
		waiting[id] = 1;
		promises[id] = promise;
		var onSuccess = function (result) {
			var count = waiting[id];
			if (isFailed) {
				throw new Error(
					"Memoizee error: Detected unordered then|done & finally resolution, which " +
						"in turn makes proper detection of success/failure impossible (when in " +
						"'done:finally' mode)\n" +
						"Consider to rely on 'then' or 'done' mode instead."
				);
			}
			if (!count) return; // Deleted from cache before resolved
			delete waiting[id];
			cache[id] = result;
			conf.emit("setasync", id, count);
		};
		var onFailure = function () {
			isFailed = true;
			if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)
			delete waiting[id];
			delete promises[id];
			conf.delete(id);
		};

		var resolvedMode = mode;
		if (!resolvedMode) resolvedMode = "then";

		if (resolvedMode === "then") {
			var nextTickFailure = function () { nextTick(onFailure); };
			// Eventual finally needs to be attached to non rejected promise
			// (so we not force propagation of unhandled rejection)
			promise = promise.then(function (result) {
				nextTick(onSuccess.bind(this, result));
			}, nextTickFailure);
			// If `finally` is a function we attach to it to remove cancelled promises.
			if (typeof promise.finally === "function") {
				promise.finally(nextTickFailure);
			}
		} else if (resolvedMode === "done") {
			// Not recommended, as it may mute any eventual "Unhandled error" events
			if (typeof promise.done !== "function") {
				throw new Error(
					"Memoizee error: Retrieved promise does not implement 'done' " +
						"in 'done' mode"
				);
			}
			promise.done(onSuccess, onFailure);
		} else if (resolvedMode === "done:finally") {
			// The only mode with no side effects assuming library does not throw unconditionally
			// for rejected promises.
			if (typeof promise.done !== "function") {
				throw new Error(
					"Memoizee error: Retrieved promise does not implement 'done' " +
						"in 'done:finally' mode"
				);
			}
			if (typeof promise.finally !== "function") {
				throw new Error(
					"Memoizee error: Retrieved promise does not implement 'finally' " +
						"in 'done:finally' mode"
				);
			}
			promise.done(onSuccess);
			promise.finally(onFailure);
		}
	});

	// From cache (sync)
	conf.on("get", function (id, args, context) {
		var promise;
		if (waiting[id]) {
			++waiting[id]; // Still waiting
			return;
		}
		promise = promises[id];
		var emit = function () { conf.emit("getasync", id, args, context); };
		if (isPromise(promise)) {
			if (typeof promise.done === "function") promise.done(emit);
			else {
				promise.then(function () { nextTick(emit); });
			}
		} else {
			emit();
		}
	});

	// On delete
	conf.on("delete", function (id) {
		delete promises[id];
		if (waiting[id]) {
			delete waiting[id];
			return; // Not yet resolved
		}
		if (!hasOwnProperty.call(cache, id)) return;
		var result = cache[id];
		delete cache[id];
		conf.emit("deleteasync", id, [result]);
	});

	// On clear
	conf.on("clear", function () {
		var oldCache = cache;
		cache = create(null);
		waiting = create(null);
		promises = create(null);
		conf.emit("clearasync", objectMap(oldCache, function (data) { return [data]; }));
	});
};


/***/ }),

/***/ 41130:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// Reference counter, useful for garbage collector like functionality



var d          = __webpack_require__(45214)
  , extensions = __webpack_require__(39313)

  , create = Object.create, defineProperties = Object.defineProperties;

extensions.refCounter = function (ignore, conf, options) {
	var cache, postfix;

	cache = create(null);
	postfix = (options.async && extensions.async) || (options.promise && extensions.promise)
		? "async" : "";

	conf.on("set" + postfix, function (id, length) {
 cache[id] = length || 1;
});
	conf.on("get" + postfix, function (id) {
 ++cache[id];
});
	conf.on("delete" + postfix, function (id) {
 delete cache[id];
});
	conf.on("clear" + postfix, function () {
 cache = {};
});

	defineProperties(conf.memoized, {
		deleteRef: d(function () {
			var id = conf.get(arguments);
			if (id === null) return null;
			if (!cache[id]) return null;
			if (!--cache[id]) {
				conf.delete(id);
				return true;
			}
			return false;
		}),
		getRefCount: d(function () {
			var id = conf.get(arguments);
			if (id === null) return 0;
			if (!cache[id]) return 0;
			return cache[id];
		})
	});
};


/***/ }),

/***/ 23556:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var normalizeOpts = __webpack_require__(96872)
  , resolveLength = __webpack_require__(50881)
  , plain         = __webpack_require__(58531);

module.exports = function (fn/*, options*/) {
	var options = normalizeOpts(arguments[1]), length;

	if (!options.normalizer) {
		length = options.length = resolveLength(options.length, fn.length, options.async);
		if (length !== 0) {
			if (options.primitive) {
				if (length === false) {
					options.normalizer = __webpack_require__(60804);
				} else if (length > 1) {
					options.normalizer = __webpack_require__(9685)(length);
				}
			} else if (length === false) options.normalizer = __webpack_require__(68066)();
				else if (length === 1) options.normalizer = __webpack_require__(82413)();
				else options.normalizer = __webpack_require__(31825)(length);
		}
	}

	// Assure extensions
	if (options.async) __webpack_require__(6237);
	if (options.promise) __webpack_require__(64168);
	if (options.dispose) __webpack_require__(15950);
	if (options.maxAge) __webpack_require__(62140);
	if (options.max) __webpack_require__(50643);
	if (options.refCounter) __webpack_require__(41130);

	return plain(fn, options);
};


/***/ }),

/***/ 76717:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */



var customError      = __webpack_require__(28455)
  , defineLength     = __webpack_require__(33864)
  , d                = __webpack_require__(45214)
  , ee               = (__webpack_require__(47545).methods)
  , resolveResolve   = __webpack_require__(33395)
  , resolveNormalize = __webpack_require__(13886);

var apply = Function.prototype.apply
  , call = Function.prototype.call
  , create = Object.create
  , defineProperties = Object.defineProperties
  , on = ee.on
  , emit = ee.emit;

module.exports = function (original, length, options) {
	var cache = create(null)
	  , conf
	  , memLength
	  , get
	  , set
	  , del
	  , clear
	  , extDel
	  , extGet
	  , extHas
	  , normalizer
	  , getListeners
	  , setListeners
	  , deleteListeners
	  , memoized
	  , resolve;
	if (length !== false) memLength = length;
	else if (isNaN(original.length)) memLength = 1;
	else memLength = original.length;

	if (options.normalizer) {
		normalizer = resolveNormalize(options.normalizer);
		get = normalizer.get;
		set = normalizer.set;
		del = normalizer.delete;
		clear = normalizer.clear;
	}
	if (options.resolvers != null) resolve = resolveResolve(options.resolvers);

	if (get) {
		memoized = defineLength(function (arg) {
			var id, result, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id !== null) {
				if (hasOwnProperty.call(cache, id)) {
					if (getListeners) conf.emit("get", id, args, this);
					return cache[id];
				}
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (id === null) {
				id = get(args);
				if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
				id = set(args);
			} else if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		}, memLength);
	} else if (length === 0) {
		memoized = function () {
			var result;
			if (hasOwnProperty.call(cache, "data")) {
				if (getListeners) conf.emit("get", "data", arguments, this);
				return cache.data;
			}
			if (arguments.length) result = apply.call(original, this, arguments);
			else result = call.call(original, this);
			if (hasOwnProperty.call(cache, "data")) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache.data = result;
			if (setListeners) conf.emit("set", "data", null, result);
			return result;
		};
	} else {
		memoized = function (arg) {
			var result, args = arguments, id;
			if (resolve) args = resolve(arguments);
			id = String(args[0]);
			if (hasOwnProperty.call(cache, id)) {
				if (getListeners) conf.emit("get", id, args, this);
				return cache[id];
			}
			if (args.length === 1) result = call.call(original, this, args[0]);
			else result = apply.call(original, this, args);
			if (hasOwnProperty.call(cache, id)) {
				throw customError("Circular invocation", "CIRCULAR_INVOCATION");
			}
			cache[id] = result;
			if (setListeners) conf.emit("set", id, null, result);
			return result;
		};
	}
	conf = {
		original: original,
		memoized: memoized,
		profileName: options.profileName,
		get: function (args) {
			if (resolve) args = resolve(args);
			if (get) return get(args);
			return String(args[0]);
		},
		has: function (id) { return hasOwnProperty.call(cache, id); },
		delete: function (id) {
			var result;
			if (!hasOwnProperty.call(cache, id)) return;
			if (del) del(id);
			result = cache[id];
			delete cache[id];
			if (deleteListeners) conf.emit("delete", id, result);
		},
		clear: function () {
			var oldCache = cache;
			if (clear) clear();
			cache = create(null);
			conf.emit("clear", oldCache);
		},
		on: function (type, listener) {
			if (type === "get") getListeners = true;
			else if (type === "set") setListeners = true;
			else if (type === "delete") deleteListeners = true;
			return on.call(this, type, listener);
		},
		emit: emit,
		updateEnv: function () { original = conf.original; }
	};
	if (get) {
		extDel = defineLength(function (arg) {
			var id, args = arguments;
			if (resolve) args = resolve(args);
			id = get(args);
			if (id === null) return;
			conf.delete(id);
		}, memLength);
	} else if (length === 0) {
		extDel = function () { return conf.delete("data"); };
	} else {
		extDel = function (arg) {
			if (resolve) arg = resolve(arguments)[0];
			return conf.delete(arg);
		};
	}
	extGet = defineLength(function () {
		var id, args = arguments;
		if (length === 0) return cache.data;
		if (resolve) args = resolve(args);
		if (get) id = get(args);
		else id = String(args[0]);
		return cache[id];
	});
	extHas = defineLength(function () {
		var id, args = arguments;
		if (length === 0) return conf.has("data");
		if (resolve) args = resolve(args);
		if (get) id = get(args);
		else id = String(args[0]);
		if (id === null) return false;
		return conf.has(id);
	});
	defineProperties(memoized, {
		__memoized__: d(true),
		delete: d(extDel),
		clear: d(conf.clear),
		_get: d(extGet),
		_has: d(extHas)
	});
	return conf;
};


/***/ }),

/***/ 13913:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var forEach       = __webpack_require__(69506)
  , normalizeOpts = __webpack_require__(96872)
  , callable      = __webpack_require__(82678)
  , lazy          = __webpack_require__(7610)
  , resolveLength = __webpack_require__(50881)
  , extensions    = __webpack_require__(39313);

module.exports = function (memoize) {
	return function (props) {
		forEach(props, function (desc) {
			var fn = callable(desc.value), length;
			desc.value = function (options) {
				if (options.getNormalizer) {
					options = normalizeOpts(options);
					if (length === undefined) {
						length = resolveLength(
							options.length,
							fn.length,
							options.async && extensions.async
						);
					}
					options.normalizer = options.getNormalizer(length);
					delete options.getNormalizer;
				}
				return memoize(fn.bind(this), options);
			};
		});
		return lazy(props);
	};
};


/***/ }),

/***/ 39313:
/***/ (function() {

"use strict";



/***/ }),

/***/ 50881:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt = __webpack_require__(23701);

module.exports = function (optsLength, fnLength, isAsync) {
	var length;
	if (isNaN(optsLength)) {
		length = fnLength;
		if (!(length >= 0)) return 1;
		if (isAsync && length) return length - 1;
		return length;
	}
	if (optsLength === false) return false;
	return toPosInt(optsLength);
};


/***/ }),

/***/ 13886:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callable = __webpack_require__(82678);

module.exports = function (userNormalizer) {
	var normalizer;
	if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
	normalizer = { get: callable(userNormalizer.get) };
	if (userNormalizer.set !== undefined) {
		normalizer.set = callable(userNormalizer.set);
		if (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);
		if (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);
		return normalizer;
	}
	normalizer.set = normalizer.get;
	return normalizer;
};


/***/ }),

/***/ 33395:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toArray  = __webpack_require__(64089)
  , isValue  = __webpack_require__(11353)
  , callable = __webpack_require__(82678);

var slice = Array.prototype.slice, resolveArgs;

resolveArgs = function (args) {
	return this.map(function (resolve, i) {
		return resolve ? resolve(args[i]) : args[i];
	}).concat(slice.call(args, this.length));
};

module.exports = function (resolvers) {
	resolvers = toArray(resolvers);
	resolvers.forEach(function (resolve) {
		if (isValue(resolve)) callable(resolve);
	});
	return resolveArgs.bind(resolvers);
};


/***/ }),

/***/ 64711:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(13913)(__webpack_require__(23556));


/***/ }),

/***/ 82413:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var indexOf = __webpack_require__(45148);

module.exports = function () {
	var lastId = 0, argsMap = [], cache = [];
	return {
		get: function (args) {
			var index = indexOf.call(argsMap, args[0]);
			return index === -1 ? null : cache[index];
		},
		set: function (args) {
			argsMap.push(args[0]);
			cache.push(++lastId);
			return lastId;
		},
		delete: function (id) {
			var index = indexOf.call(cache, id);
			if (index !== -1) {
				argsMap.splice(index, 1);
				cache.splice(index, 1);
			}
		},
		clear: function () {
			argsMap = [];
			cache = [];
		}
	};
};


/***/ }),

/***/ 31825:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var indexOf = __webpack_require__(45148)
  , create  = Object.create;

module.exports = function (length) {
	var lastId = 0, map = [[], []], cache = create(null);
	return {
		get: function (args) {
			var index = 0, set = map, i;
			while (index < length - 1) {
				i = indexOf.call(set[0], args[index]);
				if (i === -1) return null;
				set = set[1][i];
				++index;
			}
			i = indexOf.call(set[0], args[index]);
			if (i === -1) return null;
			return set[1][i] || null;
		},
		set: function (args) {
			var index = 0, set = map, i;
			while (index < length - 1) {
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					i = set[0].push(args[index]) - 1;
					set[1].push([[], []]);
				}
				set = set[1][i];
				++index;
			}
			i = indexOf.call(set[0], args[index]);
			if (i === -1) {
				i = set[0].push(args[index]) - 1;
			}
			set[1][i] = ++lastId;
			cache[lastId] = args;
			return lastId;
		},
		delete: function (id) {
			var index = 0, set = map, i, path = [], args = cache[id];
			while (index < length - 1) {
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					return;
				}
				path.push(set, i);
				set = set[1][i];
				++index;
			}
			i = indexOf.call(set[0], args[index]);
			if (i === -1) {
				return;
			}
			id = set[1][i];
			set[0].splice(i, 1);
			set[1].splice(i, 1);
			while (!set[0].length && path.length) {
				i = path.pop();
				set = path.pop();
				set[0].splice(i, 1);
				set[1].splice(i, 1);
			}
			delete cache[id];
		},
		clear: function () {
			map = [[], []];
			cache = create(null);
		}
	};
};


/***/ }),

/***/ 9685:
/***/ (function(module) {

"use strict";


module.exports = function (length) {
	if (!length) {
		return function () {
			return "";
		};
	}
	return function (args) {
		var id = String(args[0]), i = 0, currentLength = length;
		while (--currentLength) {
			id += "\u0001" + args[++i];
		}
		return id;
	};
};


/***/ }),

/***/ 68066:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* eslint max-statements: 0 */



var indexOf = __webpack_require__(45148);

var create = Object.create;

module.exports = function () {
	var lastId = 0, map = [], cache = create(null);
	return {
		get: function (args) {
			var index = 0, set = map, i, length = args.length;
			if (length === 0) return set[length] || null;
			if ((set = set[length])) {
				while (index < length - 1) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) return null;
				return set[1][i] || null;
			}
			return null;
		},
		set: function (args) {
			var index = 0, set = map, i, length = args.length;
			if (length === 0) {
				set[length] = ++lastId;
			} else {
				if (!set[length]) {
					set[length] = [[], []];
				}
				set = set[length];
				while (index < length - 1) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
						set[1].push([[], []]);
					}
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					i = set[0].push(args[index]) - 1;
				}
				set[1][i] = ++lastId;
			}
			cache[lastId] = args;
			return lastId;
		},
		delete: function (id) {
			var index = 0, set = map, i, args = cache[id], length = args.length, path = [];
			if (length === 0) {
				delete set[length];
			} else if ((set = set[length])) {
				while (index < length - 1) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					path.push(set, i);
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					return;
				}
				id = set[1][i];
				set[0].splice(i, 1);
				set[1].splice(i, 1);
				while (!set[0].length && path.length) {
					i = path.pop();
					set = path.pop();
					set[0].splice(i, 1);
					set[1].splice(i, 1);
				}
			}
			delete cache[id];
		},
		clear: function () {
			map = [];
			cache = create(null);
		}
	};
};


/***/ }),

/***/ 60804:
/***/ (function(module) {

"use strict";


module.exports = function (args) {
	var id, i, length = args.length;
	if (!length) return "\u0002";
	id = String(args[i = 0]);
	while (--length) id += "\u0001" + args[++i];
	return id;
};


/***/ }),

/***/ 58531:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callable      = __webpack_require__(82678)
  , forEach       = __webpack_require__(69506)
  , extensions    = __webpack_require__(39313)
  , configure     = __webpack_require__(76717)
  , resolveLength = __webpack_require__(50881);

module.exports = function self(fn /*, options */) {
	var options, length, conf;

	callable(fn);
	options = Object(arguments[1]);

	if (options.async && options.promise) {
		throw new Error("Options 'async' and 'promise' cannot be used together");
	}

	// Do not memoize already memoized function
	if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;

	// Resolve length;
	length = resolveLength(options.length, fn.length, options.async && extensions.async);

	// Configure cache map
	conf = configure(fn, length, options);

	// Bind eventual extensions
	forEach(extensions, function (extFn, name) {
		if (options[name]) extFn(options[name], conf, options);
	});

	if (self.__profiler__) self.__profiler__(conf);

	conf.updateEnv();
	return conf.memoized;
};


/***/ }),

/***/ 7325:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


var ensureCallable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

var byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		ensureCallable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
		return process.nextTick;
	}

	// queueMicrotask
	if (typeof queueMicrotask === "function") {
		return function (cb) { queueMicrotask(ensureCallable(cb)); };
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(ensureCallable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(ensureCallable(cb), 0); };
	}

	return null;
}());


/***/ }),

/***/ 7360:
/***/ (function(module) {

/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

module.exports = function(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';

  var len = path.length;
  if (len <= 1) return path;

  // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
  var prefix = '';
  if (len > 4 && path[3] === '\\') {
    var ch = path[2];
    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }
  return prefix + segs.join('/');
};


/***/ }),

/***/ 21023:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ 4763:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(32595);


/***/ }),

/***/ 47411:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(21023);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ 52902:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const constants = __webpack_require__(47411);
const utils = __webpack_require__(53338);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        output = token.close = `)${rest})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ 32595:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const path = __webpack_require__(21023);
const scan = __webpack_require__(4933);
const parse = __webpack_require__(52902);
const utils = __webpack_require__(53338);
const constants = __webpack_require__(47411);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ 4933:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


const utils = __webpack_require__(53338);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(47411);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ 53338:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


const path = __webpack_require__(21023);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(47411);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),

/***/ 34406:
/***/ (function(module) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 66866:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),

/***/ 48570:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(66866);
} else {}


/***/ }),

/***/ 66794:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Provider": function() { return /* reexport */ components_Provider; },
  "ReactReduxContext": function() { return /* reexport */ ReactReduxContext; },
  "batch": function() { return /* reexport */ react_dom.unstable_batchedUpdates; },
  "connect": function() { return /* reexport */ connect; },
  "connectAdvanced": function() { return /* reexport */ connectAdvanced; },
  "createDispatchHook": function() { return /* reexport */ createDispatchHook; },
  "createSelectorHook": function() { return /* reexport */ createSelectorHook; },
  "createStoreHook": function() { return /* reexport */ createStoreHook; },
  "shallowEqual": function() { return /* reexport */ shallowEqual; },
  "useDispatch": function() { return /* reexport */ useDispatch; },
  "useSelector": function() { return /* reexport */ useSelector; },
  "useStore": function() { return /* reexport */ useStore_useStore; }
});

// EXTERNAL MODULE: ../../node_modules/react/index.js
var react = __webpack_require__(2784);
// EXTERNAL MODULE: ../../node_modules/prop-types/index.js
var prop_types = __webpack_require__(13980);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/components/Context.js

var ReactReduxContext = /*#__PURE__*/react.createContext(null);

if (false) {}

/* harmony default export */ var Context = ((/* unused pure expression or super */ null && (ReactReduxContext)));
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/utils/batch.js
// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

var batch = defaultNoopBatch; // Allow injecting another batching function later

var setBatch = function setBatch(newBatch) {
  return batch = newBatch;
}; // Supply a getter just to skip dealing with ESM bindings

var getBatch = function getBatch() {
  return batch;
};
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/utils/Subscription.js
 // encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  var batch = getBatch();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify() {
      batch(function () {
        var listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}

var Subscription = /*#__PURE__*/function () {
  function Subscription(store, parentSub) {
    this.store = store;
    this.parentSub = parentSub;
    this.unsubscribe = null;
    this.listeners = nullListeners;
    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
  }

  var _proto = Subscription.prototype;

  _proto.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  _proto.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  _proto.handleChangeWrapper = function handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  };

  _proto.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  _proto.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
      this.listeners = createListenerCollection();
    }
  };

  _proto.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();


;// CONCATENATED MODULE: ../../node_modules/react-redux/es/components/Provider.js





function Provider(_ref) {
  var store = _ref.store,
      context = _ref.context,
      children = _ref.children;
  var contextValue = (0,react.useMemo)(function () {
    var subscription = new Subscription(store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store,
      subscription: subscription
    };
  }, [store]);
  var previousState = (0,react.useMemo)(function () {
    return store.getState();
  }, [store]);
  (0,react.useEffect)(function () {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return function () {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return /*#__PURE__*/react.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

if (false) {}

/* harmony default export */ var components_Provider = (Provider);
;// CONCATENATED MODULE: ../../node_modules/react-redux/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ../../node_modules/react-redux/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
// EXTERNAL MODULE: ../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var hoist_non_react_statics_cjs = __webpack_require__(73463);
var hoist_non_react_statics_cjs_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics_cjs);
// EXTERNAL MODULE: ../../node_modules/react-is/index.js
var react_is = __webpack_require__(48570);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js
 // React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react.useLayoutEffect : react.useEffect;
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/components/connectAdvanced.js







 // Define some constant arrays just to avoid re-creating these

var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];

var stringifyComponent = function stringifyComponent(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};

function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}

function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(function () {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}

function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  // We want to capture the wrapper props and child props we used for later comparisons
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}

function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  // If we're not subscribed to the store, nothing to do here
  if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

  var didUnsubscribe = false;
  var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

  var checkForUpdates = function checkForUpdates() {
    if (didUnsubscribe) {
      // Don't run stale listeners.
      // Redux doesn't guarantee unsubscriptions happen until next dispatch.
      return;
    }

    var latestStoreState = store.getState();
    var newChildProps, error;

    try {
      // Actually run the selector with the most recent store state and wrapper props
      // to determine what the child props should be
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }

    if (!error) {
      lastThrownError = null;
    } // If the child props haven't changed, nothing to do here - cascade the subscription update


    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      // Save references to the new child props.  Note that we track the "child props from store update"
      // as a ref instead of a useState/useReducer because we need a way to determine if that value has
      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
      // forcing another re-render, which we don't want.
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

      forceComponentUpdateDispatch({
        type: 'STORE_UPDATED',
        payload: {
          error: error
        }
      });
    }
  }; // Actually subscribe to the nearest connected ancestor (or store)


  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe(); // Pull data from the store after first render in case the store has
  // changed since we began.

  checkForUpdates();

  var unsubscribeWrapper = function unsubscribeWrapper() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;

    if (lastThrownError) {
      // It's possible that we caught an error due to a bad mapState function, but the
      // parent re-rendered without this component and we're about to unmount.
      // This shouldn't happen as long as we do top-down subscriptions correctly, but
      // if we ever do those wrong, this throw will surface the error in our tests.
      // In that case, throw the error from here so it doesn't get lost.
      throw lastThrownError;
    }
  };

  return unsubscribeWrapper;
}

var initStateUpdates = function initStateUpdates() {
  return [null, 0];
};

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory, // options object:
_ref) {
  if (_ref === void 0) {
    _ref = {};
  }

  var _ref2 = _ref,
      _ref2$getDisplayName = _ref2.getDisplayName,
      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName,
      _ref2$methodName = _ref2.methodName,
      methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
      _ref2$renderCountProp = _ref2.renderCountProp,
      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
      _ref2$storeKey = _ref2.storeKey,
      storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
      _ref2$withRef = _ref2.withRef,
      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
      _ref2$forwardRef = _ref2.forwardRef,
      forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
      _ref2$context = _ref2.context,
      context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context,
      connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"]);

  if (false) { var customStoreWarningMessage; }

  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if (false) {}

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var pure = connectOptions.pure;

    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    } // If we aren't running in "pure" mode, we don't want to memoize values.
    // To avoid conditionally calling hooks, we fall back to a tiny wrapper
    // that just executes the given callback immediately.


    var usePureOnlyMemo = pure ? react.useMemo : function (callback) {
      return callback();
    };

    function ConnectFunction(props) {
      var _useMemo = (0,react.useMemo)(function () {
        // Distinguish between actual "data" props that were passed to the wrapper component,
        // and values needed to control behavior (forwarded refs, alternate context instances).
        // To maintain the wrapperProps object reference, memoize this destructuring.
        var reactReduxForwardedRef = props.reactReduxForwardedRef,
            wrapperProps = _objectWithoutPropertiesLoose(props, ["reactReduxForwardedRef"]);

        return [props.context, reactReduxForwardedRef, wrapperProps];
      }, [props]),
          propsContext = _useMemo[0],
          reactReduxForwardedRef = _useMemo[1],
          wrapperProps = _useMemo[2];

      var ContextToUse = (0,react.useMemo)(function () {
        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
        // Memoize the check that determines which context instance we should use.
        return propsContext && propsContext.Consumer && (0,react_is.isContextConsumer)( /*#__PURE__*/react.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

      var contextValue = (0,react.useContext)(ContextToUse); // The store _must_ exist as either a prop or in context.
      // We'll check to see if it _looks_ like a Redux store first.
      // This allows us to pass through a `store` prop that is just a plain value.

      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);

      if (false) {} // Based on the previous check, one of these must be true


      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = (0,react.useMemo)(function () {
        // The child props selector needs the store reference as an input.
        // Re-create this selector whenever the store changes.
        return createChildSelector(store);
      }, [store]);

      var _useMemo2 = (0,react.useMemo)(function () {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.

        var subscription = new Subscription(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.

        var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
        return [subscription, notifyNestedSubs];
      }, [store, didStoreComeFromProps, contextValue]),
          subscription = _useMemo2[0],
          notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
      // and memoize that value to avoid unnecessary context updates.


      var overriddenContextValue = (0,react.useMemo)(function () {
        if (didStoreComeFromProps) {
          // This component is directly subscribed to a store from props.
          // We don't want descendants reading from this store - pass down whatever
          // the existing context value is from the nearest connected ancestor.
          return contextValue;
        } // Otherwise, put this component's subscription instance into context, so that
        // connected descendants won't update until after this component is done


        return _extends({}, contextValue, {
          subscription: subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
      // causes a change to the calculated child component props (or we caught an error in mapState)

      var _useReducer = (0,react.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
          _useReducer$ = _useReducer[0],
          previousStateUpdateResult = _useReducer$[0],
          forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards


      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      } // Set up refs to coordinate values between the subscription effect and the render logic


      var lastChildProps = (0,react.useRef)();
      var lastWrapperProps = (0,react.useRef)(wrapperProps);
      var childPropsFromStoreUpdate = (0,react.useRef)();
      var renderIsScheduled = (0,react.useRef)(false);
      var actualChildProps = usePureOnlyMemo(function () {
        // Tricky logic here:
        // - This render may have been triggered by a Redux store update that produced new child props
        // - However, we may have gotten new wrapper props after that
        // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
        // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
        // So, we'll use the child props from store update only if the wrapper props are the same as last time.
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        } // TODO We're reading the store directly in render() here. Bad idea?
        // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
        // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
        // to determine what the child props should be.


        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
      // about useLayoutEffect in SSR, so we try to detect environment and fall back to
      // just useEffect instead to avoid the warning, since neither will run anyway.

      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
      // We memoize the elements for the rendered child component as an optimization.

      var renderedWrappedComponent = (0,react.useMemo)(function () {
        return /*#__PURE__*/react.createElement(WrappedComponent, _extends({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

      var renderedChild = (0,react.useMemo)(function () {
        if (shouldHandleStateChanges) {
          // If this component is subscribed to store updates, we need to pass its own
          // subscription instance down to our descendants. That means rendering the same
          // Context instance, and putting a different value into the context.
          return /*#__PURE__*/react.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }

        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.


    var Connect = pure ? react.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;

    if (forwardRef) {
      var forwarded = react.forwardRef(function forwardConnectRef(props, ref) {
        return /*#__PURE__*/react.createElement(Connect, _extends({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoist_non_react_statics_cjs_default()(forwarded, WrappedComponent);
    }

    return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);
  };
}
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/utils/shallowEqual.js
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}
// EXTERNAL MODULE: ../../node_modules/symbol-observable/es/index.js + 1 modules
var es = __webpack_require__(7288);
;// CONCATENATED MODULE: ../../node_modules/redux/es/redux.js


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (false) {}



;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/wrapMapToProps.js

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }

    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
//
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..

function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
//
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//

function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    }; // allow detectFactoryAndVerify to get ownProps


    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (false) {}
      return props;
    };

    return proxy;
  };
}
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/mapDispatchToProps.js


function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
    return {
      dispatch: dispatch
    };
  }) : undefined;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
    return bindActionCreators(mapDispatchToProps, dispatch);
  }) : undefined;
}
/* harmony default export */ var mapDispatchToProps = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/mapStateToProps.js

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : undefined;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function () {
    return {};
  }) : undefined;
}
/* harmony default export */ var mapStateToProps = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/mergeProps.js


function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (false) {}
      }

      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}
/* harmony default export */ var mergeProps = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/selectorFactory.js


function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
} // TODO: Add more comments
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (false) {}

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/connect/connect.js








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}

function strictEqual(a, b) {
  return a === b;
} // createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios


function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? mapStateToProps : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? mapDispatchToProps : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === void 0 ? mergeProps : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }

    var _ref3 = _ref2,
        _ref3$pure = _ref3.pure,
        pure = _ref3$pure === void 0 ? true : _ref3$pure,
        _ref3$areStatesEqual = _ref3.areStatesEqual,
        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,
        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,
        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,
        extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual
    }, extraOptions));
  };
}
/* harmony default export */ var connect = (/*#__PURE__*/createConnect());
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/hooks/useReduxContext.js


/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */

function useReduxContext_useReduxContext() {
  var contextValue = (0,react.useContext)(ReactReduxContext);

  if (false) {}

  return contextValue;
}
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/hooks/useStore.js



/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

function createStoreHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useReduxContext = context === ReactReduxContext ? useReduxContext_useReduxContext : function () {
    return (0,react.useContext)(context);
  };
  return function useStore() {
    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store;

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

var useStore_useStore = /*#__PURE__*/createStoreHook();
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/hooks/useDispatch.js


/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

function createDispatchHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useStore = context === ReactReduxContext ? useStore_useStore : createStoreHook(context);
  return function useDispatch() {
    var store = useStore();
    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

var useDispatch = /*#__PURE__*/createDispatchHook();
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/hooks/useSelector.js






var refEquality = function refEquality(a, b) {
  return a === b;
};

function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = (0,react.useReducer)(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  var subscription = (0,react.useMemo)(function () {
    return new Subscription(store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = (0,react.useRef)();
  var latestSelector = (0,react.useRef)();
  var latestStoreState = (0,react.useRef)();
  var latestSelectedState = (0,react.useRef)();
  var storeState = store.getState();
  var selectedState;

  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      selectedState = selector(storeState);
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }

    throw err;
  }

  useIsomorphicLayoutEffect(function () {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = undefined;
  });
  useIsomorphicLayoutEffect(function () {
    function checkForUpdates() {
      try {
        var newSelectedState = latestSelector.current(store.getState());

        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return;
        }

        latestSelectedState.current = newSelectedState;
      } catch (err) {
        // we ignore all errors here, since when the component
        // is re-rendered, the selectors are called again, and
        // will throw again, if neither props nor store state
        // changed
        latestSubscriptionCallbackError.current = err;
      }

      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function () {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }

  var useReduxContext = context === ReactReduxContext ? useReduxContext_useReduxContext : function () {
    return (0,react.useContext)(context);
  };
  return function useSelector(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }

    if (false) {}

    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store,
        contextSub = _useReduxContext.subscription;

    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    (0,react.useDebugValue)(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

var useSelector = /*#__PURE__*/createSelectorHook();
// EXTERNAL MODULE: ../../node_modules/react-dom/index.js
var react_dom = __webpack_require__(28316);
;// CONCATENATED MODULE: ../../node_modules/react-redux/es/utils/reactBatchedUpdates.js
/* eslint-disable import/no-unresolved */

;// CONCATENATED MODULE: ../../node_modules/react-redux/es/index.js










setBatch(react_dom.unstable_batchedUpdates);


/***/ }),

/***/ 62833:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.MemoryRouter; },
/* harmony export */   "Navigate": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Navigate; },
/* harmony export */   "Outlet": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Outlet; },
/* harmony export */   "Route": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Route; },
/* harmony export */   "Router": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Router; },
/* harmony export */   "Routes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Routes; },
/* harmony export */   "UNSAFE_LocationContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_LocationContext; },
/* harmony export */   "UNSAFE_NavigationContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_NavigationContext; },
/* harmony export */   "UNSAFE_RouteContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_RouteContext; },
/* harmony export */   "createRoutesFromChildren": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createRoutesFromChildren; },
/* harmony export */   "generatePath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath; },
/* harmony export */   "matchPath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath; },
/* harmony export */   "matchRoutes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes; },
/* harmony export */   "renderMatches": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.renderMatches; },
/* harmony export */   "resolvePath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath; },
/* harmony export */   "useHref": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useHref; },
/* harmony export */   "useInRouterContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useInRouterContext; },
/* harmony export */   "useLocation": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation; },
/* harmony export */   "useMatch": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useMatch; },
/* harmony export */   "useNavigate": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate; },
/* harmony export */   "useNavigationType": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigationType; },
/* harmony export */   "useOutlet": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutlet; },
/* harmony export */   "useOutletContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutletContext; },
/* harmony export */   "useParams": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useParams; },
/* harmony export */   "useResolvedPath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath; },
/* harmony export */   "useRoutes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useRoutes; },
/* harmony export */   "BrowserRouter": function() { return /* binding */ BrowserRouter; },
/* harmony export */   "HashRouter": function() { return /* binding */ HashRouter; },
/* harmony export */   "Link": function() { return /* binding */ Link; },
/* harmony export */   "NavLink": function() { return /* binding */ NavLink; },
/* harmony export */   "createSearchParams": function() { return /* binding */ createSearchParams; },
/* harmony export */   "unstable_HistoryRouter": function() { return /* binding */ HistoryRouter; },
/* harmony export */   "useLinkClickHandler": function() { return /* binding */ useLinkClickHandler; },
/* harmony export */   "useSearchParams": function() { return /* binding */ useSearchParams; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2784);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(78810);
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10289);
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"],
      _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} ////////////////////////////////////////////////////////////////////////////////
// COMPONENTS
////////////////////////////////////////////////////////////////////////////////

/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__/* .createBrowserHistory */ .lX)({
      window
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__/* .createHashHistory */ .q_)({
      window
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

if (false) {}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

/**
 * The public API for rendering a history-aware <a>.
 */
const Link = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useHref)(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("a", _extends({}, rest, {
      href: href,
      onClick: handleClick,
      ref: ref,
      target: target
    }))
  );
});

if (false) {}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
const NavLink = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5,
      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;

  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }

  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;

  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }

  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});

if (false) {} ////////////////////////////////////////////////////////////////////////////////
// HOOKS
////////////////////////////////////////////////////////////////////////////////

/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(event => {
    if (event.button === 0 && ( // Ignore everything but left clicks
    !target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here.

      let replace = !!replaceProp || (0,history__WEBPACK_IMPORTED_MODULE_2__/* .createPath */ .Ep)(location) === (0,history__WEBPACK_IMPORTED_MODULE_2__/* .createPath */ .Ep)(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) {
   false ? 0 : void 0;
  let defaultSearchParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(createSearchParams(defaultInit));
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let searchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let searchParams = createSearchParams(location.search);

    for (let key of defaultSearchParamsRef.current.keys()) {
      if (!searchParams.has(key)) {
        defaultSearchParamsRef.current.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    }

    return searchParams;
  }, [location.search]);
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let setSearchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nextInit, navigateOptions) => {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}

/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }

  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ 10289:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": function() { return /* binding */ MemoryRouter; },
/* harmony export */   "Navigate": function() { return /* binding */ Navigate; },
/* harmony export */   "Outlet": function() { return /* binding */ Outlet; },
/* harmony export */   "Route": function() { return /* binding */ Route; },
/* harmony export */   "Router": function() { return /* binding */ Router; },
/* harmony export */   "Routes": function() { return /* binding */ Routes; },
/* harmony export */   "UNSAFE_LocationContext": function() { return /* binding */ LocationContext; },
/* harmony export */   "UNSAFE_NavigationContext": function() { return /* binding */ NavigationContext; },
/* harmony export */   "UNSAFE_RouteContext": function() { return /* binding */ RouteContext; },
/* harmony export */   "createRoutesFromChildren": function() { return /* binding */ createRoutesFromChildren; },
/* harmony export */   "generatePath": function() { return /* binding */ generatePath; },
/* harmony export */   "matchPath": function() { return /* binding */ matchPath; },
/* harmony export */   "matchRoutes": function() { return /* binding */ matchRoutes; },
/* harmony export */   "renderMatches": function() { return /* binding */ renderMatches; },
/* harmony export */   "resolvePath": function() { return /* binding */ resolvePath; },
/* harmony export */   "useHref": function() { return /* binding */ useHref; },
/* harmony export */   "useInRouterContext": function() { return /* binding */ useInRouterContext; },
/* harmony export */   "useLocation": function() { return /* binding */ useLocation; },
/* harmony export */   "useMatch": function() { return /* binding */ useMatch; },
/* harmony export */   "useNavigate": function() { return /* binding */ useNavigate; },
/* harmony export */   "useNavigationType": function() { return /* binding */ useNavigationType; },
/* harmony export */   "useOutlet": function() { return /* binding */ useOutlet; },
/* harmony export */   "useOutletContext": function() { return /* binding */ useOutletContext; },
/* harmony export */   "useParams": function() { return /* binding */ useParams; },
/* harmony export */   "useResolvedPath": function() { return /* binding */ useResolvedPath; },
/* harmony export */   "useRoutes": function() { return /* binding */ useRoutes; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2784);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(78810);
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function invariant(cond, message) {
  if (!cond) throw new Error(message);
}

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

const alreadyWarned = {};

function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     false ? 0 : void 0;
  }
} ///////////////////////////////////////////////////////////////////////////////
// CONTEXT
///////////////////////////////////////////////////////////////////////////////

/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level <Router> API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */


const NavigationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);

if (false) {}

const LocationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);

if (false) {}

const RouteContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  outlet: null,
  matches: []
});

if (false) {} ///////////////////////////////////////////////////////////////////////////////
// COMPONENTS
///////////////////////////////////////////////////////////////////////////////


/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
 */
function MemoryRouter(_ref) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_1__/* .createMemoryHistory */ .PP)({
      initialEntries,
      initialIndex
    });
  }

  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/docs/en/v6/api#navigate
 */
function Navigate(_ref2) {
  let {
    to,
    replace,
    state
  } = _ref2;
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
   false ? 0 : void 0;
  let navigate = useNavigate();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    navigate(to, {
      replace,
      state
    });
  });
  return null;
}

/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/docs/en/v6/api#outlet
 */
function Outlet(props) {
  return useOutlet(props.context);
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#route
 */
function Route(_props) {
    false ? 0 : invariant(false) ;
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/docs/en/v6/api#router
 */
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = history__WEBPACK_IMPORTED_MODULE_1__/* .Action.Pop */ .aU.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);

  if (typeof locationProp === "string") {
    locationProp = (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationProp);
  }

  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   false ? 0 : void 0;

  if (location == null) {
    return null;
  }

  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LocationContext.Provider, {
    children: children,
    value: {
      location,
      navigationType
    }
  }));
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#routes
 */
function Routes(_ref4) {
  let {
    children,
    location
  } = _ref4;
  return useRoutes(createRoutesFromChildren(children), location);
} ///////////////////////////////////////////////////////////////////////////////
// HOOKS
///////////////////////////////////////////////////////////////////////////////

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usehref
 */

function useHref(to) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;

  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
 */

function useInRouterContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/api#uselocation
 */

function useLocation() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).location;
}

/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
 */
function useNavigationType() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).navigationType;
}
/**
 * Returns true if the URL for the given "to" value matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usematch
 */

function useMatch(pattern) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    pathname
  } = useLocation();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => matchPath(pattern, pathname), [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigate
 */
function useNavigate() {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
  let activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (to, options) {
    if (options === void 0) {
      options = {};
    }

     false ? 0 : void 0;
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);

    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
 */

function useOutletContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useoutlet
 */

function useOutlet(context) {
  let outlet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext).outlet;

  if (outlet) {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useparams
 */

function useParams() {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
 */

function useResolvedPath(to) {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useroutes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  false ? 0 : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;

  if (false) {}

  let locationFromContext = useLocation();
  let location;

  if (locationArg) {
    var _parsedLocationArg$pa;

    let parsedLocationArg = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  false ? 0 : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });

  if (false) {}

  return _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
 */

function createRoutesFromChildren(children) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, element => {
    if (! /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }

    !(element.type === Route) ?  false ? 0 : invariant(false) : void 0;
    let route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };

    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }

    routes.push(route);
  });
  return routes;
}
/**
 * The parameters that were parsed from the URL path.
 */

/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/docs/en/v6/api#generatepath
 */
function generatePath(path, params) {
  if (params === void 0) {
    params = {};
  }

  return path.replace(/:(\w+)/g, (_, key) => {
    !(params[key] != null) ?  false ? 0 : invariant(false) : void 0;
    return params[key];
  }).replace(/\/*\*$/, _ => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
}
/**
 * A RouteMatch contains info about how a route matched a URL.
 */

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchroutes
 */
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  let location = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;

  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  routes.forEach((route, index) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };

    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ?  false ? 0 : invariant(false) : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      !(route.index !== true) ?  false ? 0 : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}

function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;

const isSplat = s => s === "*";

function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}

function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];

  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */


function renderMatches(matches) {
  return _renderMatches(matches);
}

function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }

  if (matches == null) return null;
  return matches.reduceRight((outlet, match, index) => {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RouteContext.Provider, {
      children: match.route.element !== undefined ? match.route.element : /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */


/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchpath
 */
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

   false ? 0 : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else {
    regexpSource += end ? "\\/*$" // When matching to the end, ignore trailing slashes
    : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
    // parent routes to matching only their own words and nothing more, e.g. parent
    // route "/home" should not match "/home2".
    "(?:\\b|\\/|$)";
  }

  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
     false ? 0 : void 0;
    return value;
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/api#resolvepath
 */


function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  let from;

  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.

  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }

  return path;
}

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__/* .parsePath */ .cP)(to).pathname : to.pathname;
}

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  let nextChar = pathname.charAt(basename.length);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(basename.length) || "/";
}

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash; ///////////////////////////////////////////////////////////////////////////////


//# sourceMappingURL=index.js.map


/***/ }),

/***/ 1738:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(34406);
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof __webpack_require__.g === "object" ? __webpack_require__.g :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ 25047:
/***/ (function(module) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 7288:
/***/ (function(module, __unused_webpack___webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ../../node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};

;// CONCATENATED MODULE: ../../node_modules/symbol-observable/es/index.js
/* module decorator */ module = __webpack_require__.hmd(module);
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result = symbolObservablePonyfill(root);
/* harmony default export */ var es = ((/* unused pure expression or super */ null && (result)));


/***/ }),

/***/ 54688:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncParallelBailHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, onDone }) {
		let code = "";
		code += `var _results = new Array(${this.options.taps.length});\n`;
		code += "var _checkDone = function() {\n";
		code += "for(var i = 0; i < _results.length; i++) {\n";
		code += "var item = _results[i];\n";
		code += "if(item === undefined) return false;\n";
		code += "if(item.result !== undefined) {\n";
		code += onResult("item.result");
		code += "return true;\n";
		code += "}\n";
		code += "if(item.error) {\n";
		code += onError("item.error");
		code += "return true;\n";
		code += "}\n";
		code += "}\n";
		code += "return false;\n";
		code += "}\n";
		code += this.callTapsParallel({
			onError: (i, err, done, doneBreak) => {
				let code = "";
				code += `if(${i} < _results.length && ((_results.length = ${i +
					1}), (_results[${i}] = { error: ${err} }), _checkDone())) {\n`;
				code += doneBreak(true);
				code += "} else {\n";
				code += done();
				code += "}\n";
				return code;
			},
			onResult: (i, result, done, doneBreak) => {
				let code = "";
				code += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i +
					1}), (_results[${i}] = { result: ${result} }), _checkDone())) {\n`;
				code += doneBreak(true);
				code += "} else {\n";
				code += done();
				code += "}\n";
				return code;
			},
			onTap: (i, run, done, doneBreak) => {
				let code = "";
				if (i > 0) {
					code += `if(${i} >= _results.length) {\n`;
					code += done();
					code += "} else {\n";
				}
				code += run();
				if (i > 0) code += "}\n";
				return code;
			},
			onDone
		});
		return code;
	}
}

const factory = new AsyncParallelBailHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncParallelBailHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = AsyncParallelBailHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncParallelBailHook.prototype = null;

module.exports = AsyncParallelBailHook;


/***/ }),

/***/ 16635:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncParallelHookCodeFactory extends HookCodeFactory {
	content({ onError, onDone }) {
		return this.callTapsParallel({
			onError: (i, err, done, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory = new AsyncParallelHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncParallelHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = AsyncParallelHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncParallelHook.prototype = null;

module.exports = AsyncParallelHook;


/***/ }),

/***/ 72662:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncSeriesBailHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, resultReturns, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onResult: (i, result, next) =>
				`if(${result} !== undefined) {\n${onResult(
					result
				)}\n} else {\n${next()}}\n`,
			resultReturns,
			onDone
		});
	}
}

const factory = new AsyncSeriesBailHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncSeriesBailHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = AsyncSeriesBailHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesBailHook.prototype = null;

module.exports = AsyncSeriesBailHook;


/***/ }),

/***/ 45663:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncSeriesHookCodeFactory extends HookCodeFactory {
	content({ onError, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory = new AsyncSeriesHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncSeriesHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = AsyncSeriesHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesHook.prototype = null;

module.exports = AsyncSeriesHook;


/***/ }),

/***/ 59899:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncSeriesLoopHookCodeFactory extends HookCodeFactory {
	content({ onError, onDone }) {
		return this.callTapsLooping({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onDone
		});
	}
}

const factory = new AsyncSeriesLoopHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncSeriesLoopHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = AsyncSeriesLoopHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesLoopHook.prototype = null;

module.exports = AsyncSeriesLoopHook;


/***/ }),

/***/ 78253:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class AsyncSeriesWaterfallHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, onDone }) {
		return this.callTapsSeries({
			onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
			onResult: (i, result, next) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += `${this._args[0]} = ${result};\n`;
				code += `}\n`;
				code += next();
				return code;
			},
			onDone: () => onResult(this._args[0])
		});
	}
}

const factory = new AsyncSeriesWaterfallHookCodeFactory();

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function AsyncSeriesWaterfallHook(args = [], name = undefined) {
	if (args.length < 1)
		throw new Error("Waterfall hooks must have at least one argument");
	const hook = new Hook(args, name);
	hook.constructor = AsyncSeriesWaterfallHook;
	hook.compile = COMPILE;
	hook._call = undefined;
	hook.call = undefined;
	return hook;
}

AsyncSeriesWaterfallHook.prototype = null;

module.exports = AsyncSeriesWaterfallHook;


/***/ }),

/***/ 65841:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const util = __webpack_require__(9141);

const deprecateContext = util.deprecate(() => {},
"Hook.context is deprecated and will be removed");

const CALL_DELEGATE = function(...args) {
	this.call = this._createCall("sync");
	return this.call(...args);
};
const CALL_ASYNC_DELEGATE = function(...args) {
	this.callAsync = this._createCall("async");
	return this.callAsync(...args);
};
const PROMISE_DELEGATE = function(...args) {
	this.promise = this._createCall("promise");
	return this.promise(...args);
};

class Hook {
	constructor(args = [], name = undefined) {
		this._args = args;
		this.name = name;
		this.taps = [];
		this.interceptors = [];
		this._call = CALL_DELEGATE;
		this.call = CALL_DELEGATE;
		this._callAsync = CALL_ASYNC_DELEGATE;
		this.callAsync = CALL_ASYNC_DELEGATE;
		this._promise = PROMISE_DELEGATE;
		this.promise = PROMISE_DELEGATE;
		this._x = undefined;

		this.compile = this.compile;
		this.tap = this.tap;
		this.tapAsync = this.tapAsync;
		this.tapPromise = this.tapPromise;
	}

	compile(options) {
		throw new Error("Abstract: should be overridden");
	}

	_createCall(type) {
		return this.compile({
			taps: this.taps,
			interceptors: this.interceptors,
			args: this._args,
			type: type
		});
	}

	_tap(type, options, fn) {
		if (typeof options === "string") {
			options = {
				name: options.trim()
			};
		} else if (typeof options !== "object" || options === null) {
			throw new Error("Invalid tap options");
		}
		if (typeof options.name !== "string" || options.name === "") {
			throw new Error("Missing name for tap");
		}
		if (typeof options.context !== "undefined") {
			deprecateContext();
		}
		options = Object.assign({ type, fn }, options);
		options = this._runRegisterInterceptors(options);
		this._insert(options);
	}

	tap(options, fn) {
		this._tap("sync", options, fn);
	}

	tapAsync(options, fn) {
		this._tap("async", options, fn);
	}

	tapPromise(options, fn) {
		this._tap("promise", options, fn);
	}

	_runRegisterInterceptors(options) {
		for (const interceptor of this.interceptors) {
			if (interceptor.register) {
				const newOptions = interceptor.register(options);
				if (newOptions !== undefined) {
					options = newOptions;
				}
			}
		}
		return options;
	}

	withOptions(options) {
		const mergeOptions = opt =>
			Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);

		return {
			name: this.name,
			tap: (opt, fn) => this.tap(mergeOptions(opt), fn),
			tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),
			tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),
			intercept: interceptor => this.intercept(interceptor),
			isUsed: () => this.isUsed(),
			withOptions: opt => this.withOptions(mergeOptions(opt))
		};
	}

	isUsed() {
		return this.taps.length > 0 || this.interceptors.length > 0;
	}

	intercept(interceptor) {
		this._resetCompilation();
		this.interceptors.push(Object.assign({}, interceptor));
		if (interceptor.register) {
			for (let i = 0; i < this.taps.length; i++) {
				this.taps[i] = interceptor.register(this.taps[i]);
			}
		}
	}

	_resetCompilation() {
		this.call = this._call;
		this.callAsync = this._callAsync;
		this.promise = this._promise;
	}

	_insert(item) {
		this._resetCompilation();
		let before;
		if (typeof item.before === "string") {
			before = new Set([item.before]);
		} else if (Array.isArray(item.before)) {
			before = new Set(item.before);
		}
		let stage = 0;
		if (typeof item.stage === "number") {
			stage = item.stage;
		}
		let i = this.taps.length;
		while (i > 0) {
			i--;
			const x = this.taps[i];
			this.taps[i + 1] = x;
			const xStage = x.stage || 0;
			if (before) {
				if (before.has(x.name)) {
					before.delete(x.name);
					continue;
				}
				if (before.size > 0) {
					continue;
				}
			}
			if (xStage > stage) {
				continue;
			}
			i++;
			break;
		}
		this.taps[i] = item;
	}
}

Object.setPrototypeOf(Hook.prototype, null);

module.exports = Hook;


/***/ }),

/***/ 44589:
/***/ (function(module) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


class HookCodeFactory {
	constructor(config) {
		this.config = config;
		this.options = undefined;
		this._args = undefined;
	}

	create(options) {
		this.init(options);
		let fn;
		switch (this.options.type) {
			case "sync":
				fn = new Function(
					this.args(),
					'"use strict";\n' +
						this.header() +
						this.contentWithInterceptors({
							onError: err => `throw ${err};\n`,
							onResult: result => `return ${result};\n`,
							resultReturns: true,
							onDone: () => "",
							rethrowIfPossible: true
						})
				);
				break;
			case "async":
				fn = new Function(
					this.args({
						after: "_callback"
					}),
					'"use strict";\n' +
						this.header() +
						this.contentWithInterceptors({
							onError: err => `_callback(${err});\n`,
							onResult: result => `_callback(null, ${result});\n`,
							onDone: () => "_callback();\n"
						})
				);
				break;
			case "promise":
				let errorHelperUsed = false;
				const content = this.contentWithInterceptors({
					onError: err => {
						errorHelperUsed = true;
						return `_error(${err});\n`;
					},
					onResult: result => `_resolve(${result});\n`,
					onDone: () => "_resolve();\n"
				});
				let code = "";
				code += '"use strict";\n';
				code += this.header();
				code += "return new Promise((function(_resolve, _reject) {\n";
				if (errorHelperUsed) {
					code += "var _sync = true;\n";
					code += "function _error(_err) {\n";
					code += "if(_sync)\n";
					code +=
						"_resolve(Promise.resolve().then((function() { throw _err; })));\n";
					code += "else\n";
					code += "_reject(_err);\n";
					code += "};\n";
				}
				code += content;
				if (errorHelperUsed) {
					code += "_sync = false;\n";
				}
				code += "}));\n";
				fn = new Function(this.args(), code);
				break;
		}
		this.deinit();
		return fn;
	}

	setup(instance, options) {
		instance._x = options.taps.map(t => t.fn);
	}

	/**
	 * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
	 */
	init(options) {
		this.options = options;
		this._args = options.args.slice();
	}

	deinit() {
		this.options = undefined;
		this._args = undefined;
	}

	contentWithInterceptors(options) {
		if (this.options.interceptors.length > 0) {
			const onError = options.onError;
			const onResult = options.onResult;
			const onDone = options.onDone;
			let code = "";
			for (let i = 0; i < this.options.interceptors.length; i++) {
				const interceptor = this.options.interceptors[i];
				if (interceptor.call) {
					code += `${this.getInterceptor(i)}.call(${this.args({
						before: interceptor.context ? "_context" : undefined
					})});\n`;
				}
			}
			code += this.content(
				Object.assign(options, {
					onError:
						onError &&
						(err => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.error) {
									code += `${this.getInterceptor(i)}.error(${err});\n`;
								}
							}
							code += onError(err);
							return code;
						}),
					onResult:
						onResult &&
						(result => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.result) {
									code += `${this.getInterceptor(i)}.result(${result});\n`;
								}
							}
							code += onResult(result);
							return code;
						}),
					onDone:
						onDone &&
						(() => {
							let code = "";
							for (let i = 0; i < this.options.interceptors.length; i++) {
								const interceptor = this.options.interceptors[i];
								if (interceptor.done) {
									code += `${this.getInterceptor(i)}.done();\n`;
								}
							}
							code += onDone();
							return code;
						})
				})
			);
			return code;
		} else {
			return this.content(options);
		}
	}

	header() {
		let code = "";
		if (this.needContext()) {
			code += "var _context = {};\n";
		} else {
			code += "var _context;\n";
		}
		code += "var _x = this._x;\n";
		if (this.options.interceptors.length > 0) {
			code += "var _taps = this.taps;\n";
			code += "var _interceptors = this.interceptors;\n";
		}
		return code;
	}

	needContext() {
		for (const tap of this.options.taps) if (tap.context) return true;
		return false;
	}

	callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
		let code = "";
		let hasTapCached = false;
		for (let i = 0; i < this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.tap) {
				if (!hasTapCached) {
					code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\n`;
					hasTapCached = true;
				}
				code += `${this.getInterceptor(i)}.tap(${
					interceptor.context ? "_context, " : ""
				}_tap${tapIndex});\n`;
			}
		}
		code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\n`;
		const tap = this.options.taps[tapIndex];
		switch (tap.type) {
			case "sync":
				if (!rethrowIfPossible) {
					code += `var _hasError${tapIndex} = false;\n`;
					code += "try {\n";
				}
				if (onResult) {
					code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
						before: tap.context ? "_context" : undefined
					})});\n`;
				} else {
					code += `_fn${tapIndex}(${this.args({
						before: tap.context ? "_context" : undefined
					})});\n`;
				}
				if (!rethrowIfPossible) {
					code += "} catch(_err) {\n";
					code += `_hasError${tapIndex} = true;\n`;
					code += onError("_err");
					code += "}\n";
					code += `if(!_hasError${tapIndex}) {\n`;
				}
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				if (!rethrowIfPossible) {
					code += "}\n";
				}
				break;
			case "async":
				let cbCode = "";
				if (onResult)
					cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\n`;
				else cbCode += `(function(_err${tapIndex}) {\n`;
				cbCode += `if(_err${tapIndex}) {\n`;
				cbCode += onError(`_err${tapIndex}`);
				cbCode += "} else {\n";
				if (onResult) {
					cbCode += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					cbCode += onDone();
				}
				cbCode += "}\n";
				cbCode += "})";
				code += `_fn${tapIndex}(${this.args({
					before: tap.context ? "_context" : undefined,
					after: cbCode
				})});\n`;
				break;
			case "promise":
				code += `var _hasResult${tapIndex} = false;\n`;
				code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
					before: tap.context ? "_context" : undefined
				})});\n`;
				code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\n`;
				code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\n`;
				code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\n`;
				code += `_hasResult${tapIndex} = true;\n`;
				if (onResult) {
					code += onResult(`_result${tapIndex}`);
				}
				if (onDone) {
					code += onDone();
				}
				code += `}), function(_err${tapIndex}) {\n`;
				code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\n`;
				code += onError(`_err${tapIndex}`);
				code += "});\n";
				break;
		}
		return code;
	}

	callTapsSeries({
		onError,
		onResult,
		resultReturns,
		onDone,
		doneReturns,
		rethrowIfPossible
	}) {
		if (this.options.taps.length === 0) return onDone();
		const firstAsync = this.options.taps.findIndex(t => t.type !== "sync");
		const somethingReturns = resultReturns || doneReturns;
		let code = "";
		let current = onDone;
		let unrollCounter = 0;
		for (let j = this.options.taps.length - 1; j >= 0; j--) {
			const i = j;
			const unroll =
				current !== onDone &&
				(this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
			if (unroll) {
				unrollCounter = 0;
				code += `function _next${i}() {\n`;
				code += current();
				code += `}\n`;
				current = () => `${somethingReturns ? "return " : ""}_next${i}();\n`;
			}
			const done = current;
			const doneBreak = skipDone => {
				if (skipDone) return "";
				return onDone();
			};
			const content = this.callTap(i, {
				onError: error => onError(i, error, done, doneBreak),
				onResult:
					onResult &&
					(result => {
						return onResult(i, result, done, doneBreak);
					}),
				onDone: !onResult && done,
				rethrowIfPossible:
					rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
			});
			current = () => content;
		}
		code += current();
		return code;
	}

	callTapsLooping({ onError, onDone, rethrowIfPossible }) {
		if (this.options.taps.length === 0) return onDone();
		const syncOnly = this.options.taps.every(t => t.type === "sync");
		let code = "";
		if (!syncOnly) {
			code += "var _looper = (function() {\n";
			code += "var _loopAsync = false;\n";
		}
		code += "var _loop;\n";
		code += "do {\n";
		code += "_loop = false;\n";
		for (let i = 0; i < this.options.interceptors.length; i++) {
			const interceptor = this.options.interceptors[i];
			if (interceptor.loop) {
				code += `${this.getInterceptor(i)}.loop(${this.args({
					before: interceptor.context ? "_context" : undefined
				})});\n`;
			}
		}
		code += this.callTapsSeries({
			onError,
			onResult: (i, result, next, doneBreak) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += "_loop = true;\n";
				if (!syncOnly) code += "if(_loopAsync) _looper();\n";
				code += doneBreak(true);
				code += `} else {\n`;
				code += next();
				code += `}\n`;
				return code;
			},
			onDone:
				onDone &&
				(() => {
					let code = "";
					code += "if(!_loop) {\n";
					code += onDone();
					code += "}\n";
					return code;
				}),
			rethrowIfPossible: rethrowIfPossible && syncOnly
		});
		code += "} while(_loop);\n";
		if (!syncOnly) {
			code += "_loopAsync = true;\n";
			code += "});\n";
			code += "_looper();\n";
		}
		return code;
	}

	callTapsParallel({
		onError,
		onResult,
		onDone,
		rethrowIfPossible,
		onTap = (i, run) => run()
	}) {
		if (this.options.taps.length <= 1) {
			return this.callTapsSeries({
				onError,
				onResult,
				onDone,
				rethrowIfPossible
			});
		}
		let code = "";
		code += "do {\n";
		code += `var _counter = ${this.options.taps.length};\n`;
		if (onDone) {
			code += "var _done = (function() {\n";
			code += onDone();
			code += "});\n";
		}
		for (let i = 0; i < this.options.taps.length; i++) {
			const done = () => {
				if (onDone) return "if(--_counter === 0) _done();\n";
				else return "--_counter;";
			};
			const doneBreak = skipDone => {
				if (skipDone || !onDone) return "_counter = 0;\n";
				else return "_counter = 0;\n_done();\n";
			};
			code += "if(_counter <= 0) break;\n";
			code += onTap(
				i,
				() =>
					this.callTap(i, {
						onError: error => {
							let code = "";
							code += "if(_counter > 0) {\n";
							code += onError(i, error, done, doneBreak);
							code += "}\n";
							return code;
						},
						onResult:
							onResult &&
							(result => {
								let code = "";
								code += "if(_counter > 0) {\n";
								code += onResult(i, result, done, doneBreak);
								code += "}\n";
								return code;
							}),
						onDone:
							!onResult &&
							(() => {
								return done();
							}),
						rethrowIfPossible
					}),
				done,
				doneBreak
			);
		}
		code += "} while(false);\n";
		return code;
	}

	args({ before, after } = {}) {
		let allArgs = this._args;
		if (before) allArgs = [before].concat(allArgs);
		if (after) allArgs = allArgs.concat(after);
		if (allArgs.length === 0) {
			return "";
		} else {
			return allArgs.join(", ");
		}
	}

	getTapFn(idx) {
		return `_x[${idx}]`;
	}

	getTap(idx) {
		return `_taps[${idx}]`;
	}

	getInterceptor(idx) {
		return `_interceptors[${idx}]`;
	}
}

module.exports = HookCodeFactory;


/***/ }),

/***/ 44366:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const util = __webpack_require__(9141);

const defaultFactory = (key, hook) => hook;

class HookMap {
	constructor(factory, name = undefined) {
		this._map = new Map();
		this.name = name;
		this._factory = factory;
		this._interceptors = [];
	}

	get(key) {
		return this._map.get(key);
	}

	for(key) {
		const hook = this.get(key);
		if (hook !== undefined) {
			return hook;
		}
		let newHook = this._factory(key);
		const interceptors = this._interceptors;
		for (let i = 0; i < interceptors.length; i++) {
			newHook = interceptors[i].factory(key, newHook);
		}
		this._map.set(key, newHook);
		return newHook;
	}

	intercept(interceptor) {
		this._interceptors.push(
			Object.assign(
				{
					factory: defaultFactory
				},
				interceptor
			)
		);
	}
}

HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
	return this.for(key).tap(options, fn);
}, "HookMap#tap(key,…) is deprecated. Use HookMap#for(key).tap(…) instead.");

HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
	return this.for(key).tapAsync(options, fn);
}, "HookMap#tapAsync(key,…) is deprecated. Use HookMap#for(key).tapAsync(…) instead.");

HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
	return this.for(key).tapPromise(options, fn);
}, "HookMap#tapPromise(key,…) is deprecated. Use HookMap#for(key).tapPromise(…) instead.");

module.exports = HookMap;


/***/ }),

/***/ 72203:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);

class MultiHook {
	constructor(hooks, name = undefined) {
		this.hooks = hooks;
		this.name = name;
	}

	tap(options, fn) {
		for (const hook of this.hooks) {
			hook.tap(options, fn);
		}
	}

	tapAsync(options, fn) {
		for (const hook of this.hooks) {
			hook.tapAsync(options, fn);
		}
	}

	tapPromise(options, fn) {
		for (const hook of this.hooks) {
			hook.tapPromise(options, fn);
		}
	}

	isUsed() {
		for (const hook of this.hooks) {
			if (hook.isUsed()) return true;
		}
		return false;
	}

	intercept(interceptor) {
		for (const hook of this.hooks) {
			hook.intercept(interceptor);
		}
	}

	withOptions(options) {
		return new MultiHook(
			this.hooks.map(h => h.withOptions(options)),
			this.name
		);
	}
}

module.exports = MultiHook;


/***/ }),

/***/ 3598:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class SyncBailHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onResult: (i, result, next) =>
				`if(${result} !== undefined) {\n${onResult(
					result
				)};\n} else {\n${next()}}\n`,
			resultReturns,
			onDone,
			rethrowIfPossible
		});
	}
}

const factory = new SyncBailHookCodeFactory();

const TAP_ASYNC = () => {
	throw new Error("tapAsync is not supported on a SyncBailHook");
};

const TAP_PROMISE = () => {
	throw new Error("tapPromise is not supported on a SyncBailHook");
};

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function SyncBailHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = SyncBailHook;
	hook.tapAsync = TAP_ASYNC;
	hook.tapPromise = TAP_PROMISE;
	hook.compile = COMPILE;
	return hook;
}

SyncBailHook.prototype = null;

module.exports = SyncBailHook;


/***/ }),

/***/ 85835:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class SyncHookCodeFactory extends HookCodeFactory {
	content({ onError, onDone, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onDone,
			rethrowIfPossible
		});
	}
}

const factory = new SyncHookCodeFactory();

const TAP_ASYNC = () => {
	throw new Error("tapAsync is not supported on a SyncHook");
};

const TAP_PROMISE = () => {
	throw new Error("tapPromise is not supported on a SyncHook");
};

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function SyncHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = SyncHook;
	hook.tapAsync = TAP_ASYNC;
	hook.tapPromise = TAP_PROMISE;
	hook.compile = COMPILE;
	return hook;
}

SyncHook.prototype = null;

module.exports = SyncHook;


/***/ }),

/***/ 14613:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class SyncLoopHookCodeFactory extends HookCodeFactory {
	content({ onError, onDone, rethrowIfPossible }) {
		return this.callTapsLooping({
			onError: (i, err) => onError(err),
			onDone,
			rethrowIfPossible
		});
	}
}

const factory = new SyncLoopHookCodeFactory();

const TAP_ASYNC = () => {
	throw new Error("tapAsync is not supported on a SyncLoopHook");
};

const TAP_PROMISE = () => {
	throw new Error("tapPromise is not supported on a SyncLoopHook");
};

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function SyncLoopHook(args = [], name = undefined) {
	const hook = new Hook(args, name);
	hook.constructor = SyncLoopHook;
	hook.tapAsync = TAP_ASYNC;
	hook.tapPromise = TAP_PROMISE;
	hook.compile = COMPILE;
	return hook;
}

SyncLoopHook.prototype = null;

module.exports = SyncLoopHook;


/***/ }),

/***/ 87845:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


const Hook = __webpack_require__(65841);
const HookCodeFactory = __webpack_require__(44589);

class SyncWaterfallHookCodeFactory extends HookCodeFactory {
	content({ onError, onResult, resultReturns, rethrowIfPossible }) {
		return this.callTapsSeries({
			onError: (i, err) => onError(err),
			onResult: (i, result, next) => {
				let code = "";
				code += `if(${result} !== undefined) {\n`;
				code += `${this._args[0]} = ${result};\n`;
				code += `}\n`;
				code += next();
				return code;
			},
			onDone: () => onResult(this._args[0]),
			doneReturns: resultReturns,
			rethrowIfPossible
		});
	}
}

const factory = new SyncWaterfallHookCodeFactory();

const TAP_ASYNC = () => {
	throw new Error("tapAsync is not supported on a SyncWaterfallHook");
};

const TAP_PROMISE = () => {
	throw new Error("tapPromise is not supported on a SyncWaterfallHook");
};

const COMPILE = function(options) {
	factory.setup(this, options);
	return factory.create(options);
};

function SyncWaterfallHook(args = [], name = undefined) {
	if (args.length < 1)
		throw new Error("Waterfall hooks must have at least one argument");
	const hook = new Hook(args, name);
	hook.constructor = SyncWaterfallHook;
	hook.tapAsync = TAP_ASYNC;
	hook.tapPromise = TAP_PROMISE;
	hook.compile = COMPILE;
	return hook;
}

SyncWaterfallHook.prototype = null;

module.exports = SyncWaterfallHook;


/***/ }),

/***/ 84388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


exports.__esModule = true;
exports.SyncHook = __webpack_require__(85835);
exports.SyncBailHook = __webpack_require__(3598);
exports.SyncWaterfallHook = __webpack_require__(87845);
exports.SyncLoopHook = __webpack_require__(14613);
exports.AsyncParallelHook = __webpack_require__(16635);
exports.AsyncParallelBailHook = __webpack_require__(54688);
exports.AsyncSeriesHook = __webpack_require__(45663);
exports.AsyncSeriesBailHook = __webpack_require__(72662);
exports.AsyncSeriesLoopHook = __webpack_require__(59899);
exports.AsyncSeriesWaterfallHook = __webpack_require__(78253);
exports.HookMap = __webpack_require__(44366);
exports.MultiHook = __webpack_require__(72203);


/***/ }),

/***/ 9141:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/


exports.deprecate = (fn, msg) => {
	let once = true;
	return function() {
		if (once) {
			console.warn("DeprecationWarning: " + msg);
			once = false;
		}
		return fn.apply(this, arguments);
	};
};


/***/ }),

/***/ 97320:
/***/ (function(module) {

"use strict";


module.exports = 2147483647;


/***/ }),

/***/ 47987:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toPosInt   = __webpack_require__(23701)
  , maxTimeout = __webpack_require__(97320);

module.exports = function (value) {
	value = toPosInt(value);
	if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
	return value;
};


/***/ }),

/***/ 21914:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(79282);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ 79282:
/***/ (function(module) {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ 61998:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(87840);

module.exports = function (value) {
	if (typeof value !== "function") return false;

	if (!hasOwnProperty.call(value, "length")) return false;

	try {
		if (typeof value.length !== "number") return false;
		if (typeof value.call !== "function") return false;
		if (typeof value.apply !== "function") return false;
	} catch (error) {
		return false;
	}

	return !isPrototype(value);
};


/***/ }),

/***/ 86604:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue       = __webpack_require__(14704)
  , isObject      = __webpack_require__(34601)
  , stringCoerce  = __webpack_require__(73590)
  , toShortString = __webpack_require__(10393);

var resolveMessage = function (message, value) {
	return message.replace("%v", toShortString(value));
};

module.exports = function (value, defaultMessage, inputOptions) {
	if (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));
	if (!isValue(value)) {
		if ("default" in inputOptions) return inputOptions["default"];
		if (inputOptions.isOptional) return null;
	}
	var errorMessage = stringCoerce(inputOptions.errorMessage);
	if (!isValue(errorMessage)) errorMessage = defaultMessage;
	throw new TypeError(resolveMessage(errorMessage, value));
};


/***/ }),

/***/ 11451:
/***/ (function(module) {

"use strict";


module.exports = function (value) {
	try {
		return value.toString();
	} catch (error) {
		try { return String(value); }
		catch (error2) { return null; }
	}
};


/***/ }),

/***/ 10393:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var safeToString = __webpack_require__(11451);

var reNewLine = /[\n\r\u2028\u2029]/g;

module.exports = function (value) {
	var string = safeToString(value);
	if (string === null) return "<Non-coercible to string value>";
	// Trim if too long
	if (string.length > 100) string = string.slice(0, 99) + "…";
	// Replace eventual new lines
	string = string.replace(reNewLine, function (char) {
		switch (char) {
			case "\n":
				return "\\n";
			case "\r":
				return "\\r";
			case "\u2028":
				return "\\u2028";
			case "\u2029":
				return "\\u2029";
			/* istanbul ignore next */
			default:
				throw new Error("Unexpected character");
		}
	});
	return string;
};


/***/ }),

/***/ 34601:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue = __webpack_require__(14704);

// prettier-ignore
var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

module.exports = function (value) {
	if (!isValue(value)) return false;
	return hasOwnProperty.call(possibleTypes, typeof value);
};


/***/ }),

/***/ 42690:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var resolveException = __webpack_require__(86604)
  , is               = __webpack_require__(56983);

module.exports = function (value/*, options*/) {
	if (is(value)) return value;
	return resolveException(value, "%v is not a plain function", arguments[1]);
};


/***/ }),

/***/ 56983:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(61998);

var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

module.exports = function (value) {
	if (!isFunction(value)) return false;
	if (classRe.test(functionToString.call(value))) return false;
	return true;
};


/***/ }),

/***/ 87840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(34601);

module.exports = function (value) {
	if (!isObject(value)) return false;
	try {
		if (!value.constructor) return false;
		return value.constructor.prototype === value;
	} catch (error) {
		return false;
	}
};


/***/ }),

/***/ 73590:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isValue  = __webpack_require__(14704)
  , isObject = __webpack_require__(34601);

var objectToString = Object.prototype.toString;

module.exports = function (value) {
	if (!isValue(value)) return null;
	if (isObject(value)) {
		// Reject Object.prototype.toString coercion
		var valueToString = value.toString;
		if (typeof valueToString !== "function") return null;
		if (valueToString === objectToString) return null;
		// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant
		// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case
	}
	try {
		return "" + value; // Ensure implicit coercion
	} catch (error) {
		return null;
	}
};


/***/ }),

/***/ 41072:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var resolveException = __webpack_require__(86604)
  , is               = __webpack_require__(14704);

module.exports = function (value/*, options*/) {
	if (is(value)) return value;
	return resolveException(value, "Cannot use %v", arguments[1]);
};


/***/ }),

/***/ 14704:
/***/ (function(module) {

"use strict";


// ES3 safe
var _undefined = void 0;

module.exports = function (value) { return value !== _undefined && value !== null; };


/***/ }),

/***/ 12854:
/***/ (function(__unused_webpack_module, exports) {

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	0;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
//RFC 6455
var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === 'boolean') {
            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path && path !== '/' ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


/***/ }),

/***/ 44330:
/***/ (function(module) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ 10082:
/***/ (function(module) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ 43335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* provided dependency */ var process = __webpack_require__(34406);
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(__webpack_require__.g.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(10082);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(44330);

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),

/***/ 51574:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
const core_1 = __webpack_require__(73660);
const draft7_1 = __webpack_require__(34151);
const discriminator_1 = __webpack_require__(89478);
const draft7MetaSchema = __webpack_require__(58117);
const META_SUPPORT_DATA = ["/properties"];
const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
class Ajv extends core_1.default {
    _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
            this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
            return;
        const metaSchema = this.opts.$data
            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
            : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
        return (this.opts.defaultMeta =
            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
    }
}
module.exports = exports = Ajv;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Ajv;
var validate_1 = __webpack_require__(55731);
Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
var codegen_1 = __webpack_require__(20271);
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
//# sourceMappingURL=ajv.js.map

/***/ }),

/***/ 36187:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
class _CodeOrName {
}
exports._CodeOrName = _CodeOrName;
exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
class Name extends _CodeOrName {
    constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
            throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        return false;
    }
    get names() {
        return { [this.str]: 1 };
    }
}
exports.Name = Name;
class _Code extends _CodeOrName {
    constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
        return this.str;
    }
    emptyStr() {
        if (this._items.length > 1)
            return false;
        const item = this._items[0];
        return item === "" || item === '""';
    }
    get str() {
        var _a;
        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
    }
    get names() {
        var _a;
        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
            if (c instanceof Name)
                names[c.str] = (names[c.str] || 0) + 1;
            return names;
        }, {})));
    }
}
exports._Code = _Code;
exports.nil = new _Code("");
function _(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
    }
    return new _Code(code);
}
exports._ = _;
const plus = new _Code("+");
function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
}
exports.str = str;
function addCodeArg(code, arg) {
    if (arg instanceof _Code)
        code.push(...arg._items);
    else if (arg instanceof Name)
        code.push(arg);
    else
        code.push(interpolate(arg));
}
exports.addCodeArg = addCodeArg;
function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
        if (expr[i] === plus) {
            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
            if (res !== undefined) {
                expr.splice(i - 1, 3, res);
                continue;
            }
            expr[i++] = "+";
        }
        i++;
    }
}
function mergeExprItems(a, b) {
    if (b === '""')
        return a;
    if (a === '""')
        return b;
    if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
            return;
        if (typeof b != "string")
            return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
            return a.slice(0, -1) + b.slice(1);
        return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    return;
}
function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
}
exports.strConcat = strConcat;
// TODO do not allow arrays here
function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null
        ? x
        : safeStringify(Array.isArray(x) ? x.join(",") : x);
}
function stringify(x) {
    return new _Code(safeStringify(x));
}
exports.stringify = stringify;
function safeStringify(x) {
    return JSON.stringify(x)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
}
exports.safeStringify = safeStringify;
function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
}
exports.getProperty = getProperty;
function regexpCode(rx) {
    return new _Code(rx.toString());
}
exports.regexpCode = regexpCode;
//# sourceMappingURL=code.js.map

/***/ }),

/***/ 20271:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
const code_1 = __webpack_require__(36187);
const scope_1 = __webpack_require__(40575);
var code_2 = __webpack_require__(36187);
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return code_2._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return code_2.str; } }));
Object.defineProperty(exports, "strConcat", ({ enumerable: true, get: function () { return code_2.strConcat; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return code_2.nil; } }));
Object.defineProperty(exports, "getProperty", ({ enumerable: true, get: function () { return code_2.getProperty; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return code_2.stringify; } }));
Object.defineProperty(exports, "regexpCode", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return code_2.Name; } }));
var scope_2 = __webpack_require__(40575);
Object.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return scope_2.Scope; } }));
Object.defineProperty(exports, "ValueScope", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));
Object.defineProperty(exports, "ValueScopeName", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));
Object.defineProperty(exports, "varKinds", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));
exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+"),
};
class Node {
    optimizeNodes() {
        return this;
    }
    optimizeNames(_names, _constants) {
        return this;
    }
}
class Def extends Node {
    constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
    }
    render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (!names[this.name.str])
            return;
        if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
}
class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
    }
    render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    }
    get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
    }
}
class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
    }
    render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
}
class Label extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        return `${this.label}:` + _n;
    }
}
class Break extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {};
    }
    render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
    }
}
class Throw extends Node {
    constructor(error) {
        super();
        this.error = error;
    }
    render({ _n }) {
        return `throw ${this.error};` + _n;
    }
    get names() {
        return this.error.names;
    }
}
class AnyCode extends Node {
    constructor(code) {
        super();
        this.code = code;
    }
    render({ _n }) {
        return `${this.code};` + _n;
    }
    optimizeNodes() {
        return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
    }
    get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
}
class ParentNode extends Node {
    constructor(nodes = []) {
        super();
        this.nodes = nodes;
    }
    render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
            else if (n)
                nodes[i] = n;
            else
                nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i];
            if (n.optimizeNames(names, constants))
                continue;
            subtractNames(names, n.names);
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : undefined;
    }
    get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
}
class BlockNode extends ParentNode {
    render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
}
class Root extends ParentNode {
}
class Else extends BlockNode {
}
Else.kind = "else";
class If extends BlockNode {
    constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
    }
    render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
            code += "else " + this.else.render(opts);
        return code;
    }
    optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
            return this.nodes; // else is ignored here
        let e = this.else;
        if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
            if (cond === false)
                return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
                return this;
            return new If(not(cond), e instanceof If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
            return undefined;
        return this;
    }
    optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
            return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
            addNames(names, this.else.names);
        return names;
    }
}
If.kind = "if";
class For extends BlockNode {
}
For.kind = "for";
class ForLoop extends For {
    constructor(iteration) {
        super();
        this.iteration = iteration;
    }
    render(opts) {
        return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iteration.names);
    }
}
class ForRange extends For {
    constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
    }
    render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
    }
}
class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
    }
    render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
    }
    get names() {
        return addNames(super.names, this.iterable.names);
    }
}
class Func extends BlockNode {
    constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
    }
    render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
}
Func.kind = "func";
class Return extends ParentNode {
    render(opts) {
        return "return " + super.render(opts);
    }
}
Return.kind = "return";
class Try extends BlockNode {
    render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
            code += this.catch.render(opts);
        if (this.finally)
            code += this.finally.render(opts);
        return code;
    }
    optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
    }
    optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
    }
    get names() {
        const names = super.names;
        if (this.catch)
            addNames(names, this.catch.names);
        if (this.finally)
            addNames(names, this.finally.names);
        return names;
    }
}
class Catch extends BlockNode {
    constructor(error) {
        super();
        this.error = error;
    }
    render(opts) {
        return `catch(${this.error})` + super.render(opts);
    }
}
Catch.kind = "catch";
class Finally extends BlockNode {
    render(opts) {
        return "finally" + super.render(opts);
    }
}
Finally.kind = "finally";
class CodeGen {
    constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
    }
    toString() {
        return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    }
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    }
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
        return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== undefined && constant)
            this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
        return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
            if (code.length > 1)
                code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
                code.push(":");
                (0, code_1.addCodeArg)(code, value);
            }
        }
        code.push("}");
        return new code_1._Code(code);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        }
        else if (thenBody) {
            this.code(thenBody).endIf();
        }
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
        return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
        return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
            this.code(forBody).endFor();
        return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
                this.var(name, (0, code_1._) `${arr}[${i}]`);
                forBody(name);
            });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
        return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
        return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
        return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
        }
        if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error) {
        return this._leafNode(new Throw(error));
    }
    // start self-balancing block
    block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
            this.code(body).endBlock(nodeCount);
        return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    }
    // end function definition
    endFunc() {
        return this._endBlockNode(Func);
    }
    optimize(n = 1) {
        while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
        }
    }
    _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
    }
    _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop();
            return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
    }
    get _root() {
        return this._nodes[0];
    }
    get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
    }
    set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
    }
}
exports.CodeGen = CodeGen;
function addNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
}
function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
}
function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
        return replaceName(expr);
    if (!canOptimize(expr))
        return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
            c = replaceName(c);
        if (c instanceof code_1._Code)
            items.push(...c._items);
        else
            items.push(c);
        return items;
    }, []));
    function replaceName(n) {
        const c = constants[n.str];
        if (c === undefined || names[n.str] !== 1)
            return n;
        delete names[n.str];
        return c;
    }
    function canOptimize(e) {
        return (e instanceof code_1._Code &&
            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
    }
}
function subtractNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
}
function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
}
exports.not = not;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
}
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
}
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
}
function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 40575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
const code_1 = __webpack_require__(36187);
class ValueError extends Error {
    constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
    }
}
var UsedValueState;
(function (UsedValueState) {
    UsedValueState[UsedValueState["Started"] = 0] = "Started";
    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var"),
};
class Scope {
    constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
    }
    toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
        return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return (this._names[prefix] = { prefix, index: 0 });
    }
}
exports.Scope = Scope;
class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
    }
}
exports.ValueScopeName = ValueScopeName;
const line = (0, code_1._) `\n`;
class ValueScope extends Scope {
    constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
        return this._scope;
    }
    name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
        var _a;
        if (value.ref === undefined)
            throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
                return _name;
        }
        else {
            vs = this._values[prefix] = new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
    }
    getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
            return;
        return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_1._) `${scopeName}${name.scopePath}`;
        });
    }
    scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
            if (name.value === undefined)
                throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
        }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
                continue;
            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
            vs.forEach((name) => {
                if (nameSet.has(name))
                    return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
                }
                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
                }
                else {
                    throw new ValueError(name);
                }
                nameSet.set(name, UsedValueState.Completed);
            });
        }
        return code;
    }
}
exports.ValueScope = ValueScope;
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ 37523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const names_1 = __webpack_require__(82654);
exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
};
exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType
        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
};
function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
        addError(gen, errObj);
    }
    else {
        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
    }
}
exports.reportError = reportError;
function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
    }
}
exports.reportExtraError = reportExtraError;
function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
}
exports.resetErrorsCount = resetErrorsCount;
function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
    /* istanbul ignore if */
    if (errsCount === undefined)
        throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
            gen.assign((0, codegen_1._) `${err}.data`, data);
        }
    });
}
exports.extendErrors = extendErrors;
function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
}
function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
        gen.return(false);
    }
}
const E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema"),
};
function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
        return (0, codegen_1._) `{}`;
    return errorObject(cxt, error, errorPaths);
}
function errorObject(cxt, error, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths),
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
}
function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath
        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
        : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
}
function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
    if (schemaPath) {
        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
}
function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
}
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 24685:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
const codegen_1 = __webpack_require__(20271);
const validation_error_1 = __webpack_require__(61735);
const names_1 = __webpack_require__(82654);
const resolve_1 = __webpack_require__(49488);
const util_1 = __webpack_require__(19439);
const validate_1 = __webpack_require__(55731);
const URI = __webpack_require__(12854);
class SchemaEnv {
    constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
            schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
    }
}
exports.SchemaEnv = SchemaEnv;
// let codeSize = 0
// let nodeCount = 0
// Compiles schema in SchemaEnv
function compileSchema(sch) {
    // TODO refactor - remove compilations
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const rootId = (0, resolve_1.getFullPath)(sch.root.baseId); // TODO if getFullPath removed 1 tests fails
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
            ref: validation_error_1.default,
            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
        });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        dataLevel: 0,
        dataTypes: [],
        definedProperties: new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
            : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._) `""`,
        opts: this.opts,
        self: this,
    };
    let sourceCode;
    try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        // gen.optimize(1)
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
        if (this.opts.code.process)
            sourceCode = this.opts.code.process(sourceCode, sch);
        // console.log("\n\n\n *** \n", sourceCode)
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
            validate.$async = true;
        if (this.opts.code.source === true) {
            validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
            const { props, items } = schemaCxt;
            validate.evaluated = {
                props: props instanceof codegen_1.Name ? undefined : props,
                items: items instanceof codegen_1.Name ? undefined : items,
                dynamicProps: props instanceof codegen_1.Name,
                dynamicItems: items instanceof codegen_1.Name,
            };
            if (validate.source)
                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
    }
    catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
            this.logger.error("Error compiling schema, function code:", sourceCode);
        // console.log("\n\n\n *** \n", sourceCode, this.opts)
        throw e;
    }
    finally {
        this._compilations.delete(sch);
    }
}
exports.compileSchema = compileSchema;
function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
        return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
        const { schemaId } = this.opts;
        if (schema)
            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
        return;
    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
}
exports.resolveRef = resolveRef;
function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
}
// Index of schema compilation in the currently compiled list
function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
            return sch;
    }
}
exports.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
// resolve and compile the references ($ref)
// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
function resolve(root, // information about the root schema for the current schema
ref // reference to resolve
) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
}
// Resolve schema, its root and baseId
function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
ref // reference to resolve
) {
    const p = URI.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(p);
    let baseId = (0, resolve_1.getFullPath)(root.baseId);
    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
            return;
        return getJsonPointer.call(this, p, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
    if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
            baseId = (0, resolve_1.resolveUrl)(baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p, schOrRef);
}
exports.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions",
]);
function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
            return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === undefined)
            return;
        schema = partSchema;
        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
            baseId = (0, resolve_1.resolveUrl)(baseId, schId);
        }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
    }
    // even though resolution failed we need to return SchemaEnv to throw exception
    // so that compileAsync loads missing schema.
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
        return env;
    return undefined;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const names = {
    // validation function arguments
    data: new codegen_1.Name("data"),
    // args passed from referencing schema
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    // function scoped variables
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    // "globals"
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart"),
};
exports["default"] = names;
//# sourceMappingURL=names.js.map

/***/ }),

/***/ 84514:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const resolve_1 = __webpack_require__(49488);
class MissingRefError extends Error {
    constructor(baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(this.missingRef));
    }
}
exports["default"] = MissingRefError;
//# sourceMappingURL=ref_error.js.map

/***/ }),

/***/ 49488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
const util_1 = __webpack_require__(19439);
const equal = __webpack_require__(69378);
const traverse = __webpack_require__(19522);
const URI = __webpack_require__(12854);
// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
]);
function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
        return true;
    if (limit === true)
        return !hasRef(schema);
    if (!limit)
        return false;
    return countKeys(schema) <= limit;
}
exports.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor",
]);
function hasRef(schema) {
    for (const key in schema) {
        if (REF_KEYWORDS.has(key))
            return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
            return true;
        if (typeof sch == "object" && hasRef(sch))
            return true;
    }
    return false;
}
function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
        if (key === "$ref")
            return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
            continue;
        if (typeof schema[key] == "object") {
            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
        }
        if (count === Infinity)
            return Infinity;
    }
    return count;
}
function getFullPath(id = "", normalize) {
    if (normalize !== false)
        id = normalizeId(id);
    const p = URI.parse(id);
    return _getFullPath(p);
}
exports.getFullPath = getFullPath;
function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
}
exports._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
}
exports.normalizeId = normalizeId;
function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
}
exports.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
        return {};
    const { schemaId } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(schId, false);
    const localRefs = {};
    const schemaRefs = new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === undefined)
            return;
        const fullPath = pathPrefix + jsonPtr;
        let baseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
            baseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = baseId;
        function addRef(ref) {
            ref = normalizeId(baseId ? URI.resolve(baseId, ref) : ref);
            if (schemaRefs.has(ref))
                throw ambiguos(ref);
            schemaRefs.add(ref);
            let schOrRef = this.refs[ref];
            if (typeof schOrRef == "string")
                schOrRef = this.refs[schOrRef];
            if (typeof schOrRef == "object") {
                checkAmbiguosRef(sch, schOrRef.schema, ref);
            }
            else if (ref !== normalizeId(fullPath)) {
                if (ref[0] === "#") {
                    checkAmbiguosRef(sch, localRefs[ref], ref);
                    localRefs[ref] = sch;
                }
                else {
                    this.refs[ref] = fullPath;
                }
            }
            return ref;
        }
        function addAnchor(anchor) {
            if (typeof anchor == "string") {
                if (!ANCHOR.test(anchor))
                    throw new Error(`invalid anchor "${anchor}"`);
                addRef.call(this, `#${anchor}`);
            }
        }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== undefined && !equal(sch1, sch2))
            throw ambiguos(ref);
    }
    function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
    }
}
exports.getSchemaRefs = getSchemaRefs;
//# sourceMappingURL=resolve.js.map

/***/ }),

/***/ 74387:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRules = exports.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
    return typeof x == "string" && jsonTypes.has(x);
}
exports.isJSONType = isJSONType;
function getRules() {
    const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
    };
    return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {},
    };
}
exports.getRules = getRules;
//# sourceMappingURL=rules.js.map

/***/ }),

/***/ 19439:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
const codegen_1 = __webpack_require__(20271);
const code_1 = __webpack_require__(36187);
// TODO refactor to use Set
function toHash(arr) {
    const hash = {};
    for (const item of arr)
        hash[item] = true;
    return hash;
}
exports.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
}
exports.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self } = it;
    if (!opts.strictSchema)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key}"`);
    }
}
exports.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
}
exports.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
}
exports.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return (0, codegen_1._) `${schema}`;
    }
    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
}
exports.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
}
exports.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
}
exports.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
exports.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
exports.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    }
    else {
        f(xs);
    }
}
exports.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen_1.Name
                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen_1.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
}
exports.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            }
            else {
                gen.assign(to, (0, codegen_1._) `${to} || {}`);
                setEvaluated(gen, to, from);
            }
        }),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
        resultToName: evaluatedPropsToName,
    }),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    }),
};
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._) `{}`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
}
exports.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
}
exports.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
    return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
    });
}
exports.useFunc = useFunc;
var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
})(Type = exports.Type || (exports.Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
            : isNumber
                ? (0, codegen_1._) `"/" + ${dataProp}`
                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
exports.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
        return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
}
exports.checkStrictMode = checkStrictMode;
//# sourceMappingURL=util.js.map

/***/ }),

/***/ 8402:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema, self }, type) {
    const group = self.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
}
exports.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
}
exports.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema, rule) {
    var _a;
    return (schema[rule.keyword] !== undefined ||
        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
}
exports.shouldUseRule = shouldUseRule;
//# sourceMappingURL=applicability.js.map

/***/ }),

/***/ 50117:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
const errors_1 = __webpack_require__(37523);
const codegen_1 = __webpack_require__(20271);
const names_1 = __webpack_require__(82654);
const boolError = {
    message: "boolean schema is false",
};
function topBoolOrEmptySchema(it) {
    const { gen, schema, validateName } = it;
    if (schema === false) {
        falseSchemaError(it, false);
    }
    else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
        gen.return(true);
    }
}
exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid) {
    const { gen, schema } = it;
    if (schema === false) {
        gen.var(valid, false); // TODO var
        falseSchemaError(it);
    }
    else {
        gen.var(valid, true); // TODO var
    }
}
exports.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
    const { gen, data } = it;
    // TODO maybe some other interface should be used for non-keyword validation errors...
    const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it,
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
}
//# sourceMappingURL=boolSchema.js.map

/***/ }),

/***/ 19259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
const rules_1 = __webpack_require__(74387);
const applicability_1 = __webpack_require__(8402);
const errors_1 = __webpack_require__(37523);
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
})(DataType = exports.DataType || (exports.DataType = {}));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    }
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
            types.push("null");
    }
    return types;
}
exports.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
}
exports.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts } = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        });
    }
    return checkTypes;
}
exports.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
}
function coerceData(it, types, coerceTo) {
    const { gen, data, opts } = it;
    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
            .assign(data, (0, codegen_1._) `${data}[0]`)
            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._) `${coerced} !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    });
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
                    .elseIf((0, codegen_1._) `${data} === null`)
                    .assign(coerced, (0, codegen_1._) `""`);
                return;
            case "number":
                gen
                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
                    .assign(coerced, (0, codegen_1._) `+${data}`);
                return;
            case "integer":
                gen
                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
                    .assign(coerced, (0, codegen_1._) `+${data}`);
                return;
            case "boolean":
                gen
                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
                    .assign(coerced, false)
                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
                    .assign(coerced, (0, codegen_1._) `[${data}]`);
        }
    }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    // TODO use gen.property
    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return (0, codegen_1._) `${data} ${EQ} null`;
        case "array":
            cond = (0, codegen_1._) `Array.isArray(${data})`;
            break;
        case "object":
            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
            break;
        case "integer":
            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
    }
}
exports.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
    }
    else {
        cond = codegen_1.nil;
    }
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
}
exports.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
};
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
}
exports.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema } = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it,
    };
}
//# sourceMappingURL=dataType.js.map

/***/ }),

/***/ 3506:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assignDefaults = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
function assignDefaults(it, ty) {
    const { properties, items } = it.schema;
    if (ty === "object" && properties) {
        for (const key in properties) {
            assignDefault(it, key, properties[key].default);
        }
    }
    else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
}
exports.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it;
    if (defaultValue === undefined)
        return;
    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
    }
    let condition = (0, codegen_1._) `${childData} === undefined`;
    if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
    }
    // `${childData} === undefined` +
    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
}
//# sourceMappingURL=defaults.js.map

/***/ }),

/***/ 55731:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
const boolSchema_1 = __webpack_require__(50117);
const dataType_1 = __webpack_require__(19259);
const applicability_1 = __webpack_require__(8402);
const dataType_2 = __webpack_require__(19259);
const defaults_1 = __webpack_require__(3506);
const keyword_1 = __webpack_require__(28357);
const subschema_1 = __webpack_require__(18438);
const codegen_1 = __webpack_require__(20271);
const names_1 = __webpack_require__(82654);
const resolve_1 = __webpack_require__(49488);
const util_1 = __webpack_require__(19439);
const errors_1 = __webpack_require__(37523);
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        }
    }
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
}
exports.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        });
    }
    else {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
}
function destructureValCxt(opts) {
    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
    });
}
function topSchemaObjCode(it) {
    const { schema, opts, gen } = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    });
    return;
}
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName } = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
}
function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
}
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
}
function schemaCxtHasRules({ schema, self }) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
}
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts } = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
}
function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self } = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
}
function checkNoDefault(it) {
    const { schema, opts } = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
}
function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.baseId, schId);
}
function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
    }
    else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
}
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
    }
    else {
        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
    }
}
function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
}
function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self } = it;
    const { RULES } = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    }
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
        if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                (0, dataType_2.reportTypeError)(it);
            }
            gen.endIf();
        }
        else {
            iterateKeywords(it, group);
        }
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
    }
}
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults }, } = it;
    if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
            }
        }
    });
}
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    }
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
    });
    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));
}
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
}
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type } = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
            }
        }
    }
}
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
}
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
}
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
    constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        }
        else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
            }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
    }
    result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        }
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        }
    }
    pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    }
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
        if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({});
            return;
        }
        this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    }
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
                gen.assign(valid, false);
        }
        gen.else();
    }
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
            }
            return codegen_1.nil;
        }
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
            }
            return codegen_1.nil;
        }
    }
    subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
        subschemaCode(nextContext, valid);
        return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
    }
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
        }
    }
}
exports.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    }
    else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
    }
    else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
    }
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
            expr = (0, codegen_1._) `${expr} && ${data}`;
        }
    }
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
}
exports.getData = getData;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 28357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
const codegen_1 = __webpack_require__(20271);
const names_1 = __webpack_require__(82654);
const code_1 = __webpack_require__(20574);
const errors_1 = __webpack_require__(37523);
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it } = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
}
exports.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        }
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        }
    }
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
    }
    function validateSync() {
        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
        var _a;
        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    }
}
exports.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
    const { gen, data, it } = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
        gen
            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
}
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
}
exports.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
                self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        }
    }
}
exports.validateKeywordUsage = validateKeywordUsage;
//# sourceMappingURL=keyword.js.map

/***/ }),

/***/ 18438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
            }
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
            };
    }
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        };
    }
    throw new Error('either "keyword" or "schema" must be passed');
}
exports.getSubschema = getSubschema;
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    }
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    }
}
exports.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
}
exports.extendSubschemaMode = extendSubschemaMode;
//# sourceMappingURL=subschema.js.map

/***/ }),

/***/ 73660:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
var validate_1 = __webpack_require__(55731);
Object.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));
var codegen_1 = __webpack_require__(20271);
Object.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));
Object.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));
Object.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));
Object.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));
Object.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));
const validation_error_1 = __webpack_require__(61735);
const ref_error_1 = __webpack_require__(84514);
const rules_1 = __webpack_require__(74387);
const compile_1 = __webpack_require__(24685);
const codegen_2 = __webpack_require__(20271);
const resolve_1 = __webpack_require__(49488);
const dataType_1 = __webpack_require__(19259);
const util_1 = __webpack_require__(19439);
const $dataRefSchema = __webpack_require__(47498);
const defaultRegExp = (str, flags) => new RegExp(str, flags);
defaultRegExp.code = "new RegExp";
const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error",
]);
const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now.",
};
const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
};
const MAX_EXPRESSION = 200;
// eslint-disable-next-line complexity
function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const s = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    return {
        strictSchema: (_e = (_d = o.strictSchema) !== null && _d !== void 0 ? _d : s) !== null && _e !== void 0 ? _e : true,
        strictNumbers: (_g = (_f = o.strictNumbers) !== null && _f !== void 0 ? _f : s) !== null && _g !== void 0 ? _g : true,
        strictTypes: (_j = (_h = o.strictTypes) !== null && _h !== void 0 ? _h : s) !== null && _j !== void 0 ? _j : "log",
        strictTuples: (_l = (_k = o.strictTuples) !== null && _k !== void 0 ? _k : s) !== null && _l !== void 0 ? _l : "log",
        strictRequired: (_o = (_m = o.strictRequired) !== null && _m !== void 0 ? _m : s) !== null && _o !== void 0 ? _o : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_p = o.loopRequired) !== null && _p !== void 0 ? _p : MAX_EXPRESSION,
        loopEnum: (_q = o.loopEnum) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        meta: (_r = o.meta) !== null && _r !== void 0 ? _r : true,
        messages: (_s = o.messages) !== null && _s !== void 0 ? _s : true,
        inlineRefs: (_t = o.inlineRefs) !== null && _t !== void 0 ? _t : true,
        schemaId: (_u = o.schemaId) !== null && _u !== void 0 ? _u : "$id",
        addUsedSchema: (_v = o.addUsedSchema) !== null && _v !== void 0 ? _v : true,
        validateSchema: (_w = o.validateSchema) !== null && _w !== void 0 ? _w : true,
        validateFormats: (_x = o.validateFormats) !== null && _x !== void 0 ? _x : true,
        unicodeRegExp: (_y = o.unicodeRegExp) !== null && _y !== void 0 ? _y : true,
        int32range: (_z = o.int32range) !== null && _z !== void 0 ? _z : true,
    };
}
class Ajv {
    constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = new Set();
        this._loading = {};
        this._cache = new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
            addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
            addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
            this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
        this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
            _dataRefSchema = { ...$dataRefSchema };
            _dataRefSchema.id = _dataRefSchema.$id;
            delete _dataRefSchema.$id;
        }
        if (meta && $data)
            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
        const { meta, schemaId } = this.opts;
        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
    }
    validate(schemaKeyRef, // key, ref or schema object
    data // to be validated
    ) {
        let v;
        if (typeof schemaKeyRef == "string") {
            v = this.getSchema(schemaKeyRef);
            if (!v)
                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        }
        else {
            v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
            this.errors = v.errors;
        return valid;
    }
    compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
            throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
            await loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
            if ($ref && !this.getSchema($ref)) {
                await runCompileAsync.call(this, { $ref }, true);
            }
        }
        async function _compileAsync(sch) {
            try {
                return this._compileSchemaEnv(sch);
            }
            catch (e) {
                if (!(e instanceof ref_error_1.default))
                    throw e;
                checkLoaded.call(this, e);
                await loadMissingSchema.call(this, e.missingSchema);
                return _compileAsync.call(this, sch);
            }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
            if (this.refs[ref]) {
                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
            }
        }
        async function loadMissingSchema(ref) {
            const _schema = await _loadSchema.call(this, ref);
            if (!this.refs[ref])
                await loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
                this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
            const p = this._loading[ref];
            if (p)
                return p;
            try {
                return await (this._loading[ref] = loadSchema(ref));
            }
            finally {
                delete this._loading[ref];
            }
        }
    }
    // Adds schema to the instance
    addSchema(schema, // If array is passed, `key` will be ignored
    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
    ) {
        if (Array.isArray(schema)) {
            for (const sch of schema)
                this.addSchema(sch, undefined, _meta, _validateSchema);
            return this;
        }
        let id;
        if (typeof schema === "object") {
            const { schemaId } = this.opts;
            id = schema[schemaId];
            if (id !== undefined && typeof id != "string") {
                throw new Error(`schema ${schemaId} must be string`);
            }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema, key, // schema key
    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
    ) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
            return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== undefined && typeof $schema != "string") {
            throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
            this.logger.warn("meta-schema not available");
            this.errors = null;
            return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
            const message = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
                this.logger.error(message);
            else
                throw new Error(message);
        }
        return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
            keyRef = sch;
        if (sch === undefined) {
            const { schemaId } = this.opts;
            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
            sch = compile_1.resolveSchema.call(this, root, keyRef);
            if (!sch)
                return;
            this.refs[keyRef] = sch;
        }
        return (sch.validate || this._compileSchemaEnv(sch));
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
            this._removeAllSchemas(this.schemas, schemaKeyRef);
            this._removeAllSchemas(this.refs, schemaKeyRef);
            return this;
        }
        switch (typeof schemaKeyRef) {
            case "undefined":
                this._removeAllSchemas(this.schemas);
                this._removeAllSchemas(this.refs);
                this._cache.clear();
                return this;
            case "string": {
                const sch = getSchEnv.call(this, schemaKeyRef);
                if (typeof sch == "object")
                    this._cache.delete(sch.schema);
                delete this.schemas[schemaKeyRef];
                delete this.refs[schemaKeyRef];
                return this;
            }
            case "object": {
                const cacheKey = schemaKeyRef;
                this._cache.delete(cacheKey);
                let id = schemaKeyRef[this.opts.schemaId];
                if (id) {
                    id = (0, resolve_1.normalizeId)(id);
                    delete this.schemas[id];
                    delete this.refs[id];
                }
                return this;
            }
            default:
                throw new Error("ajv.removeSchema: invalid parameter");
        }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions) {
        for (const def of definitions)
            this.addKeyword(def);
        return this;
    }
    addKeyword(kwdOrDef, def // deprecated
    ) {
        let keyword;
        if (typeof kwdOrDef == "string") {
            keyword = kwdOrDef;
            if (typeof def == "object") {
                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
                def.keyword = keyword;
            }
        }
        else if (typeof kwdOrDef == "object" && def === undefined) {
            def = kwdOrDef;
            keyword = def.keyword;
            if (Array.isArray(keyword) && !keyword.length) {
                throw new Error("addKeywords: keyword must be string or non-empty array");
            }
        }
        else {
            throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
            return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
            ...def,
            type: (0, dataType_1.getJSONTypes)(def.type),
            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0
            ? (k) => addRule.call(this, k, definition)
            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
    }
    getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword) {
        // TODO return type should be Ajv
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
            if (i >= 0)
                group.rules.splice(i, 1);
        }
        return this;
    }
    // Add format
    addFormat(name, format) {
        if (typeof format == "string")
            format = new RegExp(format);
        this.formats[name] = format;
        return this;
    }
    errorsText(errors = this.errors, // optional array of validation errors
    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
    ) {
        if (!errors || errors.length === 0)
            return "No errors";
        return errors
            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
            .reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
            let keywords = metaSchema;
            for (const seg of segments)
                keywords = keywords[seg];
            for (const key in rules) {
                const rule = rules[key];
                if (typeof rule != "object")
                    continue;
                const { $data } = rule.definition;
                const schema = keywords[key];
                if ($data && schema)
                    keywords[key] = schemaOrData(schema);
            }
        }
        return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
            const sch = schemas[keyRef];
            if (!regex || regex.test(keyRef)) {
                if (typeof sch == "string") {
                    delete schemas[keyRef];
                }
                else if (sch && !sch.meta) {
                    this._cache.delete(sch.schema);
                    delete schemas[keyRef];
                }
            }
        }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
            id = schema[schemaId];
        }
        else {
            if (this.opts.jtd)
                throw new Error("schema must be object");
            else if (typeof schema != "boolean")
                throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== undefined)
            return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
            if (baseId)
                this._checkUnique(baseId);
            this.refs[baseId] = sch;
        }
        if (validateSchema)
            this.validateSchema(schema, true);
        return sch;
    }
    _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
            throw new Error(`schema with key or id "${id}" already exists`);
        }
    }
    _compileSchemaEnv(sch) {
        if (sch.meta)
            this._compileMetaSchema(sch);
        else
            compile_1.compileSchema.call(this, sch);
        /* istanbul ignore if */
        if (!sch.validate)
            throw new Error("ajv implementation error");
        return sch.validate;
    }
    _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
            compile_1.compileSchema.call(this, sch);
        }
        finally {
            this.opts = currentOpts;
        }
    }
}
exports["default"] = Ajv;
Ajv.ValidationError = validation_error_1.default;
Ajv.MissingRefError = ref_error_1.default;
function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
}
function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
    return this.schemas[keyRef] || this.refs[keyRef];
}
function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
        return;
    if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
    else
        for (const key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
}
function addInitialFormats() {
    for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
            this.addFormat(name, format);
    }
}
function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
            def.keyword = keyword;
        this.addKeyword(def);
    }
}
function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
    return metaOpts;
}
const noLogs = { log() { }, warn() { }, error() { } };
function getLogger(logger) {
    if (logger === false)
        return noLogs;
    if (logger === undefined)
        return console;
    if (logger.log && logger.warn && logger.error)
        return logger;
    throw new Error("logger must implement log, warn and error methods");
}
const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
            throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
            throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
        return;
    if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
    }
}
function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
        return;
    const rule = {
        keyword,
        definition: {
            ...definition,
            type: (0, dataType_1.getJSONTypes)(definition.type),
            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
        },
    };
    if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
        ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
}
function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
    }
    else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
    }
}
function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
        return;
    if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
}
const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
};
function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
}
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 28794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://github.com/ajv-validator/ajv/issues/889
const equal = __webpack_require__(69378);
equal.code = 'require("ajv/dist/runtime/equal").default';
exports["default"] = equal;
//# sourceMappingURL=equal.js.map

/***/ }),

/***/ 26145:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
            // high surrogate, and there is a next character
            value = str.charCodeAt(pos);
            if ((value & 0xfc00) === 0xdc00)
                pos++; // low surrogate
        }
    }
    return length;
}
exports["default"] = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
//# sourceMappingURL=ucs2length.js.map

/***/ }),

/***/ 61735:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ValidationError extends Error {
    constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
    }
}
exports["default"] = ValidationError;
//# sourceMappingURL=validation_error.js.map

/***/ }),

/***/ 72884:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateAdditionalItems = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
};
const def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
            return;
        }
        validateAdditionalItems(cxt, items);
    },
};
function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it } = cxt;
    it.items = true;
    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
    if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
    }
    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
    }
    function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
            if (!it.allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
    }
}
exports.validateAdditionalItems = validateAdditionalItems;
exports["default"] = def;
//# sourceMappingURL=additionalItems.js.map

/***/ }),

/***/ 38324:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__(20574);
const codegen_1 = __webpack_require__(20271);
const names_1 = __webpack_require__(82654);
const util_1 = __webpack_require__(19439);
const error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
};
const def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        /* istanbul ignore if */
        if (!errsCount)
            throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
            return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
            gen.forIn("key", data, (key) => {
                if (!props.length && !patProps.length)
                    additionalPropertyCode(key);
                else
                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
            });
        }
        function isAdditional(key) {
            let definedProp;
            if (props.length > 8) {
                // TODO maybe an option instead of hard-coded 8?
                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
            }
            else if (props.length) {
                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
            }
            else {
                definedProp = codegen_1.nil;
            }
            if (patProps.length) {
                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
            }
            return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
                deleteAdditional(key);
                return;
            }
            if (schema === false) {
                cxt.setParams({ additionalProperty: key });
                cxt.error();
                if (!allErrors)
                    gen.break();
                return;
            }
            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
                const valid = gen.name("valid");
                if (opts.removeAdditional === "failing") {
                    applyAdditionalSchema(key, valid, false);
                    gen.if((0, codegen_1.not)(valid), () => {
                        cxt.reset();
                        deleteAdditional(key);
                    });
                }
                else {
                    applyAdditionalSchema(key, valid);
                    if (!allErrors)
                        gen.if((0, codegen_1.not)(valid), () => gen.break());
                }
            }
        }
        function applyAdditionalSchema(key, valid, errors) {
            const subschema = {
                keyword: "additionalProperties",
                dataProp: key,
                dataPropType: util_1.Type.Str,
            };
            if (errors === false) {
                Object.assign(subschema, {
                    compositeRule: true,
                    createErrors: false,
                    allErrors: false,
                });
            }
            cxt.subschema(subschema, valid);
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=additionalProperties.js.map

/***/ }),

/***/ 40993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(19439);
const def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
        const { gen, schema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
            if ((0, util_1.alwaysValidSchema)(it, sch))
                return;
            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
            cxt.ok(valid);
            cxt.mergeEvaluated(schCxt);
        });
    },
};
exports["default"] = def;
//# sourceMappingURL=allOf.js.map

/***/ }),

/***/ 97381:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__(20574);
const def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" },
};
exports["default"] = def;
//# sourceMappingURL=anyOf.js.map

/***/ }),

/***/ 94654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: ({ params: { min, max } }) => max === undefined
        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
};
const def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
            min = minContains === undefined ? 1 : minContains;
            max = maxContains;
        }
        else {
            min = 1;
        }
        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
        cxt.setParams({ min, max });
        if (max === undefined && min === 0) {
            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
            return;
        }
        if (max !== undefined && min > max) {
            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
            cxt.fail();
            return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
            let cond = (0, codegen_1._) `${len} >= ${min}`;
            if (max !== undefined)
                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
            cxt.pass(cond);
            return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === undefined && min === 1) {
            validateItems(valid, () => gen.if(valid, () => gen.break()));
        }
        else if (min === 0) {
            gen.let(valid, true);
            if (max !== undefined)
                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
        }
        else {
            gen.let(valid, false);
            validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
            const schValid = gen.name("_valid");
            const count = gen.let("count", 0);
            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
            gen.forRange("i", 0, len, (i) => {
                cxt.subschema({
                    keyword: "contains",
                    dataProp: i,
                    dataPropType: util_1.Type.Num,
                    compositeRule: true,
                }, _valid);
                block();
            });
        }
        function checkLimits(count) {
            gen.code((0, codegen_1._) `${count}++`);
            if (max === undefined) {
                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
            }
            else {
                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
                if (min === 1)
                    gen.assign(valid, true);
                else
                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
            }
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ 69068:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const code_1 = __webpack_require__(20574);
exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
};
const def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
    },
};
function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
        if (key === "__proto__")
            continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
}
function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
        return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
            continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
            property: prop,
            depsCount: deps.length,
            deps: deps.join(", "),
        });
        if (it.allErrors) {
            gen.if(hasProperty, () => {
                for (const depProp of deps) {
                    (0, code_1.checkReportMissingProp)(cxt, depProp);
                }
            });
        }
        else {
            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
        }
    }
}
exports.validatePropertyDeps = validatePropertyDeps;
function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
            continue;
        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
        }, () => gen.var(valid, true) // TODO var
        );
        cxt.ok(valid);
    }
}
exports.validateSchemaDeps = validateSchemaDeps;
exports["default"] = def;
//# sourceMappingURL=dependencies.js.map

/***/ }),

/***/ 67078:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
};
const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause });
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        }
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        }
        else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            }, schValid);
            cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword }, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
                else
                    cxt.setParams({ ifClause: keyword });
            };
        }
    },
};
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
}
exports["default"] = def;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ 81306:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const additionalItems_1 = __webpack_require__(72884);
const prefixItems_1 = __webpack_require__(80845);
const items_1 = __webpack_require__(8884);
const items2020_1 = __webpack_require__(59063);
const contains_1 = __webpack_require__(94654);
const dependencies_1 = __webpack_require__(69068);
const propertyNames_1 = __webpack_require__(60394);
const additionalProperties_1 = __webpack_require__(38324);
const properties_1 = __webpack_require__(16311);
const patternProperties_1 = __webpack_require__(31588);
const not_1 = __webpack_require__(11913);
const anyOf_1 = __webpack_require__(97381);
const oneOf_1 = __webpack_require__(24293);
const allOf_1 = __webpack_require__(40993);
const if_1 = __webpack_require__(67078);
const thenElse_1 = __webpack_require__(99187);
function getApplicator(draft2020 = false) {
    const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default,
    ];
    // array
    if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
    else
        applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
}
exports["default"] = getApplicator;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8884:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTuple = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const code_1 = __webpack_require__(20574);
const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
            return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        cxt.ok((0, code_1.validateArray)(cxt));
    },
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it } = cxt;
    checkStrictTuple(parentSchema);
    if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
    schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
            keyword,
            schemaProp: i,
            dataProp: i,
        }, valid));
        cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
    }
}
exports.validateTuple = validateTuple;
exports["default"] = def;
//# sourceMappingURL=items.js.map

/***/ }),

/***/ 59063:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const code_1 = __webpack_require__(20574);
const additionalItems_1 = __webpack_require__(72884);
const error = {
    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
};
const def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        if (prefixItems)
            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
            cxt.ok((0, code_1.validateArray)(cxt));
    },
};
exports["default"] = def;
//# sourceMappingURL=items2020.js.map

/***/ }),

/***/ 11913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(19439);
const def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
            cxt.fail();
            return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
            keyword: "not",
            compositeRule: true,
            createErrors: false,
            allErrors: false,
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" },
};
exports["default"] = def;
//# sourceMappingURL=not.js.map

/***/ }),

/***/ 24293:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
};
const def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        /* istanbul ignore if */
        if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
            return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
            schArr.forEach((sch, i) => {
                let schCxt;
                if ((0, util_1.alwaysValidSchema)(it, sch)) {
                    gen.var(schValid, true);
                }
                else {
                    schCxt = cxt.subschema({
                        keyword: "oneOf",
                        schemaProp: i,
                        compositeRule: true,
                    }, schValid);
                }
                if (i > 0) {
                    gen
                        .if((0, codegen_1._) `${schValid} && ${valid}`)
                        .assign(valid, false)
                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
                        .else();
                }
                gen.if(schValid, () => {
                    gen.assign(valid, true);
                    gen.assign(passing, i);
                    if (schCxt)
                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
                });
            });
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=oneOf.js.map

/***/ }),

/***/ 31588:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__(20574);
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const util_2 = __webpack_require__(19439);
const def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 ||
            (alwaysValidPatterns.length === patterns.length &&
                (!it.opts.unevaluated || it.props === true))) {
            return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
            for (const pat of patterns) {
                if (checkProperties)
                    checkMatchingProperties(pat);
                if (it.allErrors) {
                    validateProperties(pat);
                }
                else {
                    gen.var(valid, true); // TODO var
                    validateProperties(pat);
                    gen.if(valid);
                }
            }
        }
        function checkMatchingProperties(pat) {
            for (const prop in checkProperties) {
                if (new RegExp(pat).test(prop)) {
                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
                }
            }
        }
        function validateProperties(pat) {
            gen.forIn("key", data, (key) => {
                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
                    const alwaysValid = alwaysValidPatterns.includes(pat);
                    if (!alwaysValid) {
                        cxt.subschema({
                            keyword: "patternProperties",
                            schemaProp: pat,
                            dataProp: key,
                            dataPropType: util_2.Type.Str,
                        }, valid);
                    }
                    if (it.opts.unevaluated && props !== true) {
                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
                    }
                    else if (!alwaysValid && !it.allErrors) {
                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
                        // or if all properties were evaluated (props === true)
                        gen.if((0, codegen_1.not)(valid), () => gen.break());
                    }
                });
            });
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=patternProperties.js.map

/***/ }),

/***/ 80845:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const items_1 = __webpack_require__(8884);
const def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
};
exports["default"] = def;
//# sourceMappingURL=prefixItems.js.map

/***/ }),

/***/ 16311:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const validate_1 = __webpack_require__(55731);
const code_1 = __webpack_require__(20574);
const util_1 = __webpack_require__(19439);
const additionalProperties_1 = __webpack_require__(38324);
const def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
            it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
            return;
        const valid = gen.name("valid");
        for (const prop of properties) {
            if (hasDefault(prop)) {
                applyPropertySchema(prop);
            }
            else {
                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
                applyPropertySchema(prop);
                if (!it.allErrors)
                    gen.else().var(valid, true);
                gen.endIf();
            }
            cxt.it.definedProperties.add(prop);
            cxt.ok(valid);
        }
        function hasDefault(prop) {
            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
        }
        function applyPropertySchema(prop) {
            cxt.subschema({
                keyword: "properties",
                schemaProp: prop,
                dataProp: prop,
            }, valid);
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=properties.js.map

/***/ }),

/***/ 60394:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
};
const def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
            return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
            cxt.setParams({ propertyName: key });
            cxt.subschema({
                keyword: "propertyNames",
                data: key,
                dataTypes: ["string"],
                propertyName: key,
                compositeRule: true,
            }, valid);
            gen.if((0, codegen_1.not)(valid), () => {
                cxt.error(true);
                if (!it.allErrors)
                    gen.break();
            });
        });
        cxt.ok(valid);
    },
};
exports["default"] = def;
//# sourceMappingURL=propertyNames.js.map

/***/ }),

/***/ 99187:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(19439);
const def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it }) {
        if (parentSchema.if === undefined)
            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
    },
};
exports["default"] = def;
//# sourceMappingURL=thenElse.js.map

/***/ }),

/***/ 20574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const names_1 = __webpack_require__(82654);
const util_2 = __webpack_require__(19439);
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
        cxt.error();
    });
}
exports.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
}
exports.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
}
exports.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
    });
}
exports.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
}
exports.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
exports.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
}
exports.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
exports.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
}
exports.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
}
exports.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1._) `new RegExp`;
function usePattern({ gen, it: { opts } }, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
    });
}
exports.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it } = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: util_1.Type.Num,
            }, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
        });
    }
}
exports.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it } = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        }, schValid);
        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
exports.validateUnion = validateUnion;
//# sourceMappingURL=code.js.map

/***/ }),

/***/ 54148:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const def = {
    keyword: "id",
    code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    },
};
exports["default"] = def;
//# sourceMappingURL=id.js.map

/***/ }),

/***/ 17134:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const id_1 = __webpack_require__(54148);
const ref_1 = __webpack_require__(15798);
const core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default,
];
exports["default"] = core;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 15798:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callRef = exports.getValidate = void 0;
const ref_error_1 = __webpack_require__(84514);
const code_1 = __webpack_require__(20574);
const codegen_1 = __webpack_require__(20271);
const names_1 = __webpack_require__(82654);
const compile_1 = __webpack_require__(24685);
const util_1 = __webpack_require__(19439);
const def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
            return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === undefined)
            throw new ref_error_1.default(baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
            return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
            if (env === root)
                return callRef(cxt, validateName, env, env.$async);
            const rootName = gen.scopeValue("root", { ref: root });
            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
            const v = getValidate(cxt, sch);
            callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
            const valid = gen.name("valid");
            const schCxt = cxt.subschema({
                schema: sch,
                dataTypes: [],
                schemaPath: codegen_1.nil,
                topSchemaRef: schName,
                errSchemaPath: $ref,
            }, valid);
            cxt.mergeEvaluated(schCxt);
            cxt.ok(valid);
        }
    },
};
function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate
        ? gen.scopeValue("validate", { ref: sch.validate })
        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
exports.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
    const { gen, it } = cxt;
    const { allErrors, schemaEnv: env, opts } = it;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
        callAsyncRef();
    else
        callSyncRef();
    function callAsyncRef() {
        if (!env.$async)
            throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
            if (!allErrors)
                gen.assign(valid, true);
        }, (e) => {
            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
            addErrorsFrom(e);
            if (!allErrors)
                gen.assign(valid, false);
        });
        cxt.ok(valid);
    }
    function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
    }
    function addErrorsFrom(source) {
        const errs = (0, codegen_1._) `${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
            return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        // TODO refactor
        if (it.props !== true) {
            if (schEvaluated && !schEvaluated.dynamicProps) {
                if (schEvaluated.props !== undefined) {
                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
                }
            }
            else {
                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
            }
        }
        if (it.items !== true) {
            if (schEvaluated && !schEvaluated.dynamicItems) {
                if (schEvaluated.items !== undefined) {
                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
                }
            }
            else {
                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
            }
        }
    }
}
exports.callRef = callRef;
exports["default"] = def;
//# sourceMappingURL=ref.js.map

/***/ }),

/***/ 89478:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const types_1 = __webpack_require__(7539);
const error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName}" must be string`
        : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
};
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            }
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
            gen.endIf();
        }
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        }
        function getMapping() {
            var _a;
            const oneOfMapping = {};
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                const sch = oneOf[i];
                const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
                }
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            }
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName}" must be required`);
            return oneOfMapping;
            function hasRequired({ required }) {
                return Array.isArray(required) && required.includes(tagName);
            }
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                }
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    }
                }
                else {
                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
                }
            }
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
                }
                oneOfMapping[tagValue] = i;
            }
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7539:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiscrError = void 0;
var DiscrError;
(function (DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 34151:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const core_1 = __webpack_require__(17134);
const validation_1 = __webpack_require__(39514);
const applicator_1 = __webpack_require__(81306);
const format_1 = __webpack_require__(37822);
const metadata_1 = __webpack_require__(24593);
const draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
];
exports["default"] = draft7Vocabularies;
//# sourceMappingURL=draft7.js.map

/***/ }),

/***/ 11747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
};
const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1.nil;
                return (0, codegen_1._) `${schemaCode} && !${format}`;
            }
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
                    : (0, codegen_1._) `${format}(${data})`;
                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
            }
        }
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            }
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                }
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
                }
            }
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
                }
                return ["string", fmtDef, fmt];
            }
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
                }
                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
            }
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ 37822:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const format_1 = __webpack_require__(11747);
const format = [format_1.default];
exports["default"] = format;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 24593:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.contentVocabulary = exports.metadataVocabulary = void 0;
exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples",
];
exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema",
];
//# sourceMappingURL=metadata.js.map

/***/ }),

/***/ 21157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const equal_1 = __webpack_require__(28794);
const error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
};
const def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || (schema && typeof schema == "object")) {
            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        }
        else {
            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=const.js.map

/***/ }),

/***/ 4163:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const equal_1 = __webpack_require__(28794);
const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
};
const def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
            throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
            valid = gen.let("valid");
            cxt.block$data(valid, loopEnum);
        }
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            const vSchema = gen.const("vSchema", schemaCode);
            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
            gen.assign(valid, false);
            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
            const sch = schema[i];
            return typeof sch === "object" && sch !== null
                ? (0, codegen_1._) `${eql}(${data}, ${vSchema}[${i}])`
                : (0, codegen_1._) `${data} === ${sch}`;
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=enum.js.map

/***/ }),

/***/ 39514:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const limitNumber_1 = __webpack_require__(38143);
const multipleOf_1 = __webpack_require__(82946);
const limitLength_1 = __webpack_require__(59583);
const pattern_1 = __webpack_require__(46345);
const limitProperties_1 = __webpack_require__(3143);
const required_1 = __webpack_require__(16007);
const limitItems_1 = __webpack_require__(70957);
const uniqueItems_1 = __webpack_require__(77658);
const const_1 = __webpack_require__(21157);
const enum_1 = __webpack_require__(4163);
const validation = [
    // number
    limitNumber_1.default,
    multipleOf_1.default,
    // string
    limitLength_1.default,
    pattern_1.default,
    // object
    limitProperties_1.default,
    required_1.default,
    // array
    limitItems_1.default,
    uniqueItems_1.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default,
];
exports["default"] = validation;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 70957:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
    },
};
exports["default"] = def;
//# sourceMappingURL=limitItems.js.map

/***/ }),

/***/ 59583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const ucs2length_1 = __webpack_require__(26145);
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
    },
};
exports["default"] = def;
//# sourceMappingURL=limitLength.js.map

/***/ }),

/***/ 38143:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const ops = codegen_1.operators;
const KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
const def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    },
};
exports["default"] = def;
//# sourceMappingURL=limitNumber.js.map

/***/ }),

/***/ 3143:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const error = {
    message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
};
const def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
    },
};
exports["default"] = def;
//# sourceMappingURL=limitProperties.js.map

/***/ }),

/***/ 82946:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const codegen_1 = __webpack_require__(20271);
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
};
const def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec
            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
            : (0, codegen_1._) `${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    },
};
exports["default"] = def;
//# sourceMappingURL=multipleOf.js.map

/***/ }),

/***/ 46345:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__(20574);
const codegen_1 = __webpack_require__(20271);
const error = {
    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
};
const def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        // TODO regexp should be wrapped in try/catchs
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
    },
};
exports["default"] = def;
//# sourceMappingURL=pattern.js.map

/***/ }),

/***/ 16007:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const code_1 = __webpack_require__(20574);
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
};
const def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
            return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
            allErrorsMode();
        else
            exitOnErrorMode();
        if (opts.strictRequired) {
            const props = cxt.parentSchema.properties;
            const { definedProperties } = cxt.it;
            for (const requiredKey of schema) {
                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
                }
            }
        }
        function allErrorsMode() {
            if (useLoop || $data) {
                cxt.block$data(codegen_1.nil, loopAllRequired);
            }
            else {
                for (const prop of schema) {
                    (0, code_1.checkReportMissingProp)(cxt, prop);
                }
            }
        }
        function exitOnErrorMode() {
            const missing = gen.let("missing");
            if (useLoop || $data) {
                const valid = gen.let("valid", true);
                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
                cxt.ok(valid);
            }
            else {
                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
                (0, code_1.reportMissingProp)(cxt, missing);
                gen.else();
            }
        }
        function loopAllRequired() {
            gen.forOf("prop", schemaCode, (prop) => {
                cxt.setParams({ missingProperty: prop });
                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
            });
        }
        function loopUntilMissing(missing, valid) {
            cxt.setParams({ missingProperty: missing });
            gen.forOf(missing, schemaCode, () => {
                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
                gen.if((0, codegen_1.not)(valid), () => {
                    cxt.error();
                    gen.break();
                });
            }, codegen_1.nil);
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=required.js.map

/***/ }),

/***/ 77658:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const dataType_1 = __webpack_require__(19259);
const codegen_1 = __webpack_require__(20271);
const util_1 = __webpack_require__(19439);
const equal_1 = __webpack_require__(28794);
const error = {
    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
};
const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j });
            gen.assign(valid, true);
            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._) `{}`);
            gen.for((0, codegen_1._) `;${i}--;`, () => {
                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
                gen.if(wrongType, (0, codegen_1._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
                gen
                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                })
                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
            });
        }
        function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            })));
        }
    },
};
exports["default"] = def;
//# sourceMappingURL=uniqueItems.js.map

/***/ }),

/***/ 50716:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(76584);

var isNativeReflectConstruct = __webpack_require__(43550);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 83856:
/***/ (function(module) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 38351:
/***/ (function(module) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 83135:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(76584);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 89798:
/***/ (function(module) {

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 43550:
/***/ (function(module) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 76584:
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 53084:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(38351);

var setPrototypeOf = __webpack_require__(76584);

var isNativeFunction = __webpack_require__(89798);

var construct = __webpack_require__(50716);

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 3080:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(25047);


/***/ }),

/***/ 89622:
/***/ (function(module) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ 46637:
/***/ (function(module) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ 83969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var rng = __webpack_require__(46637);
var bytesToUuid = __webpack_require__(89622);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ 86566:
/***/ (function(module) {

"use strict";


module.exports = function () {
  return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

/***/ }),

/***/ 36373:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getConfigValuesMetadata = exports.Value = void 0;

var schema_1 = __webpack_require__(96804);

var core_1 = __webpack_require__(16134);

var config_service_1 = __webpack_require__(11175);

var REFLECT_KEY_CONFIG = "__joy_config_item";
var cacheHashId = 1;
var JoyConfigProp = Symbol("__joy_config_service");
/**
 * 声明一个配置项，当实例在初始化时，绑定joyConfig中的值到当前provider中
 * @param options
 * @constructor
 */

function Value(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, propKey) {
    if (typeof propKey === "symbol") {
      throw new Error(target + ", @ConfigValue() decorate property(" + propKey.toString() + ") should only to be string'");
    }

    (0, schema_1.Property)()(target, propKey);
    var classSchema = (0, schema_1.getJsonSchema)(target.constructor, {
      _cacheHash: cacheHashId++
    }); // _cacheHash is used for prevent from cache.

    var curConfigSchema = plainJsonSchema(classSchema.definitions, classSchema.properties[propKey]);
    var configKey = (options === null || options === void 0 ? void 0 : options.configKey) || propKey;
    var existConfigs;
    var ownConfigs = getConfigValuesMetadata(target, true);

    if (ownConfigs === undefined) {
      var superConfigs = getConfigValuesMetadata(target);
      existConfigs = superConfigs ? [].concat(superConfigs) : [];
    } else {
      existConfigs = ownConfigs;
    }

    var configValueMeta = Object.assign({
      propKey: propKey,
      configKey: configKey,
      onChange: "reload",
      // 如果是空的object，则在赋值的时候不校验。
      schema: (curConfigSchema === null || curConfigSchema === void 0 ? void 0 : curConfigSchema.type) === "object" && !curConfigSchema.properties ? undefined : curConfigSchema,
      "default": undefined
    }, options);
    var existOneIndex = existConfigs.findIndex(function (it) {
      return it.propKey === propKey;
    });

    if (existOneIndex >= 0) {
      existConfigs[existOneIndex] = configValueMeta;
    } else {
      existConfigs.push(configValueMeta);
    } // 声明一个隐藏的私有依赖属性，确保在ConfigService实例化后，才实例化被装饰的类。


    (0, core_1.Inject)(config_service_1.ConfigService)(target, JoyConfigProp);
    Reflect.defineMetadata(REFLECT_KEY_CONFIG, existConfigs, target);
  };
}

exports.Value = Value;
/**
 *
 * @param definitions jsonSchema中的definitions字段
 * @param ref  reg: #/definitions/RouterConfig
 */

function getDefinition(definitions, ref) {
  var refPaths = ref.split("/").slice(2);
  var curObj = definitions;
  refPaths.forEach(function (path) {
    curObj = curObj[path];
  });
  return plainJsonSchema(definitions, curObj);
}

function plainJsonSchema(definitions, schema) {
  var _a;

  if (schema.$ref) {
    return getDefinition(definitions, schema.$ref);
  } else if (schema.type === "array") {
    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.$ref) {
      schema.items = getDefinition(definitions, schema.items.$ref);
    } else if (Array.isArray(schema.items)) {
      for (var i = 0; i < schema.items; i++) {
        schema.items[i] = (0, schema_1.getJsonSchema)(definitions, schema.items[i]);
      }
    }
  } else if (schema.type === "object" && schema.properties) {
    for (var _i = 0, _Object$keys = Object.keys(schema.properties); _i < _Object$keys.length; _i++) {
      var prop = _Object$keys[_i];

      if (!schema.properties.hasOwnProperty(prop)) {
        continue;
      }

      schema.properties[prop] = plainJsonSchema(definitions, schema.properties[prop]);
    }
  }

  return schema;
}

function getConfigValuesMetadata(targetType, isOwn) {
  if (isOwn === void 0) {
    isOwn = false;
  }

  if (isOwn) {
    return Reflect.getOwnMetadata(REFLECT_KEY_CONFIG, typeof targetType === "function" ? targetType.prototype : targetType);
  }

  return Reflect.getMetadata(REFLECT_KEY_CONFIG, typeof targetType === "function" ? targetType.prototype : targetType);
}

exports.getConfigValuesMetadata = getConfigValuesMetadata;

/***/ }),

/***/ 60662:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigConfiguration = void 0;

var core_1 = __webpack_require__(16134);

var config_service_1 = __webpack_require__(11175);

var constants_1 = __webpack_require__(45527);

var config_loader_factory_1 = __webpack_require__(47095);

var ConfigConfiguration = /*#__PURE__*/function () {
  function ConfigConfiguration(context) {
    this.context = context;
  }

  var _proto = ConfigConfiguration.prototype;

  _proto.isAutoLoadConfig = function isAutoLoadConfig() {
    return true;
  };

  _proto.getConfigLoaderFactory = function getConfigLoaderFactory() {
    return new config_loader_factory_1.ConfigLoaderFactory();
  };

  _proto.getDefaultConfig = function getDefaultConfig() {
    return {};
  };

  _proto.getConfigServiceOptions = function getConfigServiceOptions() {
    return {
      isAutoLoadConfig: this.isAutoLoadConfig()
    };
  };

  return ConfigConfiguration;
}();

__decorate([core_1.Configuration.Component(), __metadata("design:type", config_service_1.ConfigService)], ConfigConfiguration.prototype, "configService", void 0);

__decorate([core_1.Configuration.Component(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", config_loader_factory_1.ConfigLoaderFactory)], ConfigConfiguration.prototype, "getConfigLoaderFactory", null);

__decorate([core_1.Configuration.Component({
  name: constants_1.CONFIG_DEFAULT_VALUE
}), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", Object)], ConfigConfiguration.prototype, "getDefaultConfig", null);

__decorate([core_1.Configuration.Component({
  name: constants_1.CONFIG_OPTIONS
}), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", Object)], ConfigConfiguration.prototype, "getConfigServiceOptions", null);

ConfigConfiguration = __decorate([(0, core_1.Configuration)(), __metadata("design:paramtypes", [core_1.ApplicationContext])], ConfigConfiguration);
exports.ConfigConfiguration = ConfigConfiguration;

/***/ }),

/***/ 83265:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VALIDATED_ENV_PROPNAME = exports.PARTIAL_CONFIGURATION_PROPNAME = exports.PARTIAL_CONFIGURATION_KEY = exports.VALIDATED_ENV_LOADER = exports.CONFIGURATION_LOADER = exports.CONFIGURATION_TOKEN = exports.CONFIGURATION_SERVICE_TOKEN = void 0;
/**
 * Injection tokens
 */

exports.CONFIGURATION_SERVICE_TOKEN = Symbol("CONFIG_SERVICE");
exports.CONFIGURATION_TOKEN = "CONFIGURATION_TOKEN";
exports.CONFIGURATION_LOADER = "CONFIGURATION_LOADER";
exports.VALIDATED_ENV_LOADER = "VALIDATED_ENV_LOADER";
exports.PARTIAL_CONFIGURATION_KEY = "PARTIAL_CONFIGURATION_KEY";
exports.PARTIAL_CONFIGURATION_PROPNAME = "KEY";
exports.VALIDATED_ENV_PROPNAME = "_PROCESS_ENV_VALIDATED";

/***/ }),

/***/ 11175:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(34406);


var _regeneratorRuntime = __webpack_require__(77162);

var _createClass = __webpack_require__(15198);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __param = this && this.__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var _a, _b;

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigService = void 0;

var core_1 = __webpack_require__(16134);

var constants_1 = __webpack_require__(45527);

var config_constants_1 = __webpack_require__(83265);

var lodash_get_1 = __importDefault(__webpack_require__(77485));

var lodash_has_1 = __importDefault(__webpack_require__(63211));

var lodash_set_1 = __importDefault(__webpack_require__(880));

var lodash_merge_1 = __importDefault(__webpack_require__(51344));

var config_loader_factory_1 = __webpack_require__(47095);

var config_value_decorator_1 = __webpack_require__(36373);

var schema_1 = __webpack_require__(96804);

var ajv_1 = __importDefault(__webpack_require__(51574));

var ConfigService = /*#__PURE__*/function () {
  function ConfigService(configOptions, defaultConfig, initConfig) {
    if (configOptions === void 0) {
      configOptions = {
        isAutoLoadConfig: true
      };
    }

    if (defaultConfig === void 0) {
      defaultConfig = {};
    }

    if (initConfig === void 0) {
      initConfig = {};
    }

    this.configOptions = configOptions;
    this.defaultConfig = defaultConfig;
    this.initConfig = initConfig;
    this._isCacheEnabled = false;
    this.cache = {};
  }

  var _proto = ConfigService.prototype;

  _proto.componentAfterPropertiesSet = function componentAfterPropertiesSet(instance, args) {
    // custom implement setConfigValue
    var onSetConfigValue = instance.onSetConfigValue;

    if (onSetConfigValue && typeof onSetConfigValue === "function") {
      onSetConfigValue.call(instance, this.internalConfig);
      return instance;
    }

    var configMetas = (0, config_value_decorator_1.getConfigValuesMetadata)(instance);

    if (configMetas && configMetas.length > 0) {
      this.setConfigValueByMeta(instance, configMetas);
    }

    return instance;
  };

  _proto.setConfigValueByMeta = function setConfigValueByMeta(instance, configValues) {
    if (!configValues || !configValues.length) {
      return;
    }

    var internalConfig = this.internalConfig; // const propKeys: string[] = new Array(configMetas.length);

    var configKeys = new Array(configValues.length);
    var configJsonSchema = new schema_1.JsonSchema();
    var configData = {};

    for (var i = 0; i < configValues.length; i++) {
      var _configValues$i = configValues[i],
          configKey = _configValues$i.configKey,
          propKey = _configValues$i.propKey,
          schema = _configValues$i.schema,
          transform = _configValues$i.transform,
          defaultValue = _configValues$i["default"]; // propKeys[i] = propKey;

      configKeys[i] = configKey;

      if (schema) {
        configJsonSchema.addProperty(configKey, new schema_1.JsonSchema(schema));
      } // const originValue = internalConfig[configKey];


      var originValue = this.get(configKey);

      if (transform && originValue !== undefined) {
        configData[configKey] = transform(originValue);
      } else {
        configData[configKey] = originValue;
      }

      if (configData[configKey] === undefined) {
        if (defaultValue !== undefined) {
          configData[configKey] = defaultValue;
        } else if ((schema === null || schema === void 0 ? void 0 : schema["default"]) !== undefined) {
          configData[configKey] = schema === null || schema === void 0 ? void 0 : schema["default"];
        }
      }
    }

    var ajv = new ajv_1["default"]({
      useDefaults: true,
      strict: false
    });
    var objConfigJsonSchema = configJsonSchema.toObject();
    var isValid = ajv.validate(objConfigJsonSchema, configData);

    if (!isValid) {
      var errMsg = ajv.errorsText(ajv.errors);
      throw new Error(errMsg);
    } // Ajv的默认实现，并不将数组的Default值赋值给属性


    var injectArrDefault = function injectArrDefault(schema, data) {
      var _a, _b;

      if (!schema.properties || !data) {
        return;
      }

      for (var _i = 0, _Object$keys = Object.keys(schema.properties); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];
        var propScheme = schema.properties[prop];

        if (propScheme.type === "object") {
          injectArrDefault(propScheme, data[prop]);
        } else if (propScheme.type === "array") {
          if (data[prop] === undefined && ((_a = propScheme.items) === null || _a === void 0 ? void 0 : _a["default"]) !== undefined) {
            data[prop] = (_b = propScheme.items) === null || _b === void 0 ? void 0 : _b["default"];
          }
        }
      }
    };

    injectArrDefault(objConfigJsonSchema, configData);

    for (var _i2 = 0; _i2 < configValues.length; _i2++) {
      var configMeta = configValues[_i2];
      var value = configData[configMeta.configKey];
      var presetValue = instance[configMeta.propKey];

      if (typeof value !== "undefined") {
        instance[configMeta.propKey] = value;
      }
    } // function onConfigChanged(configInstance: any): any {
    //   // @ts-ignore
    //   const instance = this as any;
    //   // 执行用户自定义的赋值行为
    //   if (instance.onConfigChanged) {
    //     instance.onConfigChanged(configInstance, configKeys);
    //     return;
    //   }
    //   instance[PROP_KEY_JOY_CONFIG_SET_VALUE](configInstance);
    // }
    // // 注册config的值变化
    // const onConfigChangedPropKey = Symbol(`__joy_config_changed`);
    // instance.prototype[onConfigChangedPropKey] = onConfigChanged;
    // RegisterTap({ hookId: "onJoyConfigChanged" })(instance, onConfigChangedPropKey);

  };

  _proto.initialize = function initialize() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.internalConfig = (0, lodash_merge_1["default"])({}, this.defaultConfig, this.initConfig);

              if (!this.configOptions.isAutoLoadConfig) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return this.loadConfig();

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  };

  _proto.loadConfig = function loadConfig() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var configLoaders, loadedValues, _iterator, _step, configLoader, configValues;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.configLoaderFactory) {
                _context2.next = 3;
                break;
              }

              console.warn("There is no config loader factory.");
              return _context2.abrupt("return");

            case 3:
              configLoaders = this.configLoaderFactory.getLoaders(this.internalConfig);

              if (!(!configLoaders || configLoaders.length === 0)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return");

            case 6:
              loadedValues = {};
              _iterator = _createForOfIteratorHelperLoose(configLoaders);

            case 8:
              if ((_step = _iterator()).done) {
                _context2.next = 16;
                break;
              }

              configLoader = _step.value;
              _context2.next = 12;
              return configLoader.loadConfig();

            case 12:
              configValues = _context2.sent;

              if (configValues) {
                (0, lodash_merge_1["default"])(loadedValues, configValues);
              }

            case 14:
              _context2.next = 8;
              break;

            case 16:
              Object.keys(loadedValues).length > 0 && this.mergeConfig(loadedValues);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
  }
  /**
   * Get a configuration value (either custom configuration or process environment variable)
   * based on property path (you can use dot notation to traverse nested object, e.g. "database.host").
   * It returns a default value if the key does not exist.
   * @param configPath
   * @param defaultValue
   */
  ;

  _proto.get = function get(configPath, defaultValue) {
    if (typeof configPath === "undefined") {
      return this.internalConfig;
    }

    var validatedEnvValue = this.getFromValidatedEnv(configPath);

    if (validatedEnvValue !== undefined) {
      return validatedEnvValue;
    }

    var processEnvValue = this.getFromProcessEnv(configPath, defaultValue);

    if (processEnvValue !== undefined) {
      return processEnvValue;
    }

    var internalValue = this.getFromInternalConfig(configPath);

    if (internalValue !== undefined) {
      return internalValue;
    }

    return defaultValue;
  };

  _proto.getConfigSchema = function getConfigSchema() {
    return this.addJoyConfigSchema.call({});
  };

  _proto.mergeConfig = function mergeConfig(customConfig, deepMerge) {
    if (deepMerge === void 0) {
      deepMerge = true;
    }

    var configs = this.internalConfig;

    if (deepMerge) {
      (0, lodash_merge_1["default"])(configs, customConfig);
    } else {
      Object.keys(customConfig).forEach(function (key) {
        configs[key] = customConfig[key];
      });
    }
  };

  _proto.normalizeConfig = function normalizeConfig( // phase: string,
  config) {
    if (typeof config === "function") {
      // config = config(phase, {defaultConfig: this});
      config = config({
        defaultConfig: this
      });

      if (typeof config.then === "function") {
        throw new Error("> Promise returned in joy config. #promise-in-next-config");
      }
    }

    return config;
  };

  _proto.getFromCache = function getFromCache(propertyPath, defaultValue) {
    var cachedValue = (0, lodash_get_1["default"])(this.cache, propertyPath);
    return cachedValue === undefined ? defaultValue : cachedValue;
  };

  _proto.getFromValidatedEnv = function getFromValidatedEnv(propertyPath) {
    var validatedEnvValue = (0, lodash_get_1["default"])(this.internalConfig[config_constants_1.VALIDATED_ENV_PROPNAME], propertyPath);
    return validatedEnvValue;
  };

  _proto.getFromProcessEnv = function getFromProcessEnv(propertyPath, defaultValue) {
    if (this.isCacheEnabled && (0, lodash_has_1["default"])(this.cache, propertyPath)) {
      var cachedValue = this.getFromCache(propertyPath, defaultValue);
      return cachedValue !== undefined ? cachedValue : defaultValue;
    }

    var processValue = (0, lodash_get_1["default"])(process.env, propertyPath);
    this.setInCacheIfDefined(propertyPath, processValue);
    return processValue;
  };

  _proto.getFromInternalConfig = function getFromInternalConfig(propertyPath) {
    var internalValue = (0, lodash_get_1["default"])(this.internalConfig, propertyPath);
    return internalValue;
  };

  _proto.setInCacheIfDefined = function setInCacheIfDefined(propertyPath, value) {
    if (typeof value === "undefined") {
      return;
    }

    (0, lodash_set_1["default"])(this.cache, propertyPath, value);
  };

  _createClass(ConfigService, [{
    key: "isCacheEnabled",
    get: function get() {
      return this._isCacheEnabled;
    },
    set: function set(value) {
      this._isCacheEnabled = value;
    }
  }]);

  return ConfigService;
}();

__decorate([(0, core_1.Optional)(), (0, core_1.Inject)(), __metadata("design:type", config_loader_factory_1.ConfigLoaderFactory)], ConfigService.prototype, "configLoaderFactory", void 0);

__decorate([(0, core_1.InjectHook)({
  id: "addJoyConfigSchema",
  type: core_1.HookType.Waterfall,
  parallel: false,
  async: true
}), __metadata("design:type", Object)], ConfigService.prototype, "addJoyConfigSchema", void 0);

__decorate([(0, core_1.InjectHook)({
  id: "onJoyConfigChanged",
  type: core_1.HookType.Waterfall,
  parallel: false,
  async: true
}), __metadata("design:type", Object)], ConfigService.prototype, "onJoyConfigChanged", void 0);

__decorate([(0, core_1.RegisterTap)(), __metadata("design:type", Function), __metadata("design:paramtypes", [typeof (_a = typeof T !== "undefined" && T) === "function" ? _a : Object, Object]), __metadata("design:returntype", typeof (_b = typeof T !== "undefined" && T) === "function" ? _b : Object)], ConfigService.prototype, "componentAfterPropertiesSet", null);

ConfigService = __decorate([(0, core_1.Component)(), __param(0, (0, core_1.Optional)()), __param(0, (0, core_1.Inject)(constants_1.CONFIG_OPTIONS)), __param(1, (0, core_1.Optional)()), __param(1, (0, core_1.Inject)(constants_1.CONFIG_DEFAULT_VALUE)), __param(2, (0, core_1.Optional)()), __param(2, (0, core_1.Inject)(constants_1.CONFIG_INIT_VALUE)), __metadata("design:paramtypes", [Object, Object, Object])], ConfigService);
exports.ConfigService = ConfigService;

/***/ }),

/***/ 45527:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CONFIG_OPTIONS = exports.CONFIG_INIT_VALUE = exports.CONFIG_DEFAULT_VALUE = void 0;
exports.CONFIG_DEFAULT_VALUE = "__SYMPH_CONFIG_DEFAULT_VALUE";
exports.CONFIG_INIT_VALUE = "__SYMPH_CONFIG_INIT_VALUE";
exports.CONFIG_OPTIONS = "__SYMPH_CONFIG_OPTIONS";

/***/ }),

/***/ 24968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(45527), exports);

__exportStar(__webpack_require__(36373), exports);

__exportStar(__webpack_require__(11175), exports);

__exportStar(__webpack_require__(60662), exports);

__exportStar(__webpack_require__(47095), exports);

__exportStar(__webpack_require__(38155), exports);

/***/ }),

/***/ 47095:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConfigLoaderFactory = void 0;

var core_1 = __webpack_require__(16134);

var ConfigLoaderFactory = /*#__PURE__*/function () {
  function ConfigLoaderFactory() {}

  var _proto = ConfigLoaderFactory.prototype;

  _proto.getLoaders = function getLoaders(configs) {
    return [];
  };

  return ConfigLoaderFactory;
}();

ConfigLoaderFactory = __decorate([(0, core_1.Component)()], ConfigLoaderFactory);
exports.ConfigLoaderFactory = ConfigLoaderFactory;

/***/ }),

/***/ 38155:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 12138:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(3080);

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ApplicationContextFactory = exports.CoreFactoryImplement = void 0;

var logger_service_1 = __webpack_require__(23906);

var shared_utils_1 = __webpack_require__(1980);

var constants_1 = __webpack_require__(29650);

var application_context_1 = __webpack_require__(65602);

var CoreFactoryImplement = /*#__PURE__*/function () {
  function CoreFactoryImplement() {
    this.logger = new logger_service_1.Logger("JoyFactory", true);
  }

  var _proto = CoreFactoryImplement.prototype;

  _proto.createApplicationContext = function createApplicationContext(entry, parent, options) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var applicationContext;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.applyLogger(options);
              applicationContext = new application_context_1.ApplicationContext(entry, parent);
              return _context.abrupt("return", this.initContext(applicationContext));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  };

  _proto.initContext = function initContext(context) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this.logger.log(constants_1.MESSAGES.APPLICATION_START);
              _context2.prev = 1;
              _context2.next = 4;
              return context.init();

            case 4:
              _context2.next = 10;
              break;

            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](1);
              this.logger.error("Init context error:", _context2.t0.message); // process.abort();

              throw _context2.t0;

            case 10:
              return _context2.abrupt("return", context);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[1, 6]]);
    }));
  };

  _proto.applyLogger = function applyLogger(options) {
    if (!options) {
      return;
    }

    !(0, shared_utils_1.isNil)(options.logger) && logger_service_1.Logger.overrideLogger(options.logger);
  };

  return CoreFactoryImplement;
}();

exports.CoreFactoryImplement = CoreFactoryImplement;
exports.ApplicationContextFactory = new CoreFactoryImplement();

/***/ }),

/***/ 65602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(3080);

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ApplicationContext = void 0;

var interfaces_1 = __webpack_require__(97116);

var logger_service_1 = __webpack_require__(23906);

var shared_utils_1 = __webpack_require__(1980);

var unknown_element_exception_1 = __webpack_require__(61266);

var application_container_1 = __webpack_require__(97596);

var injector_1 = __webpack_require__(69969);

var constants_1 = __webpack_require__(30759);

var instance_loader_1 = __webpack_require__(67163);

var runtime_exception_1 = __webpack_require__(53816);

var component_scanner_1 = __webpack_require__(94903);

var component_name_generate_1 = __webpack_require__(62000);

var hook_center_1 = __webpack_require__(30107);

var hook_resolver_1 = __webpack_require__(89598);

var core_1 = __webpack_require__(14200);

var hook_1 = __webpack_require__(22806);
/**
 * @publicApi
 */


var ApplicationContext = /*#__PURE__*/function () {
  function ApplicationContext(entry, // public readonly container: ApplicationContainer = new ApplicationContainer(),
  parent) {
    this.entry = entry;
    this.parent = parent;
    this.isInitialized = false;
    this.hookCenter = new hook_center_1.HookCenter();
    this.container = this.instanceContainer();
    this.hookCenter.registerProviderHooks(this.container);
    this.injector = this.instanceInjector();
    this.hookCenter.registerProviderHooks(this.injector);
    this.dependenciesScanner = new component_scanner_1.ComponentScanner();
    this.instanceLoader = new instance_loader_1.InstanceLoader(this.container, this.injector);
    this.hookResolver = new hook_resolver_1.HookResolver(this.hookCenter); // this.registerHooks();

    this.registerCoreProviders();
  }

  var _proto = ApplicationContext.prototype;

  _proto.hasInitialized = function hasInitialized() {
    return this.isInitialized;
  };

  _proto.instanceContainer = function instanceContainer() {
    return new application_container_1.ApplicationContainer();
  };

  _proto.instanceInjector = function instanceInjector() {
    var _a;

    return new injector_1.Injector(this.container, (_a = this.parent) === null || _a === void 0 ? void 0 : _a.injector);
  } // private registerHooks() {
  //   this.hookCenter.registerProviderHooks(this.container);
  //
  //   // this.onDidProvidersRegister = this.hookCenter.registerHook({
  //   //   id: "onDidProvidersRegister",
  //   //   type: HookType.Traverse,
  //   //   async: true,
  //   //   parallel: false,
  //   // });
  //   //
  //   // this.onContextInitialized = this.hookCenter.registerHook({
  //   //   id: "onContextInitialized",
  //   //   type: HookType.Traverse,
  //   //   async: true,
  //   //   parallel: false,
  //   // });
  //   // this.onContextBeforeDispose = this.hookCenter.registerHook({
  //   //   id: "onContextBeforeDispose",
  //   //   type: HookType.Traverse,
  //   //   async: true,
  //   //   parallel: false,
  //   // });
  //   // this.onBeforeShutdownHook = this.hookCenter.registerHook({
  //   //   id: "onBeforeShutdownHook",
  //   //   type: HookType.Traverse,
  //   //   async: true,
  //   //   parallel: false,
  //   // });
  //   // this.onShutdownHook = this.hookCenter.registerHook({
  //   //   id: "onShutdownHook",
  //   //   type: HookType.Traverse,
  //   //   async: true,
  //   //   parallel: false,
  //   // });
  // }
  ;

  _proto.registerCoreProviders = function registerCoreProviders() {
    this.container.addProviders([{
      name: Symbol("coreContext"),
      type: this.constructor,
      useValue: this
    }, {
      name: Symbol("componentScanner"),
      type: component_scanner_1.ComponentScanner,
      useValue: this.dependenciesScanner
    }, {
      name: Symbol("hookCenter"),
      type: hook_center_1.HookCenter,
      useValue: this.hookCenter
    }]);
  };

  _proto.getProviderDefinition = function getProviderDefinition(typeOrName, packageName) {
    var instanceWrapper = this.container.getProvider(typeOrName, packageName);
    return instanceWrapper;
  };

  _proto.getOptional = function getOptional(typeOrName, options) {
    var injectBy, name, type;

    if (typeof typeOrName === "function") {
      injectBy = interfaces_1.EnuInjectBy.TYPE;
      type = typeOrName;
    } else {
      injectBy = interfaces_1.EnuInjectBy.NAME;
      name = typeOrName;
    }

    var instanceWrapper = this.injector.getInstanceWrapper(injectBy, type, name);

    if ((0, shared_utils_1.isNil)(instanceWrapper)) {
      return undefined;
    }

    var provider = this.injector.loadProvider(instanceWrapper);
    return provider;
  };

  _proto.get = function get(typeOrName) {
    var instance = this.getOptional(typeOrName);

    if ((0, shared_utils_1.isNil)(instance)) {
      var providerId = this.getProviderId(typeOrName);
      throw new unknown_element_exception_1.UnknownElementException(providerId);
    }

    return instance;
  };

  _proto.getOptionalSync = function getOptionalSync(typeOrName) {
    var loadRst = this.getOptional(typeOrName);

    if (loadRst instanceof Promise) {
      throw new runtime_exception_1.RuntimeException("Its an async provider, can not load as sync");
    }

    return loadRst;
  };

  _proto.getSync = function getSync(typeOrName) {
    var loadRst = this.get(typeOrName);

    if (loadRst instanceof Promise) {
      throw new runtime_exception_1.RuntimeException("Its an async provider, can not load as sync");
    }

    return loadRst;
  }
  /**
   * inject properties for instance
   */
  ;

  _proto.resolveProperties = function resolveProperties(instance, typeOfInstance) {
    // const providerId: string = this.getProviderId(typeOfInstance);
    var providerId = this.getProviderId(instance.constructor);
    var instanceWrapper = this.container.getProvider(instance.constructor);

    if ((0, shared_utils_1.isNil)(instanceWrapper)) {
      // 生成一个临时的wrapper，用于缓存注入信息
      var provider = {
        name: Symbol(providerId),
        type: typeOfInstance,
        useClass: typeOfInstance,
        scope: interfaces_1.Scope.SINGLETON
      };
      instanceWrapper = this.container.addProvider(provider);
    }

    var injectedProps = this.injector.loadInstanceProperties(instance, instanceWrapper, constants_1.STATIC_CONTEXT).getResult();
    return injectedProps;
  };

  _proto.initContext = function initContext() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  };

  _proto.registerModule = function registerModule(module) {
    var providers = this.dependenciesScanner.scan(module);
    var wrappers = this.container.addProviders(providers);
    return wrappers;
  };

  _proto.loadModule = function loadModule(module) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var providers;
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              providers = this.registerModule(module);
              _context2.next = 3;
              return this.initProviders(providers);

            case 3:
              _context2.next = 5;
              return this.onModuleAfterLoad.call(module, providers);

            case 5:
              return _context2.abrupt("return", providers);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
  }
  /**
   * Initalizes the application.
   * Calls the Joy lifecycle events.
   *
   * @returns {Promise<this>} The JoyApplicationContext instance as Promise
   */
  ;

  _proto.init = function init() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      var providers;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.isInitialized) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", this);

            case 2:
              _context3.next = 4;
              return this.initContext();

            case 4:
              if (!this.entry) {
                _context3.next = 8;
                break;
              }

              providers = this.registerModule(this.entry);
              _context3.next = 8;
              return this.initProviders(providers);

            case 8:
              this.isInitialized = true;
              _context3.next = 11;
              return this.onContextInitialized.call();

            case 11:
              return _context3.abrupt("return", this);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
  };

  _proto.initProviders = function initProviders(instanceWrappers) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.createInstancesOfDependencies(instanceWrappers);

            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));
  };

  _proto.createInstancesOfDependencies = function createInstancesOfDependencies(instanceWrappers) {
    return this.instanceLoader.createInstancesOfDependencies(instanceWrappers);
  };

  _proto.dispose = function dispose() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
  };

  _proto.close = function close() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
      return _regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.onContextBeforeDispose.call();

            case 2:
              _context6.next = 4;
              return this.onBeforeShutdownHook.call();

            case 4:
              _context6.next = 6;
              return this.dispose();

            case 6:
              _context6.next = 8;
              return this.onShutdownHook.call();

            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
  };

  _proto.useLogger = function useLogger(logger) {
    logger_service_1.Logger.overrideLogger(logger);
  };

  _proto.getProviderId = function getProviderId(typeOrToken) {
    if ((0, shared_utils_1.isFunction)(typeOrToken)) {
      var meta = (0, core_1.getComponentMeta)(typeOrToken);

      if (meta === null || meta === void 0 ? void 0 : meta.name) {
        return meta.name.toString();
      } else {
        return (0, component_name_generate_1.componentNameGenerate)(typeOrToken);
      }
    } else {
      return typeOrToken;
    }
  };

  return ApplicationContext;
}();

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: true
}), __metadata("design:type", Object)], ApplicationContext.prototype, "onModuleAfterLoad", void 0);

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: true
}), __metadata("design:type", Object)], ApplicationContext.prototype, "onContextInitialized", void 0);

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: true
}), __metadata("design:type", Object)], ApplicationContext.prototype, "onContextBeforeDispose", void 0);

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: true
}), __metadata("design:type", Object)], ApplicationContext.prototype, "onBeforeShutdownHook", void 0);

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: true
}), __metadata("design:type", Object)], ApplicationContext.prototype, "onShutdownHook", void 0);

exports.ApplicationContext = ApplicationContext;

/***/ }),

/***/ 29650:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.REDIRECT_METADATA = exports.HEADERS_METADATA = exports.MODULE_PATH = exports.HTTP_CODE_METADATA = exports.INTERCEPTORS_METADATA = exports.RENDER_METADATA = exports.GUARDS_METADATA = exports.PIPES_METADATA = exports.FILTER_CATCH_EXCEPTIONS = exports.EXCEPTION_FILTERS_METADATA = exports.CUSTOM_ROUTE_AGRS_METADATA = exports.ROUTE_ARGS_METADATA = exports.METHOD_METADATA = exports.SCOPE_OPTIONS_METADATA = exports.OPTIONAL_PROPERTY_DEPS_METADATA = exports.PROPERTY_DEPS_METADATA = exports.OPTIONAL_DEPS_METADATA = exports.SELF_DECLARED_DEPS_METADATA = exports.PARAMTYPES_METADATA = exports.PATH_METADATA = exports.GLOBAL_MODULE_METADATA = exports.SHARED_MODULE_METADATA = exports.CONFIGURATION_METADATA = exports.INJECTABLE_METADATA = exports.APP_FILTER = exports.APP_GUARD = exports.APP_PIPE = exports.APP_INTERCEPTOR = exports.MESSAGES = exports.NAMESPACE_SEP = exports.METADATA = void 0;
exports.METADATA = {
  INJECTABLE: "injectable",
  IMPORTS: "imports",
  PROVIDERS: "providers",
  CONTROLLERS: "controllers",
  EXPORTS: "exports"
}; // === core

exports.NAMESPACE_SEP = "/"; // === application

exports.MESSAGES = {
  APPLICATION_START: "Starting Joy application...",
  APPLICATION_READY: "Joy application successfully started",
  MICROSERVICE_READY: "Joy microservice successfully started",
  UNKNOWN_EXCEPTION_MESSAGE: "Internal server error",
  ERROR_DURING_SHUTDOWN: "Error happened during shutdown",
  CALL_LISTEN_FIRST: "app.listen() needs to be called before calling app.getUrl()"
};
exports.APP_INTERCEPTOR = "APP_INTERCEPTOR";
exports.APP_PIPE = "APP_PIPE";
exports.APP_GUARD = "APP_GUARD";
exports.APP_FILTER = "APP_FILTER"; //=== common

exports.INJECTABLE_METADATA = "__joy_injectable";
exports.CONFIGURATION_METADATA = "__joy_config";
exports.SHARED_MODULE_METADATA = "__module:shared__";
exports.GLOBAL_MODULE_METADATA = "__module:global__";
exports.PATH_METADATA = "path";
exports.PARAMTYPES_METADATA = "design:paramtypes";
exports.SELF_DECLARED_DEPS_METADATA = "self:paramtypes";
exports.OPTIONAL_DEPS_METADATA = "optional:paramtypes";
exports.PROPERTY_DEPS_METADATA = "self:properties_metadata";
exports.OPTIONAL_PROPERTY_DEPS_METADATA = "optional:properties_metadata";
exports.SCOPE_OPTIONS_METADATA = "scope:options";
exports.METHOD_METADATA = "method";
exports.ROUTE_ARGS_METADATA = "__routeArguments__";
exports.CUSTOM_ROUTE_AGRS_METADATA = "__customRouteArgs__";
exports.EXCEPTION_FILTERS_METADATA = "__exceptionFilters__";
exports.FILTER_CATCH_EXCEPTIONS = "__filterCatchExceptions__";
exports.PIPES_METADATA = "__pipes__";
exports.GUARDS_METADATA = "__guards__";
exports.RENDER_METADATA = "__renderTemplate__";
exports.INTERCEPTORS_METADATA = "__interceptors__";
exports.HTTP_CODE_METADATA = "__httpCode__";
exports.MODULE_PATH = "__module_path__";
exports.HEADERS_METADATA = "__headers__";
exports.REDIRECT_METADATA = "__redirect__";

/***/ }),

/***/ 43042:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getComponentMeta = exports.Component = void 0;

var scope_options_interface_1 = __webpack_require__(27538);

var constants_1 = __webpack_require__(29650);

__webpack_require__(1738);

var component_name_generate_1 = __webpack_require__(62000);
/**
 * Decorator that marks a class as a provider.
 * Providers can be injected into other classes via constructor parameter injection
 * using Joy's built-in [Dependency Injection (DI)](#)
 * system.
 *
 * When injecting a provider, it must be visible within the context.
 *
 * Providers can also be defined in a more explicit and imperative form using
 * various [custom provider](#) techniques that expose
 * more capabilities of the DI system.
 *
 * @param options options specifying scope of component
 *
 * @publicApi
 */


function Component(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target) {
    var name = options.name || (0, component_name_generate_1.componentNameGenerate)(target);
    var provider = Object.assign({
      name: name,
      type: target,
      useClass: target,
      scope: scope_options_interface_1.Scope.SINGLETON,
      lazyRegister: false,
      global: true
    }, options);
    Reflect.defineMetadata(constants_1.INJECTABLE_METADATA, provider, target);
  };
}

exports.Component = Component;

function getComponentMeta(target, ownMeta) {
  if (ownMeta === void 0) {
    ownMeta = true;
  }

  if (ownMeta) {
    return Reflect.getOwnMetadata(constants_1.INJECTABLE_METADATA, target);
  } else {
    return Reflect.getMetadata(constants_1.INJECTABLE_METADATA, target);
  }
}

exports.getComponentMeta = getComponentMeta;

/***/ }),

/***/ 56561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isCustomValueComponent = exports.getConfigurationComponents = exports.Component = void 0;

var shared_utils_1 = __webpack_require__(1980);

var constants_1 = __webpack_require__(29650);

var interfaces_1 = __webpack_require__(97116);

var inject_decorator_1 = __webpack_require__(98184);

function Component(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, propertyKey) {
    var propType = Reflect.getMetadata("design:type", target, propertyKey);
    var paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyKey);
    var returnType = Reflect.getMetadata("design:returntype", target, propertyKey);
    var provider;

    if (!(0, shared_utils_1.isUndefined)(paramTypes)) {
      // FactoryProvider
      var inject = [].concat(paramTypes); // 设置自定义注入的参数

      var customParams = Reflect.getMetadata(inject_decorator_1.CUSTOM_INJECT_FUNC_PARAM_META, target, propertyKey);

      if (customParams && customParams.size > 0) {
        customParams.forEach(function (customInject, index) {
          var type = customInject.type,
              name = customInject.name,
              isOptional = customInject.isOptional;

          if (type === undefined && name === undefined) {
            type = inject[index];
          }

          inject[index] = {
            type: type,
            name: name,
            isOptional: isOptional
          };
        });
      }

      provider = Object.assign({
        name: propertyKey,
        type: returnType,
        // useFactory: target[propertyKey],
        useFactory: {
          factory: target.constructor,
          property: propertyKey
        },
        inject: inject,
        scope: interfaces_1.Scope.SINGLETON
      }, options);
    } else {
      if (isCustomValueComponent(options)) {
        //ValueComponent
        provider = Object.assign({
          name: propertyKey,
          type: propType,
          useValue: options.useValue,
          scope: interfaces_1.Scope.SINGLETON
        }, options);
      } else {
        //ClassProvider
        provider = Object.assign({
          name: propertyKey,
          type: propType,
          useClass: propType,
          scope: interfaces_1.Scope.SINGLETON
        }, options);
      }
    }

    var providers = Reflect.getOwnMetadata(constants_1.METADATA.PROVIDERS, target);

    if ((0, shared_utils_1.isNil)(providers)) {
      // 尝试重父类获取
      providers = [].concat(Reflect.getMetadata(constants_1.METADATA.PROVIDERS, target) || []);
    } // 如果已经存在，覆盖之前定义的，可能来至父类


    var existIndex = providers.findIndex(function (value) {
      return value.name === provider.name;
    });

    if (existIndex >= 0) {
      providers[existIndex] = provider;
    } else {
      providers.push(provider);
    }

    Reflect.defineMetadata(constants_1.METADATA.PROVIDERS, providers, target);
  };
}

exports.Component = Component;

function getConfigurationComponents(configClazz) {
  return Reflect.getMetadata(constants_1.METADATA.PROVIDERS, configClazz.prototype);
}

exports.getConfigurationComponents = getConfigurationComponents;

function isCustomValueComponent(provider) {
  return provider && !(0, shared_utils_1.isUndefined)(provider.useValue);
}

exports.isCustomValueComponent = isCustomValueComponent;

/***/ }),

/***/ 46876:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getConfigurationMeta = exports.Configuration = void 0;

var constants_1 = __webpack_require__(29650);

var configuration_component_decorator_1 = __webpack_require__(56561);

var component_decorator_1 = __webpack_require__(43042);

function Configuration(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target) {
    var _a;

    var superMeta = getConfigurationMeta(target) || {};
    var metaData = Object.assign({
      imports: {}
    }, superMeta);

    if (options.imports) {
      for (var _i = 0, _Object$keys = Object.keys(options.imports); _i < _Object$keys.length; _i++) {
        var importKey = _Object$keys[_i];
        // const superImport = superMeta.imports?.[importKey]
        metaData.imports[importKey] = (_a = options.imports) === null || _a === void 0 ? void 0 : _a[importKey];
      }
    }

    Reflect.defineMetadata(constants_1.CONFIGURATION_METADATA, metaData, target);
    (0, component_decorator_1.Component)()(target);
  };
}

exports.Configuration = Configuration;

function getConfigurationMeta(val) {
  var configMetaData = Reflect.getMetadata(constants_1.CONFIGURATION_METADATA, val);
  return configMetaData;
}

exports.getConfigurationMeta = getConfigurationMeta;
Configuration.Component = configuration_component_decorator_1.Component;

/***/ }),

/***/ 14200:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(98184), exports);

__exportStar(__webpack_require__(43042), exports);

__exportStar(__webpack_require__(36315), exports);

__exportStar(__webpack_require__(46876), exports);

__exportStar(__webpack_require__(39440), exports);

/***/ }),

/***/ 98184:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CUSTOM_INJECT_FUNC_PARAM_META = exports.Inject = void 0;

var constants_1 = __webpack_require__(29650);

var shared_utils_1 = __webpack_require__(1980);

var component_name_generate_1 = __webpack_require__(62000);

var injectable_dependency_interface_1 = __webpack_require__(20778);
/**
 * Decorator that marks a constructor parameter as a target for
 *
 * Any injected provider must be visible within the context scope
 * of the class it is being injected into.
 *
 * #### Injection tokens
 * Can be *types* (class names), *strings*. This depends on how the
 * provider with which it is associated was defined. Providers defined with the
 * `@Injectable()` decorator use the class name. Custom Providers may use strings
 * or as the injection id.
 *
 * @param typeOrName lookup key for the provider to be injected (assigned to the constructor
 * parameter).
 *
 * @publicApi
 */


function Inject(typeOrName) {
  var providerName;
  var providerType;

  if ((0, shared_utils_1.isFunction)(typeOrName)) {
    providerType = typeOrName;
  } else {
    providerName = typeOrName;
  }

  return function (target, key, index) {
    if (key === undefined) {
      injectConstructor(target, index, providerName, providerType);
      return;
    } else {
      if (typeof index === "number") {
        injectPropertyFuncParam(target, key, index, providerName, providerType);
      } else {
        injectProperty(target, key, providerName, providerType);
      }
    }
  };
}

exports.Inject = Inject;
exports.CUSTOM_INJECT_FUNC_PARAM_META = "__CUSTOM_INJECT_FUNC_PARAM";

function injectPropertyFuncParam(target, key, index, providerName, providerType) {
  var params = Reflect.getMetadata(exports.CUSTOM_INJECT_FUNC_PARAM_META, target, key) || new Map();
  var param = providerName ? {
    name: providerName
  } : {
    type: providerType
  };
  params.set(index, param);
  Reflect.defineMetadata(exports.CUSTOM_INJECT_FUNC_PARAM_META, params, target, key);
}

function injectProperty(target, key, providerName, providerType) {
  var injectBy = injectable_dependency_interface_1.EnuInjectBy.TYPE_NAME;
  var designType = Reflect.getMetadata("design:type", target, key);

  if (!providerType) {
    providerType = designType;
  } else {
    injectBy = injectable_dependency_interface_1.EnuInjectBy.TYPE;
  }

  if (!providerName) {
    providerName = key;
  } else {
    injectBy = injectable_dependency_interface_1.EnuInjectBy.NAME;
  }

  var properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, target.constructor) || [];
  properties = [].concat(properties, [{
    key: key,
    designType: designType,
    name: providerName,
    type: providerType,
    injectBy: injectBy
  }]);
  Reflect.defineMetadata(constants_1.PROPERTY_DEPS_METADATA, properties, target.constructor);
}

function injectConstructor(target, index, providerName, providerType) {
  var injectBy = injectable_dependency_interface_1.EnuInjectBy.TYPE;
  var paramTypes = Reflect.getMetadata("design:paramtypes", target);
  var designType = paramTypes[index];

  if (providerType) {
    injectBy = injectable_dependency_interface_1.EnuInjectBy.TYPE;
  } else {
    providerType = designType;
  }

  if (providerName) {
    injectBy = injectable_dependency_interface_1.EnuInjectBy.NAME;
  } else {
    providerName = (0, component_name_generate_1.componentNameGenerate)(providerType);
  }

  var dependencies = Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, target) || [];
  dependencies = [].concat(dependencies, [{
    index: index,
    designType: designType,
    name: providerName,
    type: providerType,
    injectBy: injectBy
  }]);
  Reflect.defineMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, dependencies, target);
}

/***/ }),

/***/ 39440:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getOnDidLoadMethodKey = exports.OnDidLoad = void 0;
var ON_DID_LOAD_META = Symbol("onDidLoad");
/**
 * 装饰provider的onDidLoad事件回调方法。
 * onDidLoad事件触发时机：当容器初始化完所有注册的单例组件是，根据组件扫描结果的顺序，逐个执行回调事件。
 * @constructor
 */

function OnDidLoad() {
  return function (target, key) {
    var exist = Reflect.getMetadata(ON_DID_LOAD_META, target.constructor);

    if (exist) {
      if (exist === key) {
        // the method has defined as on load call back
        return;
      }

      throw new Error("Duplicate define @OnDidLoad() on class(name:" + target.constructor.name + ")");
    }

    var designType = Reflect.getMetadata("design:type", target, key);
    Reflect.defineMetadata(ON_DID_LOAD_META, key, target.constructor);
  };
}

exports.OnDidLoad = OnDidLoad;

function getOnDidLoadMethodKey(target) {
  return Reflect.getMetadata(ON_DID_LOAD_META, target);
}

exports.getOnDidLoadMethodKey = getOnDidLoadMethodKey;

/***/ }),

/***/ 36315:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Optional = void 0;

var constants_1 = __webpack_require__(29650);

var inject_decorator_1 = __webpack_require__(98184);
/**
 * Parameter decorator for an injected dependency marking the
 * dependency as optional.
 *
 * @publicApi
 */


function Optional() {
  return function (target, key, index) {
    if (key === undefined) {
      var args = Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, target) || [];
      Reflect.defineMetadata(constants_1.OPTIONAL_DEPS_METADATA, [].concat(args, [index]), target);
      return;
    } else {
      if (typeof index === "number") {
        var params = Reflect.getMetadata(inject_decorator_1.CUSTOM_INJECT_FUNC_PARAM_META, target, key) || new Map();
        var param = params.get(index) || {};
        param.isOptional = true;
        params.set(index, param);
        Reflect.defineMetadata(inject_decorator_1.CUSTOM_INJECT_FUNC_PARAM_META, params, target, key);
      } else {
        var properties = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, target.constructor) || [];
        Reflect.defineMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, [].concat(properties, [key]), target.constructor);
      }
    } // if (!isUndefined(index)) {
    //   const args = Reflect.getMetadata(OPTIONAL_DEPS_METADATA, target) || [];
    //   Reflect.defineMetadata(OPTIONAL_DEPS_METADATA, [...args, index], target);
    //   return;
    // }
    // const properties =
    //   Reflect.getMetadata(
    //     OPTIONAL_PROPERTY_DEPS_METADATA,
    //     target.constructor
    //   ) || [];
    // Reflect.defineMetadata(
    //   OPTIONAL_PROPERTY_DEPS_METADATA,
    //   [...properties, key],
    //   target.constructor
    // );

  };
}

exports.Optional = Optional;

/***/ }),

/***/ 9705:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(14200), exports);

/***/ }),

/***/ 43708:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HttpStatus = void 0;
var HttpStatus;

(function (HttpStatus) {
  HttpStatus[HttpStatus["CONTINUE"] = 100] = "CONTINUE";
  HttpStatus[HttpStatus["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
  HttpStatus[HttpStatus["PROCESSING"] = 102] = "PROCESSING";
  HttpStatus[HttpStatus["OK"] = 200] = "OK";
  HttpStatus[HttpStatus["CREATED"] = 201] = "CREATED";
  HttpStatus[HttpStatus["ACCEPTED"] = 202] = "ACCEPTED";
  HttpStatus[HttpStatus["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
  HttpStatus[HttpStatus["NO_CONTENT"] = 204] = "NO_CONTENT";
  HttpStatus[HttpStatus["RESET_CONTENT"] = 205] = "RESET_CONTENT";
  HttpStatus[HttpStatus["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
  HttpStatus[HttpStatus["AMBIGUOUS"] = 300] = "AMBIGUOUS";
  HttpStatus[HttpStatus["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
  HttpStatus[HttpStatus["FOUND"] = 302] = "FOUND";
  HttpStatus[HttpStatus["SEE_OTHER"] = 303] = "SEE_OTHER";
  HttpStatus[HttpStatus["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
  HttpStatus[HttpStatus["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
  HttpStatus[HttpStatus["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
  HttpStatus[HttpStatus["BAD_REQUEST"] = 400] = "BAD_REQUEST";
  HttpStatus[HttpStatus["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
  HttpStatus[HttpStatus["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
  HttpStatus[HttpStatus["FORBIDDEN"] = 403] = "FORBIDDEN";
  HttpStatus[HttpStatus["NOT_FOUND"] = 404] = "NOT_FOUND";
  HttpStatus[HttpStatus["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
  HttpStatus[HttpStatus["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
  HttpStatus[HttpStatus["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
  HttpStatus[HttpStatus["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
  HttpStatus[HttpStatus["CONFLICT"] = 409] = "CONFLICT";
  HttpStatus[HttpStatus["GONE"] = 410] = "GONE";
  HttpStatus[HttpStatus["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
  HttpStatus[HttpStatus["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
  HttpStatus[HttpStatus["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
  HttpStatus[HttpStatus["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
  HttpStatus[HttpStatus["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
  HttpStatus[HttpStatus["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
  HttpStatus[HttpStatus["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
  HttpStatus[HttpStatus["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
  HttpStatus[HttpStatus["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
  HttpStatus[HttpStatus["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  HttpStatus[HttpStatus["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  HttpStatus[HttpStatus["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
  HttpStatus[HttpStatus["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
  HttpStatus[HttpStatus["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
  HttpStatus[HttpStatus["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
  HttpStatus[HttpStatus["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
})(HttpStatus = exports.HttpStatus || (exports.HttpStatus = {}));

/***/ }),

/***/ 34638:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(52121), exports);

__exportStar(__webpack_require__(43708), exports);

/***/ }),

/***/ 52121:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RequestMethod = void 0;
var RequestMethod;

(function (RequestMethod) {
  RequestMethod[RequestMethod["GET"] = 0] = "GET";
  RequestMethod[RequestMethod["POST"] = 1] = "POST";
  RequestMethod[RequestMethod["PUT"] = 2] = "PUT";
  RequestMethod[RequestMethod["DELETE"] = 3] = "DELETE";
  RequestMethod[RequestMethod["PATCH"] = 4] = "PATCH";
  RequestMethod[RequestMethod["ALL"] = 5] = "ALL";
  RequestMethod[RequestMethod["OPTIONS"] = 6] = "OPTIONS";
  RequestMethod[RequestMethod["HEAD"] = 7] = "HEAD";
})(RequestMethod = exports.RequestMethod || (exports.RequestMethod = {}));

/***/ }),

/***/ 30878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InvalidDependencyTypeException = void 0;

var runtime_exception_1 = __webpack_require__(53816);

var shared_utils_1 = __webpack_require__(1980);

var InvalidDependencyTypeException = /*#__PURE__*/function (_runtime_exception_1$) {
  _inheritsLoose(InvalidDependencyTypeException, _runtime_exception_1$);

  function InvalidDependencyTypeException(providerName, constructorIndex, prpKey, msgWhy) {
    var message = "Can't resolve dependencies of the " + providerName;

    if ((0, shared_utils_1.isNil)(constructorIndex)) {
      message += ". Please make sure that the \"" + (prpKey === null || prpKey === void 0 ? void 0 : prpKey.toString()) + "\" property,";
    } else {
      message += ". Please check that the argument " + providerName + " at index [" + constructorIndex + "], reason:";
    }

    message += msgWhy;
    return _runtime_exception_1$.call(this, message) || this;
  }

  return InvalidDependencyTypeException;
}(runtime_exception_1.RuntimeException);

exports.InvalidDependencyTypeException = InvalidDependencyTypeException;

/***/ }),

/***/ 39954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NotUniqueMatchedProviderException = void 0;

var runtime_exception_1 = __webpack_require__(53816);

var NotUniqueMatchedProviderException = /*#__PURE__*/function (_runtime_exception_1$) {
  _inheritsLoose(NotUniqueMatchedProviderException, _runtime_exception_1$);

  function NotUniqueMatchedProviderException(type, matchedProviderNames) {
    return _runtime_exception_1$.call(this, "There is more than one (" + matchedProviderNames + ") provider match type(" + type.name + "). ") || this;
  }

  return NotUniqueMatchedProviderException;
}(runtime_exception_1.RuntimeException);

exports.NotUniqueMatchedProviderException = NotUniqueMatchedProviderException;

/***/ }),

/***/ 53816:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

var _wrapNativeSuper = __webpack_require__(53084);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RuntimeException = void 0;

var RuntimeException = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RuntimeException, _Error);

  function RuntimeException(msg) {
    var _this;

    if (msg === void 0) {
      msg = "";
    }

    _this = _Error.call(this, msg) || this;
    _this.msg = msg;
    return _this;
  }

  var _proto = RuntimeException.prototype;

  _proto.what = function what() {
    return this.msg;
  };

  return RuntimeException;
}( /*#__PURE__*/_wrapNativeSuper(Error));

exports.RuntimeException = RuntimeException;

/***/ }),

/***/ 19942:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UndefinedDependencyException = void 0;

var messages_1 = __webpack_require__(33833);

var runtime_exception_1 = __webpack_require__(53816);

var UndefinedDependencyException = /*#__PURE__*/function (_runtime_exception_1$) {
  _inheritsLoose(UndefinedDependencyException, _runtime_exception_1$);

  function UndefinedDependencyException(type, undefinedDependencyContext) {
    return _runtime_exception_1$.call(this, (0, messages_1.UNKNOWN_DEPENDENCIES_MESSAGE)(type, undefinedDependencyContext)) || this;
  }

  return UndefinedDependencyException;
}(runtime_exception_1.RuntimeException);

exports.UndefinedDependencyException = UndefinedDependencyException;

/***/ }),

/***/ 33213:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnknownDependenciesException = void 0;

var messages_1 = __webpack_require__(33833);

var runtime_exception_1 = __webpack_require__(53816);

var UnknownDependenciesException = /*#__PURE__*/function (_runtime_exception_1$) {
  _inheritsLoose(UnknownDependenciesException, _runtime_exception_1$);

  function UnknownDependenciesException(type, unknownDependencyContext) {
    return _runtime_exception_1$.call(this, (0, messages_1.UNKNOWN_DEPENDENCIES_MESSAGE)(type, unknownDependencyContext)) || this;
  }

  return UnknownDependenciesException;
}(runtime_exception_1.RuntimeException);

exports.UnknownDependenciesException = UnknownDependenciesException;

/***/ }),

/***/ 61266:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(83135);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UnknownElementException = void 0;

var runtime_exception_1 = __webpack_require__(53816);

var UnknownElementException = /*#__PURE__*/function (_runtime_exception_1$) {
  _inheritsLoose(UnknownElementException, _runtime_exception_1$);

  function UnknownElementException(name) {
    return _runtime_exception_1$.call(this, "Joy could not find provider(id:" + (name || "given") + ") in the current context") || this;
  }

  return UnknownElementException;
}(runtime_exception_1.RuntimeException);

exports.UnknownElementException = UnknownElementException;

/***/ }),

/***/ 86057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(53816), exports);

/***/ }),

/***/ 33833:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.INVALID_EXCEPTION_FILTER = exports.INVALID_CLASS_SCOPE_MESSAGE = exports.INVALID_PROVIDER_ID_MESSAGE = exports.INVALID_CLASS_MESSAGE = exports.UNKNOWN_EXPORT_MESSAGE = exports.INVALID_MODULE_MESSAGE = exports.INVALID_MIDDLEWARE_MESSAGE = exports.UNKNOWN_DEPENDENCIES_MESSAGE = void 0;

var shared_utils_1 = __webpack_require__(1980);
/**
 * Returns the name of an instance
 * @param instance The instance which should get the name from
 */


var getInstanceName = function getInstanceName(instance) {
  return instance && instance.name;
};
/**
 * Returns the name of the dependency
 * Tries to get the class name, otherwise the string value
 * (= injection token). As fallback it returns '+'
 * @param dependency The dependency whichs name should get displayed
 */


var getDependencyName = function getDependencyName(dependency) {
  return (// use class name
    getInstanceName(dependency) || (0, shared_utils_1.isSymbol)(dependency) && dependency.toString() || // use string directly
    dependency || // otherwise
    "+"
  );
};

var UNKNOWN_DEPENDENCIES_MESSAGE = function UNKNOWN_DEPENDENCIES_MESSAGE(type, unknownDependencyContext) {
  var index = unknownDependencyContext.index,
      _unknownDependencyCon = unknownDependencyContext.name,
      name = _unknownDependencyCon === void 0 ? "dependency" : _unknownDependencyCon,
      dependencies = unknownDependencyContext.dependencies,
      key = unknownDependencyContext.key;
  var moduleName = "Module";
  var message = "Joy can't resolve dependencies of the " + type.toString(); // todo 说明导入provider的两个方式

  var potentialSolutions = "\n\nPotential solutions:\n- If " + String(name) + " is a provider, is it part of the current context?\n- If " + String(name) + " is exported from a separate @Module, is that module imported within " + moduleName + "?\n  @Module({\n    imports: [ /* the Module containing " + String(name) + " */ ]\n  })\n";

  if ((0, shared_utils_1.isNil)(index)) {
    message += ". Please make sure that the \"" + (key === null || key === void 0 ? void 0 : key.toString()) + "\" property is available in the current context." + potentialSolutions;
    return message;
  }

  var dependenciesName = (dependencies || []).map(getDependencyName);
  dependenciesName[index] = "?";
  message += " (";
  message += dependenciesName.join(", ");
  message += "). Please make sure that the argument " + type + " at index [" + index + "] is available in the context.";
  message += potentialSolutions;
  return message;
};

exports.UNKNOWN_DEPENDENCIES_MESSAGE = UNKNOWN_DEPENDENCIES_MESSAGE;

var INVALID_MIDDLEWARE_MESSAGE = function INVALID_MIDDLEWARE_MESSAGE(text, name) {
  return "The middleware doesn't provide the 'use' method (" + name + ")";
};

exports.INVALID_MIDDLEWARE_MESSAGE = INVALID_MIDDLEWARE_MESSAGE;

var INVALID_MODULE_MESSAGE = function INVALID_MODULE_MESSAGE(text, scope) {
  return "Joy cannot create the module instance. Often, this is because of a circular dependency between modules. Use forwardRef() to avoid it.\nScope [" + scope + "]\n";
};

exports.INVALID_MODULE_MESSAGE = INVALID_MODULE_MESSAGE;

var UNKNOWN_EXPORT_MESSAGE = function UNKNOWN_EXPORT_MESSAGE(token, module) {
  if (token === void 0) {
    token = "item";
  }

  return "Joy cannot export a provider/module that is not a part of the currently processed module (" + module + "). Please verify whether the exported " + token + " is available in this particular context.\n\nPossible Solutions:\n- Is " + token + " part of the relevant providers/imports within " + module + "?\n";
};

exports.UNKNOWN_EXPORT_MESSAGE = UNKNOWN_EXPORT_MESSAGE;

var INVALID_CLASS_MESSAGE = function INVALID_CLASS_MESSAGE(text, value) {
  return "ModuleRef cannot instantiate class (" + value + " is not constructable).";
};

exports.INVALID_CLASS_MESSAGE = INVALID_CLASS_MESSAGE;

var INVALID_PROVIDER_ID_MESSAGE = function INVALID_PROVIDER_ID_MESSAGE(text, value) {
  return "Cannot find provider named (" + value + ").";
};

exports.INVALID_PROVIDER_ID_MESSAGE = INVALID_PROVIDER_ID_MESSAGE;

var INVALID_CLASS_SCOPE_MESSAGE = function INVALID_CLASS_SCOPE_MESSAGE(text, name) {
  return (name || "This class") + " is marked as a scoped provider. Request and transient-scoped providers can't be used in combination with \"get()\" method. Please, use \"resolve()\" instead.";
};

exports.INVALID_CLASS_SCOPE_MESSAGE = INVALID_CLASS_SCOPE_MESSAGE;
exports.INVALID_EXCEPTION_FILTER = "Invalid exception filters (@UseFilters()).";

/***/ }),

/***/ 30107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HookCenter = void 0;

var runtime_exception_1 = __webpack_require__(53816);

var inject_hook_decorator_1 = __webpack_require__(77157);

var register_tap_decorator_1 = __webpack_require__(93647);

var hook_1 = __webpack_require__(36552);

var HookCenter = /*#__PURE__*/function () {
  function HookCenter() {
    this.hooks = new Map(); // 这会导致transient类型的provider内存泄露，永远无法自动释放，所以在transient类型的provider中注册的tap，需要手动调用`unregisterTag()`手动释放

    this._tapCache = new Map();
  }

  var _proto = HookCenter.prototype;

  _proto.registerHooksFromWrappers = function registerHooksFromWrappers(wrappers) {
    var hooks = new Array();

    for (var _iterator = _createForOfIteratorHelperLoose(wrappers), _step; !(_step = _iterator()).done;) {
      var wrapper = _step.value;
      var wrapperHooks = this.registerHooksFromWrapper(wrapper);

      if (wrapperHooks && wrapperHooks.length) {
        hooks.push.apply(hooks, wrapperHooks);
      }
    }

    return hooks;
  };

  _proto.registerHooksFromWrapper = function registerHooksFromWrapper(wrapper) {
    var type = wrapper.type;

    if (type === Object) {
      return;
    }

    var hookMetas = (0, inject_hook_decorator_1.getHooksMetadata)(type);

    if (hookMetas === undefined || hookMetas.length === 0) {
      return;
    }

    var hooks = new Array();

    for (var i = 0; i < hookMetas.length; i++) {
      var hookMeta = hookMetas[i];
      var hookInfo = Object.assign({}, hookMeta);
      var pipe = this.registerHook(hookInfo);
      hooks.push(pipe);
    }

    return hooks;
  };

  _proto.registerHook = function registerHook(hookInfo) {
    var _hook = this.hooks.get(hookInfo.id);

    if (_hook) {
      // todo 只有两者相同才能兼容。
      // return _hook
      throw new runtime_exception_1.RuntimeException("Error: Duplicate register hook(" + hookInfo.id + ")");
    }

    var id = hookInfo.id,
        type = hookInfo.type,
        async = hookInfo.async,
        parallel = hookInfo.parallel;
    var hook = new hook_1.Hook(id, type, async, parallel);
    this.hooks.set(id, hook);
    return hook;
  };

  _proto.registerProviderHooks = function registerProviderHooks(provider, providerType) {
    var type = providerType || provider.constructor;
    var hookMetas = (0, inject_hook_decorator_1.getHooksMetadata)(type);

    if (hookMetas === undefined || hookMetas.length === 0) {
      return undefined;
    }

    var registeredHooks = new Array();

    for (var i = 0; i < hookMetas.length; i++) {
      var hookMeta = hookMetas[i];
      var existHook = provider[hookMeta.propKey];

      if (existHook) {
        // 已经注册了hook实例，则继续使用已注册的hook。
        if (existHook.id !== hookMeta.id) {
          throw new runtime_exception_1.RuntimeException("Instance hook id(" + existHook + ") is not equal to @Hook() defines id(" + hookMeta.id + ")");
        }
      }

      var hook = existHook || this.hooks.get(hookMeta.id);

      if (!hook) {
        hook = this.registerHook(hookMeta);
      }

      registeredHooks.push(hook);
      provider[hookMeta.propKey] = hook;
    }

    return registeredHooks;
  } //todo implement unregisterProviderHooks()
  ;

  _proto.registerProviderTaps = function registerProviderTaps(provider, providerType) {
    var taps = new Array();
    var type = providerType || provider.constructor;
    var tapMetas = (0, register_tap_decorator_1.getTapsMetadata)(type);

    if (tapMetas === undefined || tapMetas.length === 0) {
      return taps;
    }

    for (var i = 0; i < tapMetas.length; i++) {
      var tapMeta = tapMetas[i];
      var tap = Object.assign(Object.assign({}, tapMeta), {
        provider: provider
      });
      this.registerTap(tapMeta.hookId, tap);
      taps.push(tap);
    }

    return taps;
  };

  _proto.registerTap = function registerTap(hookId, tap) {
    var _a, _b;

    var hook = this.hooks.get(hookId);

    if (hook === undefined) {
      throw new runtime_exception_1.RuntimeException("Register provider's tap failed, the hook(" + hookId + ") is not found, the provider is : " + ((_b = (_a = tap.provider) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name));
    }

    hook.registerTap(tap);

    this._tapCache.set(tap.provider, [hookId]);
  };

  _proto.unregisterProviderTaps = function unregisterProviderTaps(provider) {
    var removedTaps = [];

    var hookIds = this._tapCache.get(provider);

    if (!hookIds || hookIds.length == 0) {
      return removedTaps;
    }

    for (var i = 0; i < hookIds.length; i++) {
      var tap = this.unregisterProviderTap(provider, hookIds[i]);
      tap && removedTaps.push(tap);
    }

    return removedTaps;
  };

  _proto.unregisterProviderTap = function unregisterProviderTap(provider, hookId) {
    var hook = this.hooks.get(hookId);

    if (!hook) {
      return undefined;
    }

    hook.unregisterProviderTap(provider);
  };

  _proto.applyHook = function applyHook(hookId, args, initialValue) {
    var hook = this.hooks.get(hookId);

    if (hook === undefined) {
      throw new runtime_exception_1.RuntimeException("Can not apply hook(" + hookId + "), the hook is not registered.");
    }

    return hook.call(initialValue);
  };

  return HookCenter;
}();

exports.HookCenter = HookCenter;

/***/ }),

/***/ 89598:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HookResolver = void 0;

var register_tap_decorator_1 = __webpack_require__(93647);

var interfaces_1 = __webpack_require__(97116);

var constants_1 = __webpack_require__(30759);

var HookResolver = /*#__PURE__*/function () {
  function HookResolver(pluginCenter) {
    this.pluginCenter = pluginCenter;
    pluginCenter.registerTap("onComponentRegisterAfter", {
      id: "plugin-center-resolve-hooks-register-hook",
      propKey: "onComponentRegisterAfter",
      provider: this
    });
    pluginCenter.registerTap("componentAfterInitialize", {
      id: "plugin-center-resolve-hooks-register-component",
      propKey: "componentAfterInitialize",
      provider: this
    });
  }

  var _proto = HookResolver.prototype;

  _proto.onComponentRegisterAfter = function onComponentRegisterAfter(componentWrapper) {
    this.pluginCenter.registerHooksFromWrapper(componentWrapper);

    if (componentWrapper.scope === interfaces_1.Scope.SINGLETON) {
      var instancePerContext = componentWrapper.getInstanceByContextId(constants_1.STATIC_CONTEXT);

      if (instancePerContext && instancePerContext.isResolved && instancePerContext.instance) {
        this.componentAfterInitialize(instancePerContext.instance, {
          instanceWrapper: componentWrapper
        });
      }
    }

    return componentWrapper;
  };

  _proto.componentAfterInitialize = function componentAfterInitialize(instance, args) {
    var instanceWrapper = args.instanceWrapper;

    if (instanceWrapper.scope === interfaces_1.Scope.SINGLETON) {
      this.pluginCenter.registerProviderHooks(instance, instanceWrapper.type);
    }

    var taps = (0, register_tap_decorator_1.getTapsMetadata)(instanceWrapper.type);

    if (taps && taps.length > 0) {
      this.pluginCenter.registerProviderTaps(instance, instanceWrapper.type);
    }

    return instance;
  };

  return HookResolver;
}();

exports.HookResolver = HookResolver;

/***/ }),

/***/ 36552:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(83856);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Hook = void 0;

var hook_interface_1 = __webpack_require__(49541);

var tapable_1 = __webpack_require__(84388);

var errors_1 = __webpack_require__(86057);

var Hook = /*#__PURE__*/function () {
  function Hook(id, type, async, parallel) {
    if (async === void 0) {
      async = true;
    }

    if (parallel === void 0) {
      parallel = false;
    }

    this.id = id;
    this.type = type;
    this.async = async;
    this.parallel = parallel;
    this._isDisposed = false;

    try {
      var hookClazz = this.getTapableHookClazz(type, async, parallel);
      this.hookPoint = new hookClazz(["memo", "args"]);
    } catch (e) {
      throw new errors_1.RuntimeException("Can not init hook(" + id + ") instance, because of: " + e.message);
    }
  }

  var _proto = Hook.prototype;

  _proto.getTapableHook = function getTapableHook() {
    return this.hookPoint;
  };

  _proto.call = function call() {
    if (this._isDisposed) {
      console.warn("Call a disposed hook, this will do nothing.");
    }

    if (this.async) {
      var _this$hookPoint;

      return (_this$hookPoint = this.hookPoint).promise.apply(_this$hookPoint, arguments);
    } else {
      var _this$hookPoint2;

      return (_this$hookPoint2 = this.hookPoint).call.apply(_this$hookPoint2, arguments);
    }
  };

  _proto.dispose = function dispose() {
    this._isDisposed = true;
    this.hookPoint.taps = [];
  };

  _proto.getTapableHookClazz = function getTapableHookClazz(type, async, parallel) {
    var hookClazz;

    if (async) {
      if (parallel) {
        switch (type) {
          case hook_interface_1.HookType.Traverse:
            hookClazz = tapable_1.AsyncParallelHook;
            break;

          case hook_interface_1.HookType.Bail:
            hookClazz = tapable_1.AsyncParallelBailHook;
            break;

          case hook_interface_1.HookType.Waterfall:
            throw new errors_1.RuntimeException("can not set waterfall hook run parallel");
        }
      } else {
        switch (type) {
          case hook_interface_1.HookType.Traverse:
            hookClazz = tapable_1.AsyncSeriesHook;
            break;

          case hook_interface_1.HookType.Bail:
            hookClazz = tapable_1.AsyncSeriesBailHook;
            break;

          case hook_interface_1.HookType.Waterfall:
            hookClazz = tapable_1.AsyncSeriesWaterfallHook;
        }
      }
    } else {
      if (parallel) {
        switch (type) {
          case hook_interface_1.HookType.Traverse:
            throw new errors_1.RuntimeException("can not set sync hook run parallel");
        }
      } else {
        switch (type) {
          case hook_interface_1.HookType.Traverse:
            hookClazz = tapable_1.SyncHook;
            break;

          case hook_interface_1.HookType.Bail:
            hookClazz = tapable_1.SyncBailHook;
            break;

          case hook_interface_1.HookType.Waterfall:
            hookClazz = tapable_1.SyncWaterfallHook;
        }
      }
    }

    if (!hookClazz) {
      throw new errors_1.RuntimeException("");
    }

    return hookClazz;
  };

  _proto.registerTap = function registerTap(tap) {
    var _this = this;

    if (this._isDisposed) {
      console.warn("Try to register a tag to a hook, which is disposed, this will do nothing.");
    }

    var provider = tap.provider,
        propKey = tap.propKey;
    var tapMethod = this.async ? "tapPromise" : "tap";
    this.hookPoint[tapMethod]({
      name: tap.id,
      stage: tap.stage,
      before: tap.before,
      // @ts-ignore
      provider: tap.provider,
      propKey: tap.propKey
    }, function (memo, args) {
      // @ts-ignore
      var result = provider[propKey](memo, args);

      if (_this.async && !(result instanceof Promise)) {
        return Promise.resolve(result);
      }

      return result;
    });
  };

  _proto.unregisterProviderTap = function unregisterProviderTap(provider) {
    // @ts-ignore
    var taps = this.hookPoint.taps;

    for (var i = 0; i < taps.length; i++) {
      // @ts-ignore
      if (taps[i].provider === provider) {
        var tap = taps[i];
        taps.splice(i, 1);
        return {
          id: tap.name,
          stage: tap.stage,
          before: tap.before,
          // @ts-ignore
          provider: tap.provider,
          // @ts-ignore
          propKey: tap.propKey
        };
      }
    }
  };

  _createClass(Hook, [{
    key: "isDisposed",
    get: function get() {
      return this._isDisposed;
    }
  }]);

  return Hook;
}();

exports.Hook = Hook;

/***/ }),

/***/ 22806:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(49541), exports);

__exportStar(__webpack_require__(13925), exports);

__exportStar(__webpack_require__(77157), exports);

__exportStar(__webpack_require__(93647), exports);

__exportStar(__webpack_require__(30107), exports);

__exportStar(__webpack_require__(89598), exports);

/***/ }),

/***/ 77157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getHooksMetadata = exports.InjectHook = void 0;

var hook_interface_1 = __webpack_require__(49541);

var HOOKS_META_KEY = Symbol("joy-hooks");

function InjectHook(hookOptions) {
  return function (target, propertyKey) {
    var hook = Object.assign({
      type: hook_interface_1.HookType.Traverse,
      async: true,
      parallel: false
    }, {
      id: propertyKey,
      propKey: propertyKey
    }, hookOptions);
    var existHooks = getHooksMetadata(target) || [];
    existHooks.push(hook);
    Reflect.defineMetadata(HOOKS_META_KEY, existHooks, target);
  };
}

exports.InjectHook = InjectHook;

function getHooksMetadata(targetType) {
  return Reflect.getMetadata(HOOKS_META_KEY, typeof targetType === "function" ? targetType.prototype : targetType);
}

exports.getHooksMetadata = getHooksMetadata;

/***/ }),

/***/ 49541:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HookType = void 0;
var HookType;

(function (HookType) {
  HookType[HookType["Traverse"] = 0] = "Traverse";
  HookType[HookType["Waterfall"] = 1] = "Waterfall";
  HookType[HookType["Bail"] = 2] = "Bail";
})(HookType = exports.HookType || (exports.HookType = {}));

/***/ }),

/***/ 13925:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 93647:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTapsMetadata = exports.RegisterTap = void 0;

function RegisterTap(hookOptions) {
  return function (target, propertyKey) {
    var existTaps = getTapsMetadata(target) || [];
    var exist = existTaps.find(function (it) {
      return it.propKey === propertyKey;
    });

    if (exist) {
      return;
    }

    var hook = Object.assign({}, {
      id: target.constructor.name + "." + propertyKey,
      hookId: propertyKey,
      propKey: propertyKey
    }, hookOptions);
    existTaps.push(hook);
    Reflect.defineMetadata("__joy_taps", existTaps, target);
  };
}

exports.RegisterTap = RegisterTap;

function getTapsMetadata(targetType) {
  return Reflect.getMetadata("__joy_taps", typeof targetType === "function" ? targetType.prototype : targetType);
}

exports.getTapsMetadata = getTapsMetadata;

/***/ }),

/***/ 16134:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
})); // export { create } from './create'

__exportStar(__webpack_require__(97116), exports);

__exportStar(__webpack_require__(9705), exports);

__exportStar(__webpack_require__(34638), exports);

__exportStar(__webpack_require__(86057), exports);

__exportStar(__webpack_require__(76799), exports);

__exportStar(__webpack_require__(63080), exports); // export * from "./utils";


__exportStar(__webpack_require__(22806), exports);

__exportStar(__webpack_require__(65602), exports);

__exportStar(__webpack_require__(94903), exports);

__exportStar(__webpack_require__(12138), exports);

/***/ }),

/***/ 97596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ApplicationContainer = void 0;

var shared_utils_1 = __webpack_require__(1980);

var component_wrapper_1 = __webpack_require__(66007);

var runtime_exception_1 = __webpack_require__(53816);

var hook_1 = __webpack_require__(22806);

var not_unique_matched_provider_exception_1 = __webpack_require__(39954);

var ApplicationContainer = /*#__PURE__*/function () {
  // private readonly _providers = new Map<string, ComponentWrapper<Injectable>>()
  function ApplicationContainer() {
    this._providerStore = new Map();
    this._typeMap = new Map();
    this._nameMap = new Map(); // key: component.name, value: component.id

    this._aliasMap = new Map(); // key: aliasName, value: component.name
  } // /**
  //  * 可使用已存在Component的情况：已存在的同名的，且类型兼容，scope相等。
  //  * 所欲其它情况，直接使用新的Component定义，替换旧的Component。
  //  *
  //  * @param wrapperMetaOptions
  //  * @private
  //  */
  // private checkWrapperReplaceable(wrapperMetaOptions: ComponentWrapperOptions): ComponentWrapper | undefined {
  //   const {type, name, scope} = wrapperMetaOptions;
  //   if (!name) {
  //     return;
  //   }
  //   const exist = this.getProviderByName(name);
  //   if (exist) {
  //     if (exist.hasInstanced) {
  //       if (!(exist.type === type || isSubClass(exist.type, type)) || exist.scope !== scope) {
  //         throw new RuntimeException(`Register provider failed, can not register duplicate name(${String(name)}), the previous register one has instanced, and the type and scope is not compatible。`);
  //       }
  //     }
  //   }
  //
  //   return exist;
  // }


  var _proto = ApplicationContainer.prototype;

  _proto.addWrapper = function addWrapper(wrapperMetaOptions) {
    var _a, _b;

    var type = wrapperMetaOptions.type,
        name = wrapperMetaOptions.name,
        compPackage = wrapperMetaOptions["package"],
        alias = wrapperMetaOptions.alias,
        scope = wrapperMetaOptions.scope;

    if (!name) {
      throw new runtime_exception_1.RuntimeException("Register provider failed, the name is undefined.");
    }

    var mergedAlias = alias;
    var existOne = this.getProviderByName(name, compPackage);

    if (existOne) {
      if (existOne.hasInstanced) {
        if (!(existOne.type === type || (0, shared_utils_1.isSubClass)(existOne.type, type)) || existOne.scope !== scope) {
          throw new runtime_exception_1.RuntimeException("Register provider failed, can not register duplicate name(" + String(name) + "), the previous register one has instanced, and the type or scope is not compatible.");
        } else {
          return existOne;
        }
      }

      if (existOne.alias && existOne.alias.length >= 0) {
        mergedAlias = mergedAlias === null || mergedAlias === void 0 ? void 0 : mergedAlias.concat(existOne.alias);
      }
    }

    var componentWrapper = new component_wrapper_1.ComponentWrapper(Object.assign({}, wrapperMetaOptions));

    if (existOne) {
      console.debug("Overriding component {name: " + String(name) + ", package: " + (compPackage || "") + ", type: " + ((_a = existOne.type) === null || _a === void 0 ? void 0 : _a.name) + "} with {name: " + String(name) + ", package: " + (compPackage || "") + ", type:" + ((_b = componentWrapper.type) === null || _b === void 0 ? void 0 : _b.name) + "}\"");
    }

    this._providerStore.set(componentWrapper.id, componentWrapper);

    this.addNameCache(componentWrapper);
    this.addTypeCache(componentWrapper);

    if (alias && alias.length) {
      for (var _iterator = _createForOfIteratorHelperLoose(alias), _step; !(_step = _iterator()).done;) {
        var it = _step.value;

        var existAlias = this._aliasMap.get(it);

        if (existAlias) {
          if (existAlias !== name) {
            console.debug("Overriding alias '" + String(it) + "' definition for registered name " + String(existAlias) + " with new target name '" + String(name) + "'");
          } else {
            // has not changed
            continue;
          }
        }

        this._aliasMap.set(it, name);
      }
    }

    if (this.onComponentRegisterAfter) {
      this.onComponentRegisterAfter.call(componentWrapper);
    }

    return componentWrapper;
  };

  _proto.deleteWrapper = function deleteWrapper(instanceWrapper) {
    this.deleteCache(instanceWrapper);

    this._providerStore["delete"](instanceWrapper.id);
  };

  _proto.addNameCache = function addNameCache(instanceWrapper) {
    var id = instanceWrapper.id,
        name = instanceWrapper.name;
    var ids = this._nameMap.get(name) || [];
    ids.push(id);

    this._nameMap.set(name, ids);
  };

  _proto.addTypeCache = function addTypeCache(instanceWrapper) {
    var _a;

    var type = instanceWrapper.type,
        name = instanceWrapper.name,
        id = instanceWrapper.id;

    if (!type) {
      throw new runtime_exception_1.RuntimeException("Provider's type must not be null. provider name:" + name.toString());
    }

    var proto = type;
    var ids = ((_a = this._typeMap.get(type)) === null || _a === void 0 ? void 0 : _a.get(type)) || [];

    if (!ids) {
      ids = [id];
    } else {
      ids.push(id);
    }

    do {
      var typeCache = this._typeMap.get(proto);

      if (!typeCache) {
        typeCache = new Map([[type, ids]]);

        this._typeMap.set(proto, typeCache);
      } else {
        typeCache.set(type, ids);
      }

      proto = Object.getPrototypeOf(proto);
    } while (proto !== Function.prototype);
  };

  _proto.deleteCache = function deleteCache(instanceWrapper) {
    var hasDel = false;
    var type = instanceWrapper.type,
        name = instanceWrapper.name;
    var names = Array.isArray(name) ? name : [name];

    for (var _iterator2 = _createForOfIteratorHelperLoose(names), _step2; !(_step2 = _iterator2()).done;) {
      var n = _step2.value;
      hasDel = this._nameMap["delete"](n) || hasDel;
    }

    if (!type) {
      return hasDel;
    }

    var typeCache = this._typeMap.get(type);

    if (!typeCache) {
      return hasDel;
    }

    if (typeCache.size >= 0) {
      this._typeMap["delete"](type);

      hasDel = true;
    }

    return hasDel;
  };

  _proto.addProviders = function addProviders(providers) {
    var _this = this;

    var instanceWrappers = new Array((providers === null || providers === void 0 ? void 0 : providers.length) || 0);

    if (!providers || providers.length === 0) {
      return instanceWrappers;
    }

    return providers.map(function (provider) {
      return _this.addProvider(provider);
    });
  };

  _proto.getProviderDefinition = function getProviderDefinition(nameOrType) {
    var wrapper = this.getProvider(nameOrType);

    if (!wrapper) {
      return undefined;
    }

    return this.getProviderDefinitionByWrapper(wrapper);
  };

  _proto.getProviderDefinitionByWrapper = function getProviderDefinitionByWrapper(wrapper) {
    var definition;
    var instanceBy = wrapper.instanceBy,
        name = wrapper.name,
        type = wrapper.type,
        scope = wrapper.scope;

    if (instanceBy === "class") {
      definition = {
        name: name,
        useClass: type,
        scope: scope,
        lazyRegister: wrapper.autoLoad
      };
    } else if (instanceBy === "value") {
      definition = {
        name: name,
        type: type,
        useValue: wrapper.instance
      };
    } else if (instanceBy === "factory") {
      definition = {
        name: name,
        type: type,
        useFactory: wrapper.factory,
        inject: wrapper.inject,
        scope: scope
      };
    } else {
      throw new Error("unknown instanceBy, wrapper:" + wrapper.id);
    }

    return definition;
  };

  _proto.addProvider = function addProvider(provider) {
    var instanceWrapper;

    if (this.isCustomClass(provider)) {
      instanceWrapper = this.addCustomClass(provider);
    } else if (this.isCustomValue(provider)) {
      instanceWrapper = this.addCustomValue(provider);
    } else if (this.isCustomFactory(provider)) {
      instanceWrapper = this.addCustomFactory(provider);
    } else {
      throw new runtime_exception_1.RuntimeException("unknown provider type" + provider);
    }

    return instanceWrapper;
  };

  _proto.isCustomProvider = function isCustomProvider(provider) {
    return !(0, shared_utils_1.isNil)(provider.name);
  };

  _proto.isCustomClass = function isCustomClass(provider) {
    return !(0, shared_utils_1.isUndefined)(provider.useClass);
  };

  _proto.isCustomValue = function isCustomValue(provider) {
    return !(0, shared_utils_1.isUndefined)(provider.useValue);
  };

  _proto.isCustomFactory = function isCustomFactory(provider) {
    return !(0, shared_utils_1.isUndefined)(provider.useFactory);
  };

  _proto.addCustomClass = function addCustomClass(provider) {
    var name = provider.name,
        packageName = provider["package"],
        global = provider.global,
        alias = provider.alias,
        type = provider.type,
        useClass = provider.useClass,
        scope = provider.scope;
    return this.addWrapper({
      instanceBy: "class",
      name: name,
      alias: alias,
      "package": packageName,
      global: global,
      type: useClass,
      useClass: useClass || type,
      instance: null,
      isResolved: false,
      scope: scope
    });
  };

  _proto.addCustomValue = function addCustomValue(provider) {
    var name = provider.name,
        alias = provider.alias,
        value = provider.useValue,
        _provider$type = provider.type,
        type = _provider$type === void 0 ? Object : _provider$type;
    return this.addWrapper({
      instanceBy: "value",
      name: name,
      alias: alias,
      type: type,
      instance: value,
      isResolved: true,
      async: value instanceof Promise
    });
  };

  _proto.addCustomFactory = function addCustomFactory(provider) {
    var name = provider.name,
        alias = provider.alias,
        factory = provider.useFactory,
        inject = provider.inject,
        scope = provider.scope,
        type = provider.type;
    return this.addWrapper({
      instanceBy: "factory",
      name: name,
      alias: alias,
      type: type,
      factory: factory,
      inject: inject || [],
      instance: null,
      isResolved: false,
      scope: scope
    });
  };

  _proto.replace = function replace(toReplaceWrapperId, newProvider) {
    var provider = this.getProviderById(toReplaceWrapperId);

    if (!provider) {
      throw new runtime_exception_1.RuntimeException("cannot merge provider, originalProvider id${}");
    }

    var beforeDefinition = this.getProviderDefinitionByWrapper(provider);
    provider.replaceWith(newProvider);
    var nextDefinition = this.getProviderDefinitionByWrapper(provider);
    this.onComponentReplaceAfter.call(nextDefinition, beforeDefinition);
  };

  _proto["delete"] = function _delete(idOrType) {
    var provider = this.getProvider(idOrType);

    if (!provider) {
      throw new runtime_exception_1.RuntimeException("cannot remove provider(" + idOrType + "), it is not exists in container.");
    }

    this.deleteWrapper(provider);
    return provider;
  };

  _proto.hasComponent = function hasComponent(componentId) {
    return this._providerStore.get(componentId) !== undefined;
  };

  _proto.getProvider = function getProvider(nameOrType, packageName) {
    var wrapper;

    if (typeof nameOrType === "string" || typeof nameOrType === "symbol") {
      wrapper = this.getProviderByName(nameOrType, packageName);
    } else {
      wrapper = this.getProviderByType(nameOrType);
    } // if (wrapper === undefined && this.parent) {
    //   // try to get from parent container
    //   wrapper = this.parent.getProvider(nameOrType);
    // }


    return wrapper;
  };

  _proto.getProviderIds = function getProviderIds() {
    return this._providerStore.keys();
  };

  _proto.getProviderById = function getProviderById(id) {
    return this._providerStore.get(id);
  }
  /**
   * 按名称查找组件策略：
   * 1. 在包内查找。
   * 2. 在全局公共包中查找。
   * @param name
   * @param packageName
   */
  ;

  _proto.getProviderByName = function getProviderByName(name, packageName) {
    var id = this._nameMap.get(name);

    if (!id || id.length === 0) {
      var targetName = this._aliasMap.get(name);

      if (targetName) {
        id = this._nameMap.get(targetName);

        if (!id) {
          console.debug("Component alias '" + String(name) + "' can not find target name '" + String(targetName) + "' definition.");
          return undefined;
        }
      }
    }

    if (id && id.length > 0) {
      if (packageName) {
        for (var i = id.length - 1; i >= 0; i--) {
          var wrapper = this._providerStore.get(id[i]);

          if (wrapper && wrapper["package"] === packageName) {
            return this._providerStore.get(id[i]);
          }
        }
      }

      for (var _i = id.length - 1; _i >= 0; _i--) {
        var _wrapper = this._providerStore.get(id[_i]);

        if (_wrapper && (!_wrapper["package"] || _wrapper.global)) {
          return this._providerStore.get(id[_i]);
        }
      }
    }

    return undefined;
  };

  _proto.getProviderByType = function getProviderByType(type) {
    var matchTypes = this._typeMap.get(type);

    if (!matchTypes) {
      return undefined;
    }

    var matchSize = matchTypes.size;

    if (matchSize === 1) {
      var onlyMatchIds = matchTypes.values().next().value; // The last register one will replace previous.

      return this._providerStore.get(onlyMatchIds[onlyMatchIds.length - 1]);
    } else if (matchSize > 1) {
      var exactMatched = matchTypes.get(type);

      if (exactMatched && exactMatched.length === 1) {
        return this._providerStore.get(exactMatched[0]);
      } else {
        // throw new Error(`There is ${matchSize} providers match the type(${type.name})`)
        throw new not_unique_matched_provider_exception_1.NotUniqueMatchedProviderException(type, [].concat(matchTypes.keys()).map(function (it) {
          return it.name;
        }));
      }
    }

    return undefined;
  };

  _proto.getProvidersByType = function getProvidersByType(type) {
    var matchTypes = this._typeMap.get(type);

    if (!matchTypes) {
      return [];
    }

    var ids = [];

    for (var _iterator3 = _createForOfIteratorHelperLoose(matchTypes.values()), _step3; !(_step3 = _iterator3()).done;) {
      var _ids = _step3.value;
      ids = ids.concat(_ids);
    }

    return ids;
  };

  _proto.filter = function filter(_filter) {
    var internalProviderIds = this._providerStore.keys();

    var result = new Array();

    for (var _iterator4 = _createForOfIteratorHelperLoose(internalProviderIds), _step4; !(_step4 = _iterator4()).done;) {
      var providerId = _step4.value;

      var wrapper = this._providerStore.get(providerId);

      if (wrapper && _filter(wrapper)) {
        result.push(wrapper);
      }
    }

    return result;
  };

  return ApplicationContainer;
}();

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: false
}), __metadata("design:type", Object)], ApplicationContainer.prototype, "onComponentRegisterAfter", void 0);

__decorate([(0, hook_1.InjectHook)({
  type: hook_1.HookType.Traverse,
  async: false
}), __metadata("design:type", Object)], ApplicationContainer.prototype, "onComponentReplaceAfter", void 0);

exports.ApplicationContainer = ApplicationContainer;

/***/ }),

/***/ 62000:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
 // eslint-disable-next-line @typescript-eslint/ban-types

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.componentNameGenerate = void 0;

function componentNameGenerate(clazz) {
  if (typeof clazz === "function") {
    var name = clazz.name;
    name = name.replace(name[0], name[0].toLowerCase());
    return name;
  } else {
    return "" + clazz;
  }
}

exports.componentNameGenerate = componentNameGenerate;

/***/ }),

/***/ 94903:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ComponentScanner = void 0;

var constants_1 = __webpack_require__(29650);

var shared_utils_1 = __webpack_require__(1980);

var decorators_1 = __webpack_require__(9705);

var ComponentScanner = /*#__PURE__*/function () {
  function ComponentScanner() {
    this.ctxRegistry = [];
  }

  var _proto = ComponentScanner.prototype;

  _proto.scan = function scan(config // ctxRegistry: EntryType[] = []
  ) {
    var _this = this;

    var providers = [];

    if (Array.isArray(config)) {
      if (config.length > 0) {
        config.forEach(function (it) {
          providers = providers.concat(_this.scan(it));
        });
      }
    } else if ((0, shared_utils_1.isFunction)(config)) {
      providers = this.scanForConfig(config);
    } else if ((0, shared_utils_1.isObject)(config)) {
      providers = this.scanObject(config);
    }

    return providers;
  };

  _proto.scanObject = function scanObject(obj // ctxRegistry: EntryType[] = []
  ) {
    var _this2 = this;

    var ctxRegistry = this.ctxRegistry;
    var providers = [];

    if (ctxRegistry.includes(obj)) {
      return providers;
    }

    if (this.isProvider(obj)) {
      providers.push(obj);
      return providers;
    }

    ctxRegistry.push(obj);
    Object.keys(obj).forEach(function (prop) {
      var propValue = obj[prop];
      if ((0, shared_utils_1.isNil)(propValue)) return; // 1. value provider

      if (_this2.isProvider(propValue)) {
        // @ts-ignore
        providers.push(Object.assign({
          name: prop
        }, propValue));
      }

      if ((0, shared_utils_1.isFunction)(propValue)) {
        if (_this2.isConfigurationClass(propValue)) {
          // 3. configuration class
          providers = providers.concat(_this2.scanForConfig(propValue));
        } else {
          // 2. class provider
          var componentMeta = (0, decorators_1.getComponentMeta)(propValue);

          if (!(0, shared_utils_1.isNil)(componentMeta)) {
            providers.push(Object.assign({}, componentMeta));
          }
        }
      }
    });
    return providers;
  };

  _proto.scanForConfig = function scanForConfig(configClazz // ctxRegistry: EntryType[] = []
  ) {
    var _this3 = this;

    var ctxRegistry = this.ctxRegistry;
    var providers = [];

    if (!(0, shared_utils_1.isFunction)(configClazz)) {
      return providers;
    }

    if (ctxRegistry.includes(configClazz)) {
      return providers;
    }

    ctxRegistry.push(configClazz);
    var componentMeta = (0, decorators_1.getComponentMeta)(configClazz);
    componentMeta && providers.push(componentMeta);
    var configMeta = (0, decorators_1.getConfigurationMeta)(configClazz);

    if (configMeta === null || configMeta === void 0 ? void 0 : configMeta.imports) {
      var importKeys = Object.keys(configMeta.imports);

      for (var _i = 0, _importKeys = importKeys; _i < _importKeys.length; _i++) {
        var importKey = _importKeys[_i];
        providers = providers.concat(this.scan(configMeta.imports[importKey]));
      }
    }

    var reflectProviders = Reflect.getMetadata(constants_1.METADATA.PROVIDERS, configClazz.prototype);

    if (reflectProviders) {
      var ownerProviders = [];
      reflectProviders.forEach(function (provider) {
        ownerProviders.push(provider); // 扫描通过属性定义导入的configuration类

        if (_this3.isConfigurationClass(provider.type)) {
          var propImportProviders = _this3.scanForConfig(provider.type);

          if (propImportProviders && propImportProviders.length) {
            ownerProviders.push.apply(ownerProviders, propImportProviders.slice(1));
          }
        }
      });
      providers = providers.concat(ownerProviders);
    }

    return providers;
  };

  _proto.reflectMetadata = function reflectMetadata(metatype, metadataKey) {
    return Reflect.getMetadata(metadataKey, metatype) || [];
  };

  _proto.isConfigurationClass = function isConfigurationClass(val) {
    if ((0, shared_utils_1.isNil)(val)) {
      return false;
    }

    var configMetaData = (0, decorators_1.getConfigurationMeta)(val);

    if (undefined !== configMetaData && null !== configMetaData) {
      return true;
    }

    return false;
  };

  _proto.isProvider = function isProvider(val) {
    return val && typeof val === "object" && (val.useFactory || val.useValue || val.useClass);
  };

  return ComponentScanner;
}();

exports.ComponentScanner = ComponentScanner;

/***/ }),

/***/ 66007:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(83856);

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ComponentWrapper = exports.INSTANCE_ID_SYMBOL = exports.INSTANCE_METADATA_SYMBOL = void 0;

var interfaces_1 = __webpack_require__(97116);

var random_string_generator_util_1 = __webpack_require__(61447);

var shared_utils_1 = __webpack_require__(1980);

var constants_1 = __webpack_require__(30759);

var runtime_exception_1 = __webpack_require__(53816);

exports.INSTANCE_METADATA_SYMBOL = Symbol["for"]("instance_metadata:cache");
exports.INSTANCE_ID_SYMBOL = Symbol["for"]("instance_metadata:id");

var ComponentWrapper = /*#__PURE__*/function () {
  function ComponentWrapper(metadata) {
    if (metadata === void 0) {
      metadata = {};
    }

    this.global = false; // 如果为false，只有通过明确的包名，才能找到该Component，无法通过匿名包名或全局找到。
    // public readonly module?: any;

    this.scope = interfaces_1.Scope.SINGLETON;
    this.values = new WeakMap();
    var name = String(metadata.name || "") + "-";
    this[exports.INSTANCE_METADATA_SYMBOL] = {};
    this[exports.INSTANCE_ID_SYMBOL] = name + (0, random_string_generator_util_1.randomStringGenerator)();
    this.initialize(metadata);
  }

  var _proto = ComponentWrapper.prototype;

  _proto.getInstanceByStaticContext = function getInstanceByStaticContext() {
    return this.values.get(constants_1.STATIC_CONTEXT);
  };

  _proto.getInstanceByContextId = function getInstanceByContextId(contextId) {
    if (this.scope === interfaces_1.Scope.PROTOTYPE) {
      return this.cloneTransientInstance(contextId);
    }

    var instancePerContext = this.values.get(contextId);
    return instancePerContext ? instancePerContext : this.cloneStaticInstance(contextId);
  } // todo remove
  ;

  _proto.getInstanceByInquirerId = function getInstanceByInquirerId(contextId, inquirerId) {
    // let collectionPerContext = this.transientMap.get(inquirerId);
    // if (!collectionPerContext) {
    //   collectionPerContext = new WeakMap();
    //   this.transientMap.set(inquirerId, collectionPerContext);
    // }
    // const instancePerContext = collectionPerContext.get(contextId);
    // return instancePerContext
    //   ? instancePerContext
    //   : this.cloneTransientInstance(contextId, inquirerId);
    return this.cloneTransientInstance(contextId);
  };

  _proto.setInstanceByContextId = function setInstanceByContextId(contextId, value, inquirerId) {
    if (this.scope === interfaces_1.Scope.PROTOTYPE && inquirerId) {
      return this.setInstanceByInquirerId(contextId, inquirerId, value);
    }

    this.values.set(contextId, value);
  };

  _proto.setInstanceByInquirerId = function setInstanceByInquirerId(contextId, inquirerId, value) {
    var _a;

    var collection = (_a = this.transientMap) === null || _a === void 0 ? void 0 : _a.get(inquirerId);

    if (!collection) {
      collection = new WeakMap();
      this.transientMap.set(inquirerId, collection);
    }

    collection.set(contextId, value);
  };

  _proto.addCtorMetadata = function addCtorMetadata(index, wrapper) {
    if (!this[exports.INSTANCE_METADATA_SYMBOL].dependencies) {
      this[exports.INSTANCE_METADATA_SYMBOL].dependencies = [];
    }

    this[exports.INSTANCE_METADATA_SYMBOL].dependencies[index] = wrapper;
  };

  _proto.getCtorMetadata = function getCtorMetadata() {
    return this[exports.INSTANCE_METADATA_SYMBOL].dependencies;
  };

  _proto.addPropertiesMetadata = function addPropertiesMetadata(key, wrapper) {
    if (!this[exports.INSTANCE_METADATA_SYMBOL].properties) {
      this[exports.INSTANCE_METADATA_SYMBOL].properties = [];
    }

    this[exports.INSTANCE_METADATA_SYMBOL].properties.push({
      key: key,
      wrapper: wrapper
    });
  };

  _proto.getPropertiesMetadata = function getPropertiesMetadata() {
    return this[exports.INSTANCE_METADATA_SYMBOL].properties;
  };

  _proto.addEnhancerMetadata = function addEnhancerMetadata(wrapper) {
    if (!this[exports.INSTANCE_METADATA_SYMBOL].enhancers) {
      this[exports.INSTANCE_METADATA_SYMBOL].enhancers = [];
    }

    this[exports.INSTANCE_METADATA_SYMBOL].enhancers.push(wrapper);
  };

  _proto.getEnhancersMetadata = function getEnhancersMetadata() {
    return this[exports.INSTANCE_METADATA_SYMBOL].enhancers;
  };

  _proto.isDependencyTreeStatic = function isDependencyTreeStatic() {
    if (this.scope === interfaces_1.Scope.SINGLETON) {
      return true;
    }

    return false;
  };

  _proto.cloneStaticInstance = function cloneStaticInstance(contextId) {
    var staticInstance = this.getInstanceByStaticContext();

    if (this.isDependencyTreeStatic()) {
      return staticInstance;
    }

    var instancePerContext = Object.assign(Object.assign({}, staticInstance), {
      instance: undefined,
      isResolved: false,
      isPending: false
    });

    if (this.isNewable()) {
      instancePerContext.instance = Object.create(this.type.prototype);
    }

    this.setInstanceByContextId(contextId, instancePerContext);
    return instancePerContext;
  };

  _proto.cloneTransientInstance = function cloneTransientInstance(contextId) {
    var staticInstance = this.getInstanceByStaticContext();
    var instancePerContext = Object.assign(Object.assign({}, staticInstance), {
      instance: undefined,
      isResolved: false,
      isPending: false
    });

    if (this.isNewable()) {
      instancePerContext.instance = Object.create(this.type.prototype);
    } // will not save instance, the transient instance will mananged by inquirer
    // this.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);


    return instancePerContext;
  };

  _proto.createPrototype = function createPrototype(contextId) {
    var host = this.getInstanceByContextId(contextId);

    if (!this.isNewable() || host.isResolved) {
      return;
    }

    return Object.create(this.type.prototype);
  };

  _proto.isInRequestScope = function isInRequestScope(contextId, inquirer) {
    var isDependencyTreeStatic = this.isDependencyTreeStatic();
    return !isDependencyTreeStatic && contextId !== constants_1.STATIC_CONTEXT && (!this.isTransient || this.isTransient && inquirer);
  };

  _proto.isLazyTransient = function isLazyTransient(contextId, inquirer) {
    var isInquirerRequestScoped = inquirer && !inquirer.isDependencyTreeStatic();
    return !!(this.isDependencyTreeStatic() && contextId !== constants_1.STATIC_CONTEXT && this.isTransient && isInquirerRequestScoped);
  };

  _proto.isStatic = function isStatic(contextId, inquirer) {
    var isInquirerRequestScoped = inquirer && !inquirer.isDependencyTreeStatic();
    var isStaticTransient = this.isTransient && !isInquirerRequestScoped;
    return this.isDependencyTreeStatic() && contextId === constants_1.STATIC_CONTEXT && (!this.isTransient || isStaticTransient && !!inquirer);
  };

  _proto.getStaticTransientInstances = function getStaticTransientInstances() {
    if (!this.transientMap) {
      return [];
    }

    var instances = [].concat(this.transientMap.values());
    return instances.map(function (item) {
      return item.get(constants_1.STATIC_CONTEXT);
    }).filter(function (item) {
      return !!item;
    });
  }
  /**
   * todo 已经生成的实例，如何替换为新的类型？ 包括单例和多例模式下生成的实例。
   *
   * @param provider
   */
  ;

  _proto.replaceWith = function replaceWith(provider) {
    if (provider.type) {
      this.type = provider.type;
    }

    if (provider.useValue) {
      this.setInstanceByContextId(constants_1.STATIC_CONTEXT, provider.useValue);
    } else if (provider.useClass) {
      var type = provider.type,
          scope = provider.scope,
          lazyRegister = provider.lazyRegister,
          useClass = provider.useClass;
      Object.assign(this, {
        type: type,
        scope: scope,
        autoLoad: lazyRegister,
        useClass: useClass,
        inject: null
      });
      this.values["delete"](constants_1.STATIC_CONTEXT);
    } else if (provider.useFactory) {
      var useFactory = provider.useFactory,
          inject = provider.inject,
          _scope = provider.scope;
      Object.assign(this, {
        useFactory: useFactory,
        inject: inject || [],
        scope: _scope
      });
      this.values["delete"](constants_1.STATIC_CONTEXT);
    } else {
      throw new runtime_exception_1.RuntimeException("Unknown provider type, provider " + this.name.toString() + " merge provider " + JSON.stringify(provider) + " failed.");
    }
  };

  _proto.isNewable = function isNewable() {
    return (0, shared_utils_1.isNil)(this.inject) && this.type && this.type.prototype;
  } // private isWrapperListStatic(
  //   tree: ComponentWrapper[],
  //   lookupRegistry: string[]
  // ): boolean {
  //   return tree.every((item: ComponentWrapper) =>
  //     item.isDependencyTreeStatic(lookupRegistry)
  //   );
  // }
  ;

  _proto.initialize = function initialize(metadata) {
    var instance = metadata.instance,
        isResolved = metadata.isResolved,
        wrapperPartial = __rest(metadata, ["instance", "isResolved"]);

    Object.assign(this, wrapperPartial);
    this.setInstanceByContextId(constants_1.STATIC_CONTEXT, {
      id: this.id,
      instance: instance,
      isResolved: isResolved
    });
    this.scope === interfaces_1.Scope.PROTOTYPE && (this.transientMap = new Map());
  };

  _createClass(ComponentWrapper, [{
    key: "id",
    get: function get() {
      return this[exports.INSTANCE_ID_SYMBOL];
    }
  }, {
    key: "instance",
    get: function get() {
      var instancePerContext = this.getInstanceByContextId(constants_1.STATIC_CONTEXT);
      return instancePerContext.instance;
    },
    set: function set(value) {
      this.values.set(constants_1.STATIC_CONTEXT, {
        id: this.id,
        instance: value
      });
    }
  }, {
    key: "isNotMetatype",
    get: function get() {
      var isFactory = this.type && !(0, shared_utils_1.isNil)(this.inject);
      return !this.type || isFactory;
    }
  }, {
    key: "isTransient",
    get: function get() {
      return this.scope === interfaces_1.Scope.PROTOTYPE;
    }
  }]);

  return ComponentWrapper;
}();

exports.ComponentWrapper = ComponentWrapper;

/***/ }),

/***/ 30759:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.STATIC_CONTEXT = void 0;
var STATIC_CONTEXT_ID = 1;
exports.STATIC_CONTEXT = Object.freeze({
  id: STATIC_CONTEXT_ID
});

/***/ }),

/***/ 76799:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(97596), exports); // export { ContextId, IComponentWrapper } from "./instance-wrapper";
// export { InjectorHookTaps } from "./injector";


__exportStar(__webpack_require__(66007), exports);

__exportStar(__webpack_require__(69969), exports);

/***/ }),

/***/ 69969:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(3080);

var _construct = __webpack_require__(50716);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Injector = void 0;

var constants_1 = __webpack_require__(29650);

var interfaces_1 = __webpack_require__(97116);

var shared_utils_1 = __webpack_require__(1980);

var runtime_exception_1 = __webpack_require__(53816);

var undefined_dependency_exception_1 = __webpack_require__(19942);

var unknown_dependencies_exception_1 = __webpack_require__(33213);

var constants_2 = __webpack_require__(30759);

var task_thenable_1 = __webpack_require__(2052);

var component_name_generate_1 = __webpack_require__(62000);

var core_1 = __webpack_require__(14200);

var component_info_aware_interface_1 = __webpack_require__(98799);

var invalid_dependency_type_exception_1 = __webpack_require__(30878);

var hook_interface_1 = __webpack_require__(49541);

var not_unique_matched_provider_exception_1 = __webpack_require__(39954);

var application_context_ware_interface_1 = __webpack_require__(83218);

var application_context_1 = __webpack_require__(65602);

var hook_1 = __webpack_require__(22806);

var Injector = /*#__PURE__*/function () {
  function Injector(container, parentInjector) {
    this.container = container;
    this.parentInjector = parentInjector; // this.container = appContent.container;
    // this.parentInjector = appContent.parent.injector
    // this.componentAfterInitialize = this.pluginCenter.registerHook({
    //   id: "componentAfterInitialize",
    //   async: false,
    //   parallel: false,
    //   type: HookType.Waterfall,
    // });
  }

  var _proto = Injector.prototype;

  _proto.loadProvider = function loadProvider(wrapper, contextId) {
    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    var instance = this.loadInstance(wrapper, contextId); // await this.loadEnhancersPerContext(wrapper, contextId, wrapper

    return instance.getResult();
  };

  _proto.loadInstance = function loadInstance(wrapper, contextId) {
    var _this = this;

    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    if (!wrapper.hasInstanced) {
      // 标记是否已经被加载过，已经加载和实例化的Component被替换和修改，将会带来很多未知的风险。
      wrapper.hasInstanced = true;
    }

    var instanceHost = wrapper.getInstanceByContextId(contextId);

    if (instanceHost.isResolved) {
      return task_thenable_1.TaskThenable.resolve(instanceHost.instance);
    } // 如果component未声明在本容器内，则尝试在父容器处理。


    if (!this.container.hasComponent(wrapper.id)) {
      if (this.parentInjector) {
        return this.parentInjector.loadInstance(wrapper, contextId);
      } else {
        throw new runtime_exception_1.RuntimeException("Instance component error, the component(id:" + String(wrapper.id) + ",name:" + String(wrapper.name) + ") is not exists in context.");
      }
    }

    if (wrapper.scope === interfaces_1.Scope.SINGLETON && instanceHost.loadTask) {
      return instanceHost.loadTask;
    }

    var name = wrapper.name,
        inject = wrapper.inject;
    var targetWrapper = wrapper;

    if ((0, shared_utils_1.isUndefined)(targetWrapper)) {
      throw new runtime_exception_1.RuntimeException();
    }

    var constructorDeps = this.resolveConstructorParams(wrapper, inject, contextId);
    var loadTask = task_thenable_1.TaskThenable.all(constructorDeps).then(function (deps) {
      return _this.instantiateClass(deps, instanceHost, wrapper, targetWrapper, contextId);
    }).then(function (instance) {
      if (!(0, shared_utils_1.isNil)(inject)) {
        return instance;
      }

      return _this.loadInstanceProperties(instance, wrapper, contextId).then(function (injectedProps) {
        return instance;
      });
    }).then(function (instance) {
      var _a;

      instance = ((_a = _this.componentAfterPropertiesSet) === null || _a === void 0 ? void 0 : _a.call(instance, {
        instanceWrapper: wrapper
      })) || instance;
      return instance;
    }).then(function (instance) {
      if ((0, component_info_aware_interface_1.isComponentInfoAwareComp)(instance)) {
        instance.setProviderInfo({
          name: wrapper.name,
          type: wrapper.type,
          scope: wrapper.scope
        });
      }

      if ((0, application_context_ware_interface_1.isApplicationContextAwareComp)(instance)) {
        var contextWrapper = _this.container.getProviderByType(application_context_1.ApplicationContext);

        var context = contextWrapper && _this.loadProvider(contextWrapper);

        if (!context || context.then) {
          throw new runtime_exception_1.RuntimeException("Can not call setApplicationContext on component '" + String(wrapper.name) + ", because can not get app context instance.'");
        }

        instance.setApplicationContext(context);
      } // if (isNil(inject) && isFunction(instance.afterPropertiesSet)) {
      //   const rst = instance.afterPropertiesSet();
      //   if (isPromise(rst)) {
      //     return new Promise((resolve, reject) => {
      //       rst.then(() => {
      //         resolve(instance);
      //       }, reject);
      //     });
      //   }
      // }


      return instance;
    }).then(function (instance) {
      if ((0, shared_utils_1.isFunction)(instance.initialize)) {
        var rst = instance.initialize();

        if ((0, shared_utils_1.isPromise)(rst)) {
          return new Promise(function (resolve, reject) {
            rst.then(function () {
              resolve(instance);
            }, reject);
          });
        }
      }

      return instance;
    }).then(function (instance) {
      var _a;

      instance = ((_a = _this.componentAfterInitialize) === null || _a === void 0 ? void 0 : _a.call(instance, {
        instanceWrapper: wrapper
      })) || instance;
      instanceHost.isResolved = true;
      return instance;
    });
    instanceHost.loadTask = loadTask;
    return loadTask;
  };

  _proto.loadInstanceProperties = function loadInstanceProperties(instance, wrapper, contextId) {
    var _this2 = this;

    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    var properties = this.resolveProperties(wrapper, contextId);

    if (properties.length === 0) {
      return task_thenable_1.TaskThenable.resolve([]);
    }

    return task_thenable_1.TaskThenable.all(properties.map(function (i) {
      return i.loadTask;
    })).then(function (propertyInstances) {
      properties.forEach(function (p, i) {
        p.isResolved = true;
        p.instance = propertyInstances[i];
      });

      _this2.applyProperties(instance, properties);

      return properties;
    });
  };

  _proto.resolveConstructorParams = function resolveConstructorParams(wrapper, inject, contextId) {
    var _this3 = this;

    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    var metadata = wrapper.getCtorMetadata();

    if (metadata) {
      return this.loadCtorMetadata(metadata, contextId);
    }

    var dependencies = this.reflectConstructorParams(wrapper.type, inject);
    var optionalDependenciesIds = (0, shared_utils_1.isNil)(inject) ? this.reflectOptionalParams(wrapper.type) : [];
    return dependencies.map(function (param, index) {
      try {
        return _this3.resolveSingleParam(wrapper, param, contextId);
      } catch (err) {
        var isOptional = param.isOptional || optionalDependenciesIds && optionalDependenciesIds.includes(index);

        if (!isOptional) {
          throw err;
        }

        return undefined;
      }
    });
  }
  /**
   * 获取构造函数中需要注入的依赖项
   */
  ;

  _proto.reflectConstructorParams = function reflectConstructorParams(type, params) {
    var paramDeps = []; // when useFactory or custom inject constructor params

    if (!(0, shared_utils_1.isNil)(params)) {
      paramDeps = params.map(function (param, index) {
        var type;
        var name;
        var injectBy;
        var isOptional;

        if (typeof param === "object") {
          type = param.type;
          name = param.name;
          isOptional = param.isOptional;
          injectBy = type !== undefined ? interfaces_1.EnuInjectBy.TYPE : interfaces_1.EnuInjectBy.NAME;
        } else if ((0, shared_utils_1.isFunction)(param)) {
          type = param;
          injectBy = interfaces_1.EnuInjectBy.TYPE;
        } else {
          name = param;
          injectBy = interfaces_1.EnuInjectBy.NAME;
        }

        return {
          index: index,
          name: name,
          type: type,
          designType: type,
          injectBy: injectBy,
          isOptional: isOptional
        };
      });
      return paramDeps;
    }

    var cusParams = this.reflectCustomfParams(type); // items that decorated by @Inject()

    var cusParamsMap;

    if (cusParams && cusParams.length > 0) {
      cusParamsMap = new Map();

      for (var _iterator = _createForOfIteratorHelperLoose(cusParams), _step; !(_step = _iterator()).done;) {
        var param = _step.value;
        cusParamsMap.set(param.index, param);
      }
    }

    var custructionParams = Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type) || [];
    paramDeps = custructionParams.map(function (paramType, index) {
      var cusParam = cusParamsMap && cusParamsMap.get(index);
      if (!(0, shared_utils_1.isNil)(cusParam)) return cusParam;

      if (paramType === Object) {
        //when not specified a type, or set as a interface
        throw new undefined_dependency_exception_1.UndefinedDependencyException("Constructor(" + type.name + ") argument(index:" + index + ")", {
          index: index,
          dependencies: custructionParams
        });
      }

      return {
        index: index,
        name: (0, component_name_generate_1.componentNameGenerate)(paramType),
        type: paramType,
        injectBy: interfaces_1.EnuInjectBy.TYPE
      };
    });
    return paramDeps;
  };

  _proto.reflectOptionalParams = function reflectOptionalParams(type) {
    return Reflect.getMetadata(constants_1.OPTIONAL_DEPS_METADATA, type);
  }
  /**
   * 在构造函数参数中，通过@Inject()声明的依赖项
   * @param type
   */
  ;

  _proto.reflectCustomfParams = function reflectCustomfParams(type) {
    return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type) || [];
  };

  _proto.resolveSingleParam = function resolveSingleParam(wrapper, dependency, contextId) {
    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    if ((0, shared_utils_1.isUndefined)(dependency)) {
      throw new undefined_dependency_exception_1.UndefinedDependencyException(String(wrapper.name), dependency);
    }

    var key = dependency.key,
        index = dependency.index,
        designType = dependency.designType,
        name = dependency.name,
        type = dependency.type,
        injectBy = dependency.injectBy;

    if (injectBy === interfaces_1.EnuInjectBy.TYPE && type === Object) {
      throw new invalid_dependency_type_exception_1.InvalidDependencyTypeException(String(wrapper.name), index, undefined, "should not set Object type to " + String(wrapper.name) + " argument at index [" + index + "]");
    }

    var paramWrapper = this.getInstanceWrapper(injectBy, type, name, wrapper["package"]);

    if ((0, shared_utils_1.isNil)(paramWrapper) && !(0, shared_utils_1.isNil)(dependency.type)) {
      paramWrapper = this.dynamicAddWrapper(dependency.type, dependency.name);
    }

    if ((0, shared_utils_1.isNil)(paramWrapper)) {
      throw new unknown_dependencies_exception_1.UnknownDependenciesException(String(wrapper.name), dependency);
    }

    if (designType && designType !== Object && paramWrapper.type !== Object && designType !== paramWrapper.type && !(0, shared_utils_1.isSubClass)(paramWrapper.type, designType)) {
      throw new invalid_dependency_type_exception_1.InvalidDependencyTypeException(String(wrapper.name), index, key, paramWrapper.type.name + " class provider can not set to " + (type === null || type === void 0 ? void 0 : type.name) + " class");
    }

    !(0, shared_utils_1.isNil)(key) ? wrapper.addPropertiesMetadata(key, paramWrapper) : wrapper.addCtorMetadata(index, paramWrapper);
    return this.resolveInstance(paramWrapper, contextId);
  };

  _proto.getInstanceWrapper = function getInstanceWrapper(injectBy, type, name, packageName) {
    var container = this.container;
    var instanceWrapper;

    if (type === undefined && name === undefined) {
      throw new Error("Can not find provider by type and name, the both are undefined.");
    }

    switch (injectBy) {
      case interfaces_1.EnuInjectBy.TYPE:
        if (type === undefined) {
          throw new Error("Can not find provider by type, the type is undefined.");
        }

        instanceWrapper = container.getProviderByType(type);
        break;

      case interfaces_1.EnuInjectBy.NAME:
        if (name === undefined) {
          throw new Error("Can not find provider by name, the name is undefined.");
        }

        instanceWrapper = container.getProviderByName(name, packageName);

        if (instanceWrapper && !(0, shared_utils_1.isSubClass)(instanceWrapper.type, type)) {// todo print warn log, but not interrupt running
        }

        break;

      case interfaces_1.EnuInjectBy.TYPE_NAME:
      default:
        var err;

        if (type !== undefined && type !== Object) {
          try {
            instanceWrapper = container.getProviderByType(type);
          } catch (e) {
            if (!(e instanceof not_unique_matched_provider_exception_1.NotUniqueMatchedProviderException)) {
              throw e;
            }

            err = e;
          }
        }

        if (!instanceWrapper && name !== undefined) {
          // then not found by type, or found out more than one provider
          instanceWrapper = container.getProviderByName(name, packageName);
        }

        if (!instanceWrapper && err) {
          throw err;
        }

    }

    if (!instanceWrapper && this.parentInjector) {
      instanceWrapper = this.parentInjector.getInstanceWrapper(injectBy, type, name, packageName);
    }

    return instanceWrapper;
  };

  _proto.dynamicAddWrapper = function dynamicAddWrapper(type, name) {
    var meta = (0, core_1.getComponentMeta)(type);

    if (!meta || !meta.lazyRegister) {
      return undefined;
    }

    if (name) {
      meta.name = name;
    }

    return this.container.addProvider(meta);
  };

  _proto.resolveParamToken = function resolveParamToken(wrapper, param) {
    if (!param.forwardRef) {
      return param;
    }

    wrapper.forwardRef = true;
    return param.forwardRef();
  };

  _proto.resolveInstance = function resolveInstance(instanceWrapper, contextId) {
    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    return this.loadInstance(instanceWrapper, contextId);
  };

  _proto.resolveProperties = function resolveProperties(wrapper, contextId) {
    var _this4 = this;

    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    var metadata = wrapper.getPropertiesMetadata();

    if (metadata) {
      return this.loadPropertiesMetadata(metadata, contextId);
    }

    var properties = this.reflectProperties(wrapper.type);
    return properties.map(function (propDep) {
      var instanceRst;

      try {
        instanceRst = _this4.resolveSingleParam(wrapper, propDep, contextId);
      } catch (e) {
        if (!propDep.isOptional) {
          throw e;
        }
      }

      return Object.assign(Object.assign({}, propDep), {
        isResolved: false,
        loadTask: instanceRst,
        instance: null
      });
    });
  };

  _proto.reflectProperties = function reflectProperties(type) {
    var properties = Reflect.getMetadata(constants_1.PROPERTY_DEPS_METADATA, type) || [];
    var optionalKeys = Reflect.getMetadata(constants_1.OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];
    return properties.map(function (item) {
      return Object.assign(Object.assign({}, item), {
        isOptional: optionalKeys.includes(item.key),
        isResolved: false
      });
    });
  };

  _proto.applyProperties = function applyProperties(instance, properties) {
    if ((0, shared_utils_1.isObject)(instance)) {
      properties.filter(function (item) {
        return !(0, shared_utils_1.isNil)(item.instance);
      }).forEach(function (item) {
        return instance[item.key] = item.instance;
      });
    }
  };

  _proto.instantiateClass = function instantiateClass(instances, instanceHost, wrapper, targetMetatype, contextId) {
    if (contextId === void 0) {
      contextId = constants_2.STATIC_CONTEXT;
    }

    var type = wrapper.type,
        inject = wrapper.inject;

    if ((0, shared_utils_1.isNil)(inject)) {
      // instance by constructor
      instanceHost.instance = wrapper.forwardRef ? Object.assign(instanceHost.instance, _construct(type, instances)) : _construct(type, instances);
      return instanceHost.instance;
    } else {
      var factory = targetMetatype.factory;

      if (typeof factory === "object") {
        // instance by configuration
        var factoryClass = factory.factory,
            property = factory.property;
        var factoryWrapper = this.container.getProviderByType(factoryClass);

        if ((0, shared_utils_1.isNil)(factoryWrapper)) {
          throw new runtime_exception_1.RuntimeException("Instantiate factory provider failed, can not find factory instance(class: " + factoryClass.name + ") in container.");
        }

        return this.resolveInstance(factoryWrapper, contextId).then(function (factoryInstance) {
          var returnValue = factoryInstance[property].apply(factoryInstance, instances);

          if (returnValue === null || returnValue === undefined) {
            throw new runtime_exception_1.RuntimeException("Instantiate factory provider(name: " + String(wrapper.name) + ") failed, factory method return a null or undefined value.");
          }

          instanceHost.instance = returnValue;
          return returnValue;
        });
      } else {
        // instance by factory function
        var returnValue = factory.apply(void 0, instances);

        if (returnValue === null || returnValue === undefined) {
          throw new runtime_exception_1.RuntimeException("Instantiate factory provider(name: " + String(wrapper.name) + ") failed, factory method return a null or undefined value.");
        }

        instanceHost.instance = returnValue;
        return returnValue;
      }
    }
  };

  _proto.loadEnhancersPerContext = function loadEnhancersPerContext(wrapper, container, ctx) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _this5 = this;

      var enhancers, loadEnhancer;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              enhancers = wrapper.getEnhancersMetadata() || [];

              loadEnhancer = function loadEnhancer(item) {
                return _this5.loadInstance(item, ctx);
              };

              _context.next = 4;
              return Promise.all(enhancers.map(loadEnhancer));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  };

  _proto.loadCtorMetadata = function loadCtorMetadata(metadata, contextId) {
    var _this6 = this;

    return metadata.map(function (item) {
      return _this6.resolveInstance(item, contextId);
    });
  };

  _proto.loadPropertiesMetadata = function loadPropertiesMetadata(metadata, contextId) {
    var _this7 = this;

    return metadata.map(function (_ref) {
      var item = _ref.wrapper,
          key = _ref.key;

      var instanceRst = _this7.resolveInstance(item, contextId);

      return {
        key: key,
        name: key,
        isResolved: false,
        loadTask: instanceRst,
        instance: null
      };
    });
  };

  return Injector;
}();

__decorate([(0, hook_1.InjectHook)({
  async: false,
  parallel: false,
  type: hook_interface_1.HookType.Waterfall
}), __metadata("design:type", Object)], Injector.prototype, "componentAfterInitialize", void 0);

__decorate([(0, hook_1.InjectHook)({
  async: false,
  parallel: false,
  type: hook_interface_1.HookType.Waterfall
}), __metadata("design:type", Object)], Injector.prototype, "componentAfterPropertiesSet", void 0);

exports.Injector = Injector;

/***/ }),

/***/ 67163:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(3080);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InstanceLoader = void 0;

var logger_service_1 = __webpack_require__(23906);

var interfaces_1 = __webpack_require__(97116);

var constants_1 = __webpack_require__(30759);

var InstanceLoader = /*#__PURE__*/function () {
  function InstanceLoader(container, injector) {
    this.container = container;
    this.injector = injector;
    this.logger = new logger_service_1.Logger(InstanceLoader.name, true);
  }

  var _proto = InstanceLoader.prototype;

  _proto.createInstancesOfDependencies = function createInstancesOfDependencies(instanceWrappers) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _iterator, _step, wrapper;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // const wrappers = [] as ComponentWrapper[]
              for (_iterator = _createForOfIteratorHelperLoose(instanceWrappers); !(_step = _iterator()).done;) {
                wrapper = _step.value;
                // const wrapper = this.container.getProviderById(id)!;
                wrapper.createPrototype(constants_1.STATIC_CONTEXT); // wrappers.push(wrapper)
              }

              return _context.abrupt("return", this.createInstancesOfProviders(instanceWrappers));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  };

  _proto.createInstancesOfProviders = function createInstancesOfProviders(wrappers) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var promises, _iterator2, _step2, wrapper, provider;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              promises = [];
              _iterator2 = _createForOfIteratorHelperLoose(wrappers);

            case 2:
              if ((_step2 = _iterator2()).done) {
                _context2.next = 10;
                break;
              }

              wrapper = _step2.value;

              if (!(wrapper.scope !== interfaces_1.Scope.SINGLETON)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("continue", 8);

            case 6:
              provider = this.injector.loadProvider(wrapper);
              promises.push(provider);

            case 8:
              _context2.next = 2;
              break;

            case 10:
              return _context2.abrupt("return", Promise.all(promises));

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
  };

  return InstanceLoader;
}();

exports.InstanceLoader = InstanceLoader;

/***/ }),

/***/ 17499:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 88567:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 54747:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 83218:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isApplicationContextAwareComp = void 0;

function isApplicationContextAwareComp(comp) {
  return typeof (comp === null || comp === void 0 ? void 0 : comp.setApplicationContext) === "function";
}

exports.isApplicationContextAwareComp = isApplicationContextAwareComp;

/***/ }),

/***/ 98799:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isComponentInfoAwareComp = void 0;

function isComponentInfoAwareComp(comp) {
  return typeof (comp === null || comp === void 0 ? void 0 : comp.setProviderInfo) === "function";
}

exports.isComponentInfoAwareComp = isComponentInfoAwareComp;

/***/ }),

/***/ 56476:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isFactoryComponent = exports.isValueComponent = exports.isClassComponent = exports.isComponent = void 0;

function isComponent(provider) {
  var id = provider.id,
      useClass = provider.useClass,
      useValue = provider.useValue,
      useFactory = provider.useFactory;
  return typeof id != "undefined" && (typeof useClass !== "undefined" || typeof useValue !== "undefined" || typeof useFactory !== "undefined");
}

exports.isComponent = isComponent;

function isClassComponent(provider) {
  return typeof provider.useClass !== "undefined";
}

exports.isClassComponent = isClassComponent;

function isValueComponent(provider) {
  return typeof provider.useValue !== "undefined";
}

exports.isValueComponent = isValueComponent;

function isFactoryComponent(provider) {
  return typeof provider.useFactory !== "undefined";
}

exports.isFactoryComponent = isFactoryComponent;

/***/ }),

/***/ 27538:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Scope = void 0;
/**
 * @publicApi
 */

var Scope;

(function (Scope) {
  /**
   * The provider can be shared across multiple classes. The provider lifetime
   * is strictly tied to the application lifecycle. Once the application has
   * bootstrapped, all providers have been instantiated.
   */
  Scope["SINGLETON"] = "singleton";
  /**
   * A new private instance of the provider is instantiated for every use
   */

  Scope["PROTOTYPE"] = "prototype";
  /**
   * A new instance is instantiated for each request processing pipeline
   */

  Scope["REQUEST"] = "request";
})(Scope = exports.Scope || (exports.Scope = {}));

/***/ }),

/***/ 97116:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(17499), exports);

__exportStar(__webpack_require__(56476), exports);

__exportStar(__webpack_require__(98799), exports);

__exportStar(__webpack_require__(88567), exports);

__exportStar(__webpack_require__(27538), exports);

__exportStar(__webpack_require__(82918), exports);

__exportStar(__webpack_require__(9877), exports);

__exportStar(__webpack_require__(20778), exports);

__exportStar(__webpack_require__(54747), exports);

__exportStar(__webpack_require__(90015), exports);

/***/ }),

/***/ 20778:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EnuInjectBy = void 0;
var EnuInjectBy;

(function (EnuInjectBy) {
  EnuInjectBy["NAME"] = "NAME";
  EnuInjectBy["TYPE"] = "TYPE";
  EnuInjectBy["TYPE_NAME"] = "TYPE_NAME";
})(EnuInjectBy = exports.EnuInjectBy || (exports.EnuInjectBy = {}));

/***/ }),

/***/ 9877:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 90015:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JoyContextOptions = void 0;
/**
 * @publicApi
 */

var JoyContextOptions = function JoyContextOptions() {};

exports.JoyContextOptions = JoyContextOptions;

/***/ }),

/***/ 82918:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 63080:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(23906), exports);

/***/ }),

/***/ 23906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __param = this && this.__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

var Logger_1;
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Logger = exports.LogLevel = void 0;

var cli_color_1 = __importDefault(__webpack_require__(23692));

var component_decorator_1 = __webpack_require__(43042);

var optional_decorator_1 = __webpack_require__(36315);

var shared_utils_1 = __webpack_require__(1980);

var cyan = cli_color_1["default"].cyan; // export type LogLevel = 'log' | 'error' | 'warn' | 'debug' | 'verbose';

var LogLevel;

(function (LogLevel) {
  LogLevel["log"] = "log";
  LogLevel["error"] = "error";
  LogLevel["warn"] = "warn";
  LogLevel["debug"] = "debug";
  LogLevel["verbose"] = "verbose";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));

var Logger = Logger_1 = /*#__PURE__*/function () {
  function Logger(context, isTimestampEnabled) {
    if (isTimestampEnabled === void 0) {
      isTimestampEnabled = false;
    }

    this.context = context;
    this.isTimestampEnabled = isTimestampEnabled;
  }

  var _proto = Logger.prototype;

  _proto.error = function error(message, trace, context) {
    if (trace === void 0) {
      trace = "";
    }

    var instance = this.getInstance();

    if (!this.isLogLevelEnabled(LogLevel.error)) {
      return;
    }

    instance && instance.error.call(instance, message, trace, context || this.context);
  };

  _proto.log = function log(message, context) {
    this.callFunction(LogLevel.log, message, context);
  };

  _proto.warn = function warn(message, context) {
    this.callFunction(LogLevel.warn, message, context);
  };

  _proto.debug = function debug(message, context) {
    this.callFunction(LogLevel.debug, message, context);
  };

  _proto.verbose = function verbose(message, context) {
    this.callFunction(LogLevel.verbose, message, context);
  };

  Logger.overrideLogger = function overrideLogger(logger) {
    if (Array.isArray(logger)) {
      this.logLevels = logger;
      return;
    }

    this.instance = (0, shared_utils_1.isObject)(logger) ? logger : undefined;
  };

  Logger.log = function log(message, context, isTimeDiffEnabled) {
    if (context === void 0) {
      context = "";
    }

    if (isTimeDiffEnabled === void 0) {
      isTimeDiffEnabled = true;
    }

    this.printMessage(LogLevel.log, message, cli_color_1["default"].green, context, isTimeDiffEnabled);
  };

  Logger.error = function error(message, trace, context, isTimeDiffEnabled) {
    if (trace === void 0) {
      trace = "";
    }

    if (context === void 0) {
      context = "";
    }

    if (isTimeDiffEnabled === void 0) {
      isTimeDiffEnabled = true;
    }

    this.printMessage(LogLevel.error, message, cli_color_1["default"].red, context, isTimeDiffEnabled);
    this.printStackTrace(trace);
  };

  Logger.warn = function warn(message, context, isTimeDiffEnabled) {
    if (context === void 0) {
      context = "";
    }

    if (isTimeDiffEnabled === void 0) {
      isTimeDiffEnabled = true;
    }

    this.printMessage(LogLevel.warn, message, cli_color_1["default"].yellow, context, isTimeDiffEnabled);
  };

  Logger.debug = function debug(message, context, isTimeDiffEnabled) {
    if (context === void 0) {
      context = "";
    }

    if (isTimeDiffEnabled === void 0) {
      isTimeDiffEnabled = true;
    }

    this.printMessage(LogLevel.debug, message, cli_color_1["default"].magentaBright, context, isTimeDiffEnabled);
  };

  Logger.verbose = function verbose(message, context, isTimeDiffEnabled) {
    if (context === void 0) {
      context = "";
    }

    if (isTimeDiffEnabled === void 0) {
      isTimeDiffEnabled = true;
    }

    this.printMessage(LogLevel.verbose, message, cli_color_1["default"].cyanBright, context, isTimeDiffEnabled);
  };

  _proto.callFunction = function callFunction(name, message, context) {
    if (!this.isLogLevelEnabled(name)) {
      return;
    }

    var instance = this.getInstance();
    var func = instance && instance[name];
    func && func.call(instance, message, context || this.context, this.isTimestampEnabled);
  };

  _proto.getInstance = function getInstance() {
    var _Logger_ = Logger_1,
        instance = _Logger_.instance;

    if (!instance) {
      Logger_1.instance = Logger_1;
    }

    return instance === this ? Logger_1 : instance;
  };

  _proto.isLogLevelEnabled = function isLogLevelEnabled(level) {
    return Logger_1.logLevels.includes(level);
  };

  Logger.printMessage = function printMessage(logLevel, message, color, context, isTimeDiffEnabled) {
    if (context === void 0) {
      context = "";
    }

    var output = (0, shared_utils_1.isObject)(message) ? color("Object:") + "\n" + JSON.stringify(message, null, 2) + "\n" : color(message);
    var localeStringOptions = {
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      day: "2-digit",
      month: "2-digit",
      hour12: false
    };
    var timestamp = new Date(Date.now()).toLocaleString(undefined, localeStringOptions);
    var msgs = [];

    if (true) {
      // in browser
      msgs = msgs.concat([color("[Joy] " + logLevel + " - "), timestamp, "   ", context && cyan("[" + context + "] "), output, this.getTimestamp(isTimeDiffEnabled) || ""]);
      window.console.log(msgs.join(""));
    } else {}
  };

  Logger.getTimestamp = function getTimestamp(isTimeDiffEnabled) {
    var includeTimestamp = Logger_1.lastTimestamp && isTimeDiffEnabled;
    var rst;

    if (includeTimestamp) {
      rst = cyan(" +" + (Date.now() - (Logger_1.lastTimestamp || Date.now())) + "ms");
    }

    Logger_1.lastTimestamp = Date.now();
    return rst;
  };

  Logger.printStackTrace = function printStackTrace(trace) {
    if (!trace) {
      return;
    }

    if (true) {
      // in browser
      console.error(trace);
    } else {}
  };

  return Logger;
}();

Logger.logLevels = Object.values(LogLevel);
Logger = Logger_1 = __decorate([(0, component_decorator_1.Component)(), __param(0, (0, optional_decorator_1.Optional)()), __param(1, (0, optional_decorator_1.Optional)()), __metadata("design:paramtypes", [String, Object])], Logger);
exports.Logger = Logger;

/***/ }),

/***/ 61447:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.randomStringGenerator = void 0;

var v4_1 = __importDefault(__webpack_require__(83969));

var randomStringGenerator = function randomStringGenerator() {
  return (0, v4_1["default"])();
};

exports.randomStringGenerator = randomStringGenerator;

/***/ }),

/***/ 1980:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isPromise = exports.isSubClass = exports.isSymbol = exports.isEmpty = exports.isNil = exports.isConstructor = exports.isString = exports.isFunction = exports.validatePath = exports.isPlainObject = exports.isObject = exports.isUndefined = void 0;

var isUndefined = function isUndefined(obj) {
  return typeof obj === "undefined";
};

exports.isUndefined = isUndefined;

var isObject = function isObject(fn) {
  return !(0, exports.isNil)(fn) && typeof fn === "object";
};

exports.isObject = isObject; // eslint-disable-next-line @typescript-eslint/ban-types

var isPlainObject = function isPlainObject(fn) {
  if (!(0, exports.isObject)(fn)) {
    return false;
  }

  var proto = Object.getPrototypeOf(fn);

  if (proto === null) {
    return true;
  }

  var ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
};

exports.isPlainObject = isPlainObject;

var validatePath = function validatePath(path) {
  return path ? path.charAt(0) !== "/" ? "/" + path : path : "";
};

exports.validatePath = validatePath;

var isFunction = function isFunction(fn) {
  return typeof fn === "function";
};

exports.isFunction = isFunction;

var isString = function isString(fn) {
  return typeof fn === "string";
};

exports.isString = isString;

var isConstructor = function isConstructor(fn) {
  return fn === "constructor";
};

exports.isConstructor = isConstructor;

var isNil = function isNil(obj) {
  return (0, exports.isUndefined)(obj) || obj === null;
};

exports.isNil = isNil;

var isEmpty = function isEmpty(array) {
  return !(array && array.length > 0);
};

exports.isEmpty = isEmpty;

var isSymbol = function isSymbol(fn) {
  return typeof fn === "symbol";
};

exports.isSymbol = isSymbol;

var isSubClass = function isSubClass(classA, classB) {
  if (!(0, exports.isFunction)(classA) || !(0, exports.isFunction)(classB)) {
    return false;
  }

  var proto = Object.getPrototypeOf(classA);

  while (proto !== Function.prototype) {
    if (proto === classB) {
      return true;
    }

    proto = Object.getPrototypeOf(proto);
  }

  return false;
};

exports.isSubClass = isSubClass;

var isPromise = function isPromise(obj) {
  return obj instanceof Promise;
};

exports.isPromise = isPromise;

/***/ }),

/***/ 2052:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(83856);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TaskThenable = void 0;

var TaskThenable = /*#__PURE__*/function () {
  function TaskThenable(executor, isSync) {
    if (isSync === void 0) {
      isSync = true;
    }

    this._state = null;
    this._isSync = true;
    this.nextTasks = [];
    this.delegating = false;
    this.deferreds = [];
    if (!(this instanceof TaskThenable)) return new TaskThenable(executor, isSync);
    if (typeof executor !== "function") throw new TypeError("not a function");
    this._isSync = isSync; // eslint-disable-next-line @typescript-eslint/no-this-alias

    var self = this;

    function resolve(newValue) {
      if (self.delegating) return;
      resolve_(newValue);
    }

    function resolve_(newValue) {
      if (self._state !== null) return;

      try {
        //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
        if (newValue === self) throw new TypeError("A promise cannot be resolved with itself.");

        if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
          var then = newValue.then;

          if (typeof then === "function") {
            self.delegating = true;

            if (newValue instanceof Promise) {
              self.setAsync();
              self._value = newValue;
            } else if (newValue instanceof TaskThenable) {
              if (!newValue.isSync) {
                self.setAsync();
              }
            }

            then.call(newValue, resolve_, reject_);
            return;
          }
        }

        self._state = true;
        self._value = newValue;
        finale();
      } catch (e) {
        reject_(e);
      }
    }

    function reject(newValue) {
      if (self.delegating) return;
      reject_(newValue);
    }

    function reject_(newValue) {
      if (self._state !== null) return;
      self._state = false;
      self._value = newValue;
      finale();
    }

    function finale() {
      for (var i = 0, len = self.deferreds.length; i < len; i++) {
        self.handle(self.deferreds[i]);
      } // @ts-ignore


      self.deferreds = undefined;
    }

    try {
      executor(resolve, reject);
    } catch (e) {
      reject(e);
    }
  }

  var _proto = TaskThenable.prototype;

  _proto.then = function then(onfulfilled, onrejected) {
    var _this = this;

    var nextTask = new TaskThenable(function (resolve, reject) {
      _this.handle({
        onFulfilled: onfulfilled,
        onRejected: onrejected,
        resolve: resolve,
        reject: reject
      });
    }, this._isSync);
    this.nextTasks.push(nextTask);
    return nextTask;
  };

  _proto.getResult = function getResult() {
    var _this2 = this;

    if (this._isSync) {
      if (this._state === null) {
        throw new Error("[TaskThenable] state error, sync task must be has specific state.\n           maybe execute resolve() at a async thread, if the task run async model, please resolve a promise value.\n        ");
      }

      if (this._state) {
        return this._value;
      } else {
        if (this._value === undefined || this._value === null) {
          console.warn("[TaskThenable] unspecific error detail, ");
        }

        throw this._value;
      }
    } else {
      return new Promise(function (resolve1, reject1) {
        _this2.handle({
          resolve: resolve1,
          reject: reject1
        });
      });
    }
  };

  _proto.setAsync = function setAsync() {
    this._isSync = false;

    for (var i = 0, len = this.nextTasks.length; i < len; i++) {
      this.nextTasks[i].setAsync();
    }
  };

  _proto.handle = function handle(deferred) {
    if (this._state === null) {
      this.deferreds.push(deferred);
      return;
    }

    var cb = this._state ? deferred.onFulfilled : deferred.onRejected;

    if (typeof cb !== "function") {
      (this._state ? deferred.resolve : deferred.reject)(this._value);
      return;
    }

    var ret;

    try {
      ret = cb(this._value);
    } catch (e) {
      deferred.reject(e);
      return;
    }

    deferred.resolve(ret);
  };

  TaskThenable.all = function all(arr) {
    // TODO: this polyfill only supports array-likes
    //       it should support all iterables
    var args = Array.prototype.slice.call(arr);
    var isPreTaskSync = true;

    for (var i = 0; i < args.length; i++) {
      var t = args[i];

      if (t instanceof TaskThenable && !t.isSync) {
        isPreTaskSync = false;
        break;
      }
    }

    return new TaskThenable(function (resolve, reject) {
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        if (val && (typeof val === "object" || typeof val === "function")) {
          var then = val.then;

          if (typeof then === "function") {
            var isSync = val instanceof TaskThenable ? val.isSync : !(val instanceof Promise);

            if (!isSync) {// debugger
            }

            var p = new TaskThenable(then.bind(val), isSync);
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      }

      for (var _i = 0; _i < args.length; _i++) {
        res(_i, args[_i]);
      }
    }, isPreTaskSync);
  };

  TaskThenable.resolve = function resolve(value) {
    return new TaskThenable(function (resolve) {
      resolve(value);
    });
  };

  _createClass(TaskThenable, [{
    key: "state",
    get: function get() {
      return this._state;
    }
  }, {
    key: "isSync",
    get: function get() {
      return this._isSync;
    }
  }]);

  return TaskThenable;
}();

exports.TaskThenable = TaskThenable;

/***/ }),

/***/ 41145:
/***/ (function(module) {

"use strict";


var assign = Object.assign.bind(Object);
module.exports = assign;
module.exports["default"] = module.exports;

/***/ }),

/***/ 74950:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.noop = void 0;
exports.noop = "noop";

/***/ }),

/***/ 74074:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizePathTrailingSlash = exports.removePathTrailingSlash = void 0;
/**
 * Removes the trailing slash of a path if there is one. Preserves the root path `/`.
 */

function removePathTrailingSlash(path) {
  return path.endsWith("/") && path !== "/" ? path.slice(0, -1) : path;
}

exports.removePathTrailingSlash = removePathTrailingSlash;
/**
 * Normalizes the trailing slash of a path according to the `trailingSlash` option
 * in `joy.config.js`.
 */

exports.normalizePathTrailingSlash =  false ? 0 : removePathTrailingSlash;

/***/ }),

/***/ 75045:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AmpStateContext = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

exports.AmpStateContext = react_1["default"].createContext({});

if (false) {}

/***/ }),

/***/ 3005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.useAmp = exports.isInAmpMode = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

var amp_context_1 = __webpack_require__(75045);

function isInAmpMode(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

exports.isInAmpMode = isInAmpMode;

function useAmp() {
  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(react_1["default"].useContext(amp_context_1.AmpStateContext));
}

exports.useAmp = useAmp;

/***/ }),

/***/ 47050:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HeadManagerContext = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

exports.HeadManagerContext = react_1["default"].createContext({});

if (false) {}

/***/ }),

/***/ 98870:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Head = exports.defaultHead = void 0;

var react_1 = __importStar(__webpack_require__(2784));

var side_effect_1 = __importDefault(__webpack_require__(48961));

var amp_context_1 = __webpack_require__(75045);

var head_manager_context_1 = __webpack_require__(47050);

var amp_1 = __webpack_require__(3005);

function defaultHead(inAmpMode) {
  if (inAmpMode === void 0) {
    inAmpMode = false;
  }

  var head = [react_1["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push(react_1["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

exports.defaultHead = defaultHead;

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === "string" || typeof child === "number") {
    return list;
  } // Adds support for React.Fragment


  if (child.type === react_1["default"].Fragment) {
    var fragmentList = [];
    react_1["default"].Children.toArray(child.props.children).forEach(function (fragmentChild) {
      if (typeof fragmentChild === "string" || typeof fragmentChild === "number") {
        return;
      }

      fragmentList = fragmentList.concat(fragmentChild);
    });
    return list.concat(fragmentList);
  }

  return list.concat(child);
}

var METATYPES = ["name", "httpEquiv", "charSet", "itemProp"];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var isUnique = true;

    if (h.key && typeof h.key !== "number" && h.key.indexOf("$") > 0) {
      var key = h.key.slice(h.key.indexOf("$") + 1);

      if (keys.has(key)) {
        isUnique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case "title":
      case "base":
        if (tags.has(h.type)) {
          isUnique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case "meta":
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === "charSet") {
            if (metaTypes.has(metatype)) {
              isUnique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if (categories.has(category)) {
              isUnique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return isUnique;
  };
}
/**
 *
 * @param headElements List of multiple <Head> instances
 */


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = react_1["default"].Children.toArray(headElement.props.children);
    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;

    if (false) { var newProps; }

    return react_1["default"].cloneElement(c, {
      key: key
    });
  });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */


function Head(_ref) {
  var children = _ref.children;
  var ampState = (0, react_1.useContext)(amp_context_1.AmpStateContext);
  var headManager = (0, react_1.useContext)(head_manager_context_1.HeadManagerContext);
  return react_1["default"].createElement(side_effect_1["default"], {
    reduceComponentsToState: reduceComponents,
    headManager: headManager,
    inAmpMode: (0, amp_1.isInAmpMode)(ampState)
  }, children);
}

exports.Head = Head; // TODO: Remove in the next major release

Head.rewind = function () {//noop
}; // export default Head;

/***/ }),

/***/ 72606:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JoySSRContext = void 0;

var react_1 = __webpack_require__(2784);

exports.JoySSRContext = (0, react_1.createContext)(undefined);

/***/ }),

/***/ 98506:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*
MIT License

Copyright (c) Jason Miller (https://jasonformat.com/)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

exports["default"] = mitt;

/***/ }),

/***/ 44209:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(46913);

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markLoadingError = exports.resolveHref = exports.isLocalURL = exports.delBasePath = exports.addBasePath = exports.hasBasePath = void 0;

var normalize_trailing_slash_1 = __webpack_require__(74074);

var denormalize_page_path_1 = __webpack_require__(96438);

var mitt_1 = __importDefault(__webpack_require__(98506));

var utils_1 = __webpack_require__(73509);

var is_dynamic_1 = __webpack_require__(29631);

var parse_relative_url_1 = __webpack_require__(23190);

var querystring_1 = __webpack_require__(90892);

var resolve_rewrites_1 = __importDefault(__webpack_require__(74950));

var route_matcher_1 = __webpack_require__(8597);

var route_regex_1 = __webpack_require__(54733);

var basePath =  false || "";

function buildCancellationError() {
  return Object.assign(new Error("Route Cancelled"), {
    cancelled: true
  });
}

function hasBasePath(path) {
  return path === basePath || path.startsWith(basePath + "/");
}

exports.hasBasePath = hasBasePath;

function addBasePath(path) {
  // we only add the basepath on relative urls
  return basePath && path.startsWith("/") ? path === "/" ? (0, normalize_trailing_slash_1.normalizePathTrailingSlash)(basePath) : basePath + path : path;
}

exports.addBasePath = addBasePath;

function delBasePath(path) {
  return path.slice(basePath.length) || "/";
}

exports.delBasePath = delBasePath;
/**
 * Detects whether a given url is routable by the Joy.js router (browser only).
 */

function isLocalURL(url) {
  if (url.startsWith("/")) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, utils_1.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

exports.isLocalURL = isLocalURL;
/**
 * Resolves a given hyperlink with a certain router state (basePath not included).
 * Preserves absolute urls.
 */

function resolveHref(currentPath, href) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, "http://n");
  var urlAsString = typeof href === "string" ? href : (0, utils_1.formatWithValidation)(href);

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, normalize_trailing_slash_1.normalizePathTrailingSlash)(finalUrl.pathname); // if the origin didn't change, it means we received a relative href

    return finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
  } catch (_) {
    return urlAsString;
  }
}

exports.resolveHref = resolveHref;
var PAGE_LOAD_ERROR = Symbol("PAGE_LOAD_ERROR");

function markLoadingError(err) {
  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});
}

exports.markLoadingError = markLoadingError;

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  return {
    url: addBasePath(resolveHref(router.pathname, url)),
    as: as ? addBasePath(resolveHref(router.pathname, as)) : as
  };
}

var manualScrollRestoration = (/* unused pure expression or super */ null && ( false && 0));

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Joy.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: "same-origin"
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchJoyData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      markLoadingError(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  function Router(pathname, query, as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        initialStyleSheets = _ref.initialStyleSheets,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;
    // Static Data Cache
    this.sdc = {};

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname = _this.pathname,
            _query = _this.query;

        _this.changeState("replaceState", (0, utils_1.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, utils_1.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var url = state.url,
          as = state.as,
          options = state.options;

      var _ref2 = (0, parse_relative_url_1.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change("replaceState", url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow
      }));
    }; // represents the current component key


    this.route = (0, normalize_trailing_slash_1.removePathTrailingSlash)(pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (pathname !== "/_error") {
      this.components[this.route] = {
        // Component,
        styleSheets: initialStyleSheets,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components["/_app"] = {
      // Component: App as ComponentType,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = pathname;
    this.query = query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, is_dynamic_1.isDynamicRoute)(pathname) && __JOY_DATA__.autoExport ? pathname : as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (as.substr(0, 2) !== "//") {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState("replaceState", (0, utils_1.formatWithValidation)({
          pathname: addBasePath(pathname),
          query: query
        }), (0, utils_1.getURL)());
      }

      window.addEventListener("popstate", this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) { var debouncedScrollSave, scrollDebounceTimeout; }
    }
  }

  var _proto = Router.prototype;

  _proto.reload = function reload() {
    window.location.reload();
  }
  /**
   * Go back in history
   */
  ;

  _proto.back = function back() {
    window.history.back();
  }
  /**
   * Performs a `pushState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */
  ;

  _proto.push = function push(url, as, options) {
    if (as === void 0) {
      as = url;
    }

    if (options === void 0) {
      options = {};
    }

    var _prepareUrlAs = prepareUrlAs(this, url, as);

    url = _prepareUrlAs.url;
    as = _prepareUrlAs.as;
    return this.change("pushState", url, as, options);
  }
  /**
   * Performs a `replaceState` with arguments
   * @param url of the route
   * @param as masks `url` for the browser
   * @param options object you can define `shallow` and other options
   */
  ;

  _proto.replace = function replace(url, as, options) {
    if (as === void 0) {
      as = url;
    }

    if (options === void 0) {
      options = {};
    }

    var _prepareUrlAs2 = prepareUrlAs(this, url, as);

    url = _prepareUrlAs2.url;
    as = _prepareUrlAs2.as;
    return this.change("replaceState", url, as, options);
  };

  _proto.change = function change(method, url, as, options) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var _this2 = this;

      var cleanedAs, pages, _yield$this$pageLoade, rewrites, parsed, _parsed, pathname, searchParams, query, route, _options$shallow, shallow, resolvedAs, _ref3, asPathname, routeRegex, routeMatch, missingParams, routeInfo, error;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (isLocalURL(url)) {
                _context.next = 3;
                break;
              }

              window.location.href = url;
              return _context.abrupt("return", false);

            case 3:
              if (!options._h) {
                this.isSsr = false;
              } // marking route changes as a navigation start entry


              if (utils_1.ST) {
                performance.mark("routeChange");
              }

              if (this._inFlightRoute) {
                this.abortComponentLoad(this._inFlightRoute);
              }

              cleanedAs = hasBasePath(as) ? delBasePath(as) : as;
              this._inFlightRoute = as; // If the url change is only related to a hash change
              // We should not proceed. We should only change the state.
              // WARNING: `_h` is an internal option for handing Joy.js client-side
              // hydration. Your app should _never_ use this property. It may change at
              // any time without notice.

              if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                _context.next = 16;
                break;
              }

              this.asPath = cleanedAs;
              Router.events.emit("hashChangeStart", as); // TODO: do we need the resolved href when only a hash change?

              this.changeState(method, url, as, options);
              this.scrollToHash(cleanedAs);
              this.notify(this.components[this.route]);
              Router.events.emit("hashChangeComplete", as);
              return _context.abrupt("return", true);

            case 16:
              _context.next = 18;
              return this.pageLoader.getPageList();

            case 18:
              pages = _context.sent;
              _context.next = 21;
              return this.pageLoader.promisedBuildManifest;

            case 21:
              _yield$this$pageLoade = _context.sent;
              rewrites = _yield$this$pageLoade.__rewrites;
              parsed = (0, parse_relative_url_1.parseRelativeUrl)(url);
              _parsed = parsed, pathname = _parsed.pathname, searchParams = _parsed.searchParams;
              parsed = this._resolveHref(parsed, pages);

              if (parsed.pathname !== pathname) {
                pathname = parsed.pathname;
                url = (0, utils_1.formatWithValidation)(parsed);
              }

              query = (0, querystring_1.searchParamsToUrlQuery)(searchParams); // url and as should always be prefixed with basePath by this
              // point by either joy/link or router.push/replace so strip the
              // basePath from the pathname to match the pages dir 1-to-1

              pathname = pathname ? (0, normalize_trailing_slash_1.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
              // (not location.reload() but reload getInitialProps and other Joy.js stuffs)
              // We also need to set the method = replaceState always
              // as this should not go into the history (That's how browsers work)
              // We should compare the new asPath to the current asPath, not the url

              if (!this.urlIsNew(cleanedAs)) {
                method = "replaceState";
              }

              route = (0, normalize_trailing_slash_1.removePathTrailingSlash)(pathname);
              _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow; // we need to resolve the as value using rewrites for dynamic SSG
              // pages to allow building the data URL correctly

              resolvedAs = as;

              if (false) {}

              resolvedAs = delBasePath(resolvedAs);

              if (!(0, is_dynamic_1.isDynamicRoute)(route)) {
                _context.next = 47;
                break;
              }

              _ref3 = (0, parse_relative_url_1.parseRelativeUrl)(resolvedAs), asPathname = _ref3.pathname;
              routeRegex = (0, route_regex_1.getRouteRegex)(route);
              routeMatch = (0, route_matcher_1.getRouteMatcher)(routeRegex)(asPathname);

              if (routeMatch) {
                _context.next = 46;
                break;
              }

              missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                return !query[param];
              });

              if (!(missingParams.length > 0)) {
                _context.next = 44;
                break;
              }

              if (false) {}

              throw new Error("The provided `as` value (" + asPathname + ") is incompatible with the `href` value (" + route + "). ");

            case 44:
              _context.next = 47;
              break;

            case 46:
              // Merge params into `query`, overwriting any specified in search
              Object.assign(query, routeMatch);

            case 47:
              Router.events.emit("routeChangeStart", as);
              _context.prev = 48;
              _context.next = 51;
              return this.getRouteInfo(route, pathname, query, as, shallow);

            case 51:
              routeInfo = _context.sent;
              error = routeInfo.error;
              Router.events.emit("beforeHistoryChange", as);
              this.changeState(method, url, as, options);

              if (false) {}

              _context.next = 58;
              return this.set(route, pathname, query, cleanedAs, routeInfo)["catch"](function (e) {
                if (e.cancelled) error = error || e;else throw e;
              });

            case 58:
              if (!error) {
                _context.next = 61;
                break;
              }

              Router.events.emit("routeChangeError", error, cleanedAs);
              throw error;

            case 61:
              if (false) {}

              Router.events.emit("routeChangeComplete", as);
              return _context.abrupt("return", true);

            case 66:
              _context.prev = 66;
              _context.t0 = _context["catch"](48);

              if (!_context.t0.cancelled) {
                _context.next = 70;
                break;
              }

              return _context.abrupt("return", false);

            case 70:
              throw _context.t0;

            case 71:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[48, 66]]);
    }));
  };

  _proto.changeState = function changeState(method, url, as, options) {
    if (options === void 0) {
      options = {};
    }

    if (false) {}

    if (method !== "pushState" || (0, utils_1.getURL)() !== as) {
      this._shallow = options.shallow;
      window.history[method]({
        url: url,
        as: as,
        options: options,
        __N: true
      }, // Most browsers currently ignores this parameter, although they may use it in the future.
      // Passing the empty string here should be safe against future changes to the method.
      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
      "", as);
    }
  };

  _proto.handleRouteInfoError = function handleRouteInfoError(err, pathname, query, as, loadErrorFail) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _yield$this$fetchComp, Component, styleSheets, routeInfo;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!err.cancelled) {
                _context2.next = 2;
                break;
              }

              throw err;

            case 2:
              if (!(PAGE_LOAD_ERROR in err || loadErrorFail)) {
                _context2.next = 6;
                break;
              }

              Router.events.emit("routeChangeError", err, as); // If we can't load the page it could be one of following reasons
              //  1. Page doesn't exists
              //  2. Page does exist in a different zone
              //  3. Internal error while loading the page
              // So, doing a hard reload is the proper way to deal with this.

              window.location.href = as; // Changing the URL doesn't block executing the current code path.
              // So let's throw a cancellation error stop the routing logic.

              throw buildCancellationError();

            case 6:
              _context2.prev = 6;
              _context2.next = 9;
              return this.fetchComponent("/_error");

            case 9:
              _yield$this$fetchComp = _context2.sent;
              Component = _yield$this$fetchComp.page;
              styleSheets = _yield$this$fetchComp.styleSheets;
              routeInfo = {
                // Component,
                styleSheets: styleSheets,
                err: err,
                error: err
              };
              _context2.prev = 13;
              _context2.next = 16;
              return this.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              });

            case 16:
              routeInfo.props = _context2.sent;
              _context2.next = 23;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](13);
              console.error("Error in error page `getInitialProps`: ", _context2.t0);
              routeInfo.props = {};

            case 23:
              return _context2.abrupt("return", routeInfo);

            case 26:
              _context2.prev = 26;
              _context2.t1 = _context2["catch"](6);
              return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, true));

            case 29:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[6, 26], [13, 19]]);
    }));
  };

  _proto.getRouteInfo = function getRouteInfo(route, pathname, query, as, shallow) {
    if (shallow === void 0) {
      shallow = false;
    }

    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
  };

  _proto.set = function set(route, pathname, query, as, data) {
    this.isFallback = false;
    this.route = route;
    this.pathname = pathname;
    this.query = query;
    this.asPath = as;
    return this.notify(data);
  }
  /**
   * Callback to execute before replacing router state
   * @param cb callback to be executed
   */
  ;

  _proto.beforePopState = function beforePopState(cb) {
    this._bps = cb;
  };

  _proto.onlyAHashChange = function onlyAHashChange(as) {
    if (!this.asPath) return false;

    var _this$asPath$split = this.asPath.split("#"),
        oldUrlNoHash = _this$asPath$split[0],
        oldHash = _this$asPath$split[1];

    var _as$split = as.split("#"),
        newUrlNoHash = _as$split[0],
        newHash = _as$split[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
      return true;
    } // If the urls are change, there's more than a hash change


    if (oldUrlNoHash !== newUrlNoHash) {
      return false;
    } // If the hash has changed, then it's a hash only change.
    // This check is necessary to handle both the enter and
    // leave hash === '' cases. The identity case falls through
    // and is treated as a next reload.


    return oldHash !== newHash;
  };

  _proto.scrollToHash = function scrollToHash(as) {
    var _as$split2 = as.split("#"),
        hash = _as$split2[1]; // Scroll to top if the hash is just `#` with no value


    if (hash === "") {
      window.scrollTo(0, 0);
      return;
    } // First we check if the element by id is found


    var idEl = document.getElementById(hash);

    if (idEl) {
      idEl.scrollIntoView();
      return;
    } // If there's no element with the id, we check the `name` property
    // To mirror browsers


    var nameEl = document.getElementsByName(hash)[0];

    if (nameEl) {
      nameEl.scrollIntoView();
    }
  };

  _proto.urlIsNew = function urlIsNew(asPath) {
    return this.asPath !== asPath;
  };

  _proto._resolveHref = function _resolveHref(parsedHref, pages) {
    var pathname = parsedHref.pathname;
    var cleanPathname = (0, denormalize_page_path_1.denormalizePagePath)(delBasePath(pathname));

    if (cleanPathname === "/404" || cleanPathname === "/_error") {
      return parsedHref;
    } // handle resolving href for dynamic routes


    if (!pages.includes(cleanPathname)) {
      // eslint-disable-next-line array-callback-return
      pages.some(function (page) {
        if ((0, is_dynamic_1.isDynamicRoute)(page) && (0, route_regex_1.getRouteRegex)(page).re.test(cleanPathname)) {
          parsedHref.pathname = addBasePath(page);
          return true;
        }
      });
    }

    return parsedHref;
  }
  /**
   * Prefetch page code, you may wait for the data during page rendering.
   * This feature only works in production!
   * @param url the href of prefetched page
   * @param asPath the as path of the prefetched page
   */
  ;

  _proto.prefetch = function prefetch(url, asPath, options) {
    if (asPath === void 0) {
      asPath = url;
    }

    if (options === void 0) {
      options = {};
    }

    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
      var parsed, _parsed2, pathname, pages, route;

      return _regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              parsed = (0, parse_relative_url_1.parseRelativeUrl)(url);
              _parsed2 = parsed, pathname = _parsed2.pathname;
              _context4.next = 4;
              return this.pageLoader.getPageList();

            case 4:
              pages = _context4.sent;
              parsed = this._resolveHref(parsed, pages);

              if (parsed.pathname !== pathname) {
                pathname = parsed.pathname;
                url = (0, utils_1.formatWithValidation)(parsed);
              } // Prefetch is not supported in development mode because it would trigger on-demand-entries


              if (true) {
                _context4.next = 9;
                break;
              }

              return _context4.abrupt("return");

            case 9:
              route = (0, normalize_trailing_slash_1.removePathTrailingSlash)(pathname);
              _context4.next = 12;
              return Promise.all([this.pageLoader.prefetchData(url, asPath), this.pageLoader[options.priority ? "loadPage" : "prefetch"](route)]);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));
  };

  _proto.fetchComponent = function fetchComponent(route) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
      var cancelled, cancel, componentResult, error;
      return _regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              cancelled = false;

              cancel = this.clc = function () {
                cancelled = true;
              };

              _context5.next = 4;
              return this.pageLoader.loadPage(route);

            case 4:
              componentResult = _context5.sent;

              if (!cancelled) {
                _context5.next = 9;
                break;
              }

              error = new Error("Abort fetching component for route: \"" + route + "\"");
              error.cancelled = true;
              throw error;

            case 9:
              if (cancel === this.clc) {
                this.clc = null;
              }

              return _context5.abrupt("return", componentResult);

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));
  };

  _proto._getData = function _getData(fn) {
    var _this3 = this;

    var cancelled = false;

    var cancel = function cancel() {
      cancelled = true;
    };

    this.clc = cancel;
    return fn().then(function (data) {
      if (cancel === _this3.clc) {
        _this3.clc = null;
      }

      if (cancelled) {
        var err = new Error("DynamicLoading initial props cancelled");
        err.cancelled = true;
        throw err;
      }

      return data;
    });
  };

  _proto._getStaticData = function _getStaticData(dataHref) {
    var _this4 = this;

    var _URL = new URL(dataHref, window.location.href),
        cacheKey = _URL.href;

    if ( true && this.sdc[cacheKey]) {
      return Promise.resolve(this.sdc[cacheKey]);
    }

    return fetchJoyData(dataHref, this.isSsr).then(function (data) {
      _this4.sdc[cacheKey] = data;
      return data;
    });
  };

  _proto._getServerData = function _getServerData(dataHref) {
    return fetchJoyData(dataHref, this.isSsr);
  };

  _proto.getInitialProps = function getInitialProps(Component, ctx) {// const { Component: App } = this.components["/_app"];
    // const AppTree = this._wrapApp(App as AppComponent);
    // ctx.AppTree = AppTree;
    // return loadGetInitialProps<AppContextType<Router>>(App, {
    //   AppTree,
    //   Component,
    //   router: this,
    //   ctx,
    // });
  };

  _proto.abortComponentLoad = function abortComponentLoad(as) {
    if (this.clc) {
      Router.events.emit("routeChangeError", buildCancellationError(), as);
      this.clc();
      this.clc = null;
    }
  };

  _proto.notify = function notify(data) {// return this.sub(data, this.components["/_app"].Component as AppComponent);
  };

  return Router;
}();

exports["default"] = Router;
Router.events = (0, mitt_1["default"])();

/***/ }),

/***/ 23153:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
 // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.formatUrl = void 0;

var querystring = __importStar(__webpack_require__(90892));

var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || "";
  var pathname = urlObj.pathname || "";
  var hash = urlObj.hash || "";
  var query = urlObj.query || "";
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(":") ? "[" + hostname + "]" : hostname);

    if (urlObj.port) {
      host += ":" + urlObj.port;
    }
  }

  if (query && typeof query === "object") {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":") protocol += ":";

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname[0] !== "/") pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }

  if (hash && hash[0] !== "#") hash = "#" + hash;
  if (search && search[0] !== "?") search = "?" + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace("#", "%23");
  return "" + protocol + host + pathname + search + hash;
}

exports.formatUrl = formatUrl;

/***/ }),

/***/ 29631:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isDynamicRoute = void 0; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
var TEST_ROUTE_1 = /\/:[^/]+?(?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route) || TEST_ROUTE_1.test(route);
}

exports.isDynamicRoute = isDynamicRoute;

/***/ }),

/***/ 23190:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseRelativeUrl = void 0;

var utils_1 = __webpack_require__(73509);

var DUMMY_BASE = new URL( false ? 0 : (0, utils_1.getLocationOrigin)());
/**
 * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
 * (e.g. `./hello`) then at least base must be.
 * Absolute urls are rejected with one exception, in the browser, absolute urls that are on
 * the current origin will be parsed as relative
 */

function parseRelativeUrl(url, base) {
  var resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin,
      protocol = _URL.protocol;

  if (origin !== DUMMY_BASE.origin || protocol !== "http:" && protocol !== "https:") {
    throw new Error("invariant: invalid relative URL");
  }

  return {
    pathname: pathname,
    searchParams: searchParams,
    search: search,
    hash: hash,
    href: href.slice(DUMMY_BASE.origin.length)
  };
}

exports.parseRelativeUrl = parseRelativeUrl;

/***/ }),

/***/ 90892:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assign = exports.urlQueryToSearchParams = exports.searchParamsToUrlQuery = void 0;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === "undefined") {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

exports.searchParamsToUrlQuery = searchParamsToUrlQuery;

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var key = _ref[0],
        value = _ref[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, item);
      });
    } else {
      result.set(key, value);
    }
  });
  return result;
}

exports.urlQueryToSearchParams = urlQueryToSearchParams;

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    // @ts-ignore
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    }); // @ts-ignore

    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

exports.assign = assign;

/***/ }),

/***/ 8597:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getRouteMatcher = void 0;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error("failed to decode param");
        err.code = "DECODE_FAILED";
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf("/") ? m.split("/").map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

exports.getRouteMatcher = getRouteMatcher;

/***/ }),

/***/ 54733:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getRouteRegex = void 0; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&");
}

function parseParameter(param) {
  var optional = param.startsWith("[") && param.endsWith("]");

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith("...");

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, "") || "/").slice(1).split("/");
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith("[") && segment.endsWith("]")) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
    } else {
      return "/" + escapeRegex(segment);
    }
  }).join(""); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^" + parameterizedRoute + "(?:/)?$"),
    groups: groups
  };
}

exports.getRouteRegex = getRouteRegex;

/***/ }),

/***/ 48961:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _assertThisInitialized = __webpack_require__(99270);

var _inheritsLoose = __webpack_require__(75155);

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var react_1 = __webpack_require__(2784);

var isServer = false;

var default_1 = /*#__PURE__*/function (_react_1$Component) {
  _inheritsLoose(default_1, _react_1$Component);

  function default_1(props) {
    var _this;

    _this = _react_1$Component.call(this, props) || this;

    _this.emitChange = function () {
      if (_this._hasHeadManager) {
        _this.props.headManager.updateHead(_this.props.reduceComponentsToState(Array.from(_this.props.headManager.mountedInstances), _this.props));
      }
    };

    _this._hasHeadManager = _this.props.headManager && _this.props.headManager.mountedInstances;

    if (isServer && _this._hasHeadManager) {
      _this.props.headManager.mountedInstances.add(_assertThisInitialized(_this));

      _this.emitChange();
    }

    return _this;
  }

  var _proto = default_1.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances.add(this);
    }

    this.emitChange();
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.emitChange();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this._hasHeadManager) {
      this.props.headManager.mountedInstances["delete"](this);
    }

    this.emitChange();
  };

  _proto.render = function render() {
    return null;
  };

  return default_1;
}(react_1.Component);

exports["default"] = default_1;

/***/ }),

/***/ 73509:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(46913);

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ST = exports.SP = exports.formatWithValidation = exports.urlObjectKeys = exports.loadGetInitialProps = exports.isResSent = exports.getDisplayName = exports.getURL = exports.getLocationOrigin = exports.execOnce = void 0;

var format_url_1 = __webpack_require__(23153);
/**
 * Utils
 */


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

exports.execOnce = execOnce;

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return protocol + "//" + hostname + (port ? ":" + port : "");
}

exports.getLocationOrigin = getLocationOrigin;

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

exports.getURL = getURL;

function getDisplayName(Component) {
  return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
}

exports.getDisplayName = getDisplayName;

function isResSent(res) {
  return res.finished || res.headersSent;
}

exports.isResSent = isResSent;

function loadGetInitialProps(App, ctx) {
  var _a;

  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (true) {
              _context.next = 4;
              break;
            }

            if (!((_a = App.prototype) === null || _a === void 0 ? void 0 : _a.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"" + getDisplayName(App) + ".getInitialProps()\" is defined as an instance method";
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"" + getDisplayName(App) + ".getInitialProps()\" should resolve to an object. But found \"" + props + "\" instead.";
            throw new Error(_message);

          case 20:
            if (false) {}

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
}

exports.loadGetInitialProps = loadGetInitialProps;
exports.urlObjectKeys = ["auth", "hash", "host", "hostname", "href", "path", "pathname", "port", "protocol", "query", "search", "slashes"];

function formatWithValidation(url) {
  if (false) {}

  return (0, format_url_1.formatUrl)(url);
}

exports.formatWithValidation = formatWithValidation;
exports.SP = typeof performance !== "undefined";
exports.ST = exports.SP && typeof performance.mark === "function" && typeof performance.measure === "function";

/***/ }),

/***/ 96438:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.denormalizePagePath = exports.normalizePathSep = void 0;

function normalizePathSep(path) {
  return path.replace(/\\/g, "/");
}

exports.normalizePathSep = normalizePathSep;

function denormalizePagePath(page) {
  page = normalizePathSep(page);

  if (page.startsWith("/index/")) {
    page = page.slice(6);
  } else if (page === "/index") {
    page = "/";
  }

  return page;
}

exports.denormalizePagePath = denormalizePagePath;

/***/ }),

/***/ 29540:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(75155);

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.App = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

var router_dom_1 = __webpack_require__(99092);

var App = /*#__PURE__*/function (_react_1$default$Comp) {
  _inheritsLoose(App, _react_1$default$Comp);

  function App(props, context) {
    var _this;

    _this = _react_1$default$Comp.call(this, props, context) || this;
    var appContext = props.appContext;
    _this.reactRouter = appContext.getSync("reactRouterService");
    return _this;
  }

  var _proto = App.prototype;

  _proto.getRoutes = function getRoutes() {
    return this.reactRouter.getRoutes() || [];
  };

  _proto.render = function render() {
    var routes = this.getRoutes();
    return react_1["default"].createElement(router_dom_1.RoutesRenderer, {
      routes: routes
    });
  };

  return App;
}(react_1["default"].Component);

exports.App = App;
exports["default"] = App;

/***/ }),

/***/ 61583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(75155);

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ErrorComponent = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

var head_1 = __webpack_require__(98870);

var joy_ssr_react_context_1 = __webpack_require__(72606);

var react_2 = __webpack_require__(27894);

var statusCodes = {
  400: "Bad Request",
  404: "This page could not be found",
  405: "Method Not Allowed",
  500: "Internal Server Error"
};
/**
 * `Error` component used for handling errors.
 */

var ErrorComponent = /*#__PURE__*/function (_react_1$default$Comp) {
  _inheritsLoose(ErrorComponent, _react_1$default$Comp);

  function ErrorComponent() {
    return _react_1$default$Comp.apply(this, arguments) || this;
  }

  var _proto = ErrorComponent.prototype;

  _proto.getErrorObject = function getErrorObject() {
    var _a, _b, _c;

    var err = this.props.err || ((_a = this.context) === null || _a === void 0 ? void 0 : _a.err);
    var statusCode = this.props.statusCode || (err === null || err === void 0 ? void 0 : err.statusCode) || ((_c = (_b = this.context) === null || _b === void 0 ? void 0 : _b.res) === null || _c === void 0 ? void 0 : _c.statusCode) || 404;
    var title = this.props.title || (err === null || err === void 0 ? void 0 : err.message) || statusCodes[statusCode] || "An unexpected error has occurred";
    return {
      statusCode: statusCode,
      title: title
    };
  };

  _proto.render = function render() {
    var errObj = this.getErrorObject();
    return this.renderView(errObj);
  };

  _proto.renderView = function renderView(_ref) {
    var statusCode = _ref.statusCode,
        title = _ref.title;
    return react_1["default"].createElement("div", {
      style: styles.error
    }, react_1["default"].createElement(head_1.Head, null, react_1["default"].createElement("title", null, statusCode, ": ", title)), react_1["default"].createElement("div", null, react_1["default"].createElement("style", {
      dangerouslySetInnerHTML: {
        __html: "body { margin: 0 }"
      }
    }), statusCode ? react_1["default"].createElement("h1", {
      style: styles.h1
    }, statusCode) : null, react_1["default"].createElement("div", {
      style: styles.desc
    }, react_1["default"].createElement("h2", {
      style: styles.h2
    }, title, "."))));
  };

  return ErrorComponent;
}(react_1["default"].Component);

ErrorComponent.displayName = "ErrorPage";
ErrorComponent.contextType = joy_ssr_react_context_1.JoySSRContext;
ErrorComponent = __decorate([(0, react_2.ReactComponent)({
  name: "joyErrorComponent"
})], ErrorComponent);
exports.ErrorComponent = ErrorComponent;
var styles = {
  error: {
    color: "#000",
    background: "#fff",
    fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, "Segoe UI", "Fira Sans", Avenir, "Helvetica Neue", "Lucida Grande", sans-serif',
    height: "100vh",
    textAlign: "center",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center"
  },
  desc: {
    display: "inline-block",
    textAlign: "left",
    lineHeight: "49px",
    height: "49px",
    verticalAlign: "middle"
  },
  h1: {
    display: "inline-block",
    borderRight: "1px solid rgba(0, 0, 0,.3)",
    margin: 0,
    marginRight: "20px",
    padding: "10px 23px 10px 0",
    fontSize: "24px",
    fontWeight: 500,
    verticalAlign: "top"
  },
  h2: {
    fontSize: "14px",
    fontWeight: "normal",
    lineHeight: "inherit",
    margin: 0,
    padding: 0
  }
};
exports["default"] = ErrorComponent;

/***/ }),

/***/ 98154:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(98152);

var _inheritsLoose = __webpack_require__(81660);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseReactController = void 0;

var react_1 = __webpack_require__(2784);

var react_app_container_1 = __webpack_require__(30739);

var react_redux_service_1 = __webpack_require__(21094);

var base_react_model_1 = __webpack_require__(19900);

var react_route_decorator_1 = __webpack_require__(85067);

var core_1 = __webpack_require__(16134);

var react_app_init_manager_1 = __webpack_require__(66965);

var react_controller_decorator_1 = __webpack_require__(23414);
/**
 * todo model 状态发生改变后，如何精细的判断是否有必要刷新组件？
 */


var BaseReactController = /*#__PURE__*/function (_react_1$Component) {
  _inheritsLoose(BaseReactController, _react_1$Component);

  function BaseReactController(props, context) {
    var _this;

    _this = _react_1$Component.call(this, props, context) || this;
    _this.hasInitInvoked = false;
    _this.hasInjectProps = false;
    _this.isRendingView = false;
    _this.modelStateDeps = {};
    _this.isWaitingInitStaticDid = true;

    _this.modelStateListener = function (models, nextState, previousState) {
      if (!_this.isCtlMounted) {
        return;
      }

      var hasStateChange = models.map(function (ns) {
        var nextModelState = nextState[ns];
        var preModelState = previousState[ns];
        return _this.isModelStateChange(ns, nextModelState, preModelState);
      }).reduce(function (previousValue, currentValue) {
        return previousValue || currentValue;
      });

      if (hasStateChange) {
        _this.setState({
          // @ts-ignore
          _modelStateVersion: _this.state._modelStateVersion + 1
        });
      }
    };

    _this.isModelStateChange = function (modelNameSpace, nextModelState, preModelState) {
      if (modelNameSpace === _this.initManager.getNamespace()) {
        if (!_this.props.match) {
          return false;
        }

        var matchedUrl = _this.props.match.pathname;
        var nextInitState = nextModelState[matchedUrl];
        var preInitState = preModelState[matchedUrl];

        if (_this.isWaitingInitStaticDid && (nextInitState === null || nextInitState === void 0 ? void 0 : nextInitState.initStatic) === react_app_init_manager_1.ReactRouteInitStatus.SUCCESS) {
          _this.triggerOnInitialModelStaticStateDid();
        }

        return (nextInitState === null || nextInitState === void 0 ? void 0 : nextInitState.initStatic) !== (preInitState === null || preInitState === void 0 ? void 0 : preInitState.initStatic) || (nextInitState === null || nextInitState === void 0 ? void 0 : nextInitState.init) !== (preInitState === null || preInitState === void 0 ? void 0 : preInitState.init);
      } else {
        var depProps = _this.modelStateDeps[modelNameSpace];

        if (!(depProps === null || depProps === void 0 ? void 0 : depProps.length)) {
          return false;
        }

        for (var _iterator = _createForOfIteratorHelperLoose(depProps), _step; !(_step = _iterator()).done;) {
          var depProp = _step.value;

          if (!preModelState || !nextModelState || preModelState[depProp] !== nextModelState[depProp]) {
            return true;
          }
        }

        return false;
      }
    };

    _this.isCtlMounted = false;
    var contextValues = props.__ctx_values;

    if (contextValues) {
      for (var _i = 0, _Object$keys = Object.keys(contextValues); _i < _Object$keys.length; _i++) {
        var propKey = _Object$keys[_i];
        _this[propKey] = contextValues[propKey];
      }
    }

    _this.reduxStore = _this.appContext.getSync(react_redux_service_1.ReactReduxService);
    return _this;
  }
  /**
   * 向后兼容：
   * 进行组件渲染的的准备工作，可以在服务端和浏览器上运行,
   * @param context
   */


  var _proto = BaseReactController.prototype;

  _proto.componentPrepare = function componentPrepare(context) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
  };

  _proto.prepareComponent = function prepareComponent() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
  };

  _proto._patch_shouldComponentUpdate = function _patch_shouldComponentUpdate(nextProps, nextState, nextContext) {
    this.bindProps(nextProps);
    return true;
  };

  _proto._patch_pre_componentDidMount = function _patch_pre_componentDidMount() {
    this.isCtlMounted = true;

    var _this$getInitState = this.getInitState(),
        initStatic = _this$getInitState.initStatic;

    if (this.isWaitingInitStaticDid && initStatic === react_app_init_manager_1.ReactRouteInitStatus.SUCCESS) {
      this.triggerOnInitialModelStaticStateDid();
    }
  };

  _proto._patch_componentWillUnmount = function _patch_componentWillUnmount() {
    var _a;

    this.isCtlMounted = false;
    var pathname = ((_a = this.props.match) === null || _a === void 0 ? void 0 : _a.pathname) || this.location.pathname;
    this.initManager.unregisterRouteController(pathname, this);

    if (this._models) {
      this.reduxStore.rmModelStateListener(this._models.map(function (it) {
        return it.getNamespace();
      }), this.modelStateListener);
    }

    this.initManager.resetInitState(pathname);
  };

  _proto.bindProps = function bindProps(props) {
    this.location = this.props.location;
    (0, react_route_decorator_1.bindRouteFromCompProps)(this, props);
  };

  _proto.triggerOnInitialModelStaticStateDid = function triggerOnInitialModelStaticStateDid() {
    this.isWaitingInitStaticDid = false;

    if ( true && typeof this.onInitialModelStaticStateDid === "function") {
      this.onInitialModelStaticStateDid();
    }
  };

  _proto.init = function init() {
    var _a;

    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      var pathname;
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.hasInitInvoked) {
                _context3.next = 2;
                break;
              }

              throw new Error("Controller init twice");

            case 2:
              this.hasInitInvoked = true;
              this.injectProps();
              this.bindProps(this.props);

              if (typeof this.initialize === "function") {
                this.initialize();
              }

              this.state = Object.assign(Object.assign({}, this.state), {
                _modelStateVersion: 1
              });
              pathname = ((_a = this.props.match) === null || _a === void 0 ? void 0 : _a.pathname) || this.location.pathname;
              this.initManager.registerRouteController(pathname, this);

            case 9:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
  }
  /**
   * !import： must called in subclass of constructor
   * @private
   */
  ;

  _proto.injectProps = function injectProps() {
    var _this2 = this;

    var controllerType = Object.getPrototypeOf(this).constructor;
    var injectedProps = this.appContext.resolveProperties(this, controllerType);

    if (injectedProps instanceof Promise) {
      this.hasInjectProps = false;
      injectedProps.then(function (props) {
        _this2.registersModel(props);

        _this2.hasInjectProps = true;
      })["catch"](function (err) {
        console.error("Init controller failed, controller name: " + controllerType.name + ", err: " + err + ".");
      });
    } else {
      this.registersModel(injectedProps);
      this.hasInjectProps = true;
    }
  };

  _proto.registersModel = function registersModel(propDeps) {
    this._models = new Array();

    for (var i = 0; i < propDeps.length; i++) {
      var propDep = propDeps[i];
      var instance = propDep.instance;

      if (!base_react_model_1.BaseReactModel.isModel(instance)) {
        continue;
      }

      var model = instance;
      this[propDep.key] = this.createModelProxy(model);

      this._models.push(model);
    }

    if (this._models.length) {
      this.reduxStore.addModelStateListener(this._models.map(function (it) {
        return it.getNamespace();
      }), this.modelStateListener);
    }
  };

  _proto.createModelProxy = function createModelProxy(model) {
    var _this3 = this;

    var modelNs = model.getNamespace();
    return new Proxy(model, {
      get: function get(target, p, receiver) {
        if (p === "state") {
          return new Proxy(target[p], {
            get: function get(state, stateProp, receiver) {
              if (_this3.isRendingView) {
                if (!_this3.modelStateDeps[modelNs]) {
                  _this3.modelStateDeps[modelNs] = [];
                }

                _this3.modelStateDeps[modelNs].push(stateProp);
              }

              return state[stateProp];
            }
          });
        } else {
          return target[p];
        }
      }
    });
  };

  _proto.getInitState = function getInitState() {
    var _a, _b, _c;

    var pathname = ((_a = this.props.match) === null || _a === void 0 ? void 0 : _a.pathname) || ((_b = this.location) === null || _b === void 0 ? void 0 : _b.pathname) || "/";
    var index = !!((_c = this.props.route) === null || _c === void 0 ? void 0 : _c.index);
    var initState = this.initManager.getRouteInitState({
      pathname: pathname,
      index: index
    });
    return initState;
  };

  _proto.setInitState = function setInitState(_ref) {
    var initStatic = _ref.initStatic,
        init = _ref.init;

    var _a, _b;

    var pathname = ((_a = this.props.match) === null || _a === void 0 ? void 0 : _a.pathname) || this.location.pathname;
    var index = !!((_b = this.props.route) === null || _b === void 0 ? void 0 : _b.index);
    this.initManager.setInitState({
      pathname: pathname,
      index: index
    }, {
      initStatic: initStatic,
      init: init
    });
  };

  _proto.render = function render() {
    var _this$getInitState2 = this.getInitState(),
        initStatic = _this$getInitState2.initStatic,
        init = _this$getInitState2.init; // reset model state dep props


    this.modelStateDeps = {};
    this.isRendingView = true;

    if (!this.hasInjectProps || initStatic === react_app_init_manager_1.ReactRouteInitStatus.LOADING) {
      return "loading...";
    }

    if (initStatic === react_app_init_manager_1.ReactRouteInitStatus.ERROR) {
      return "controller " + this.constructor.prototype.name + " init static model state failed";
    }

    if (init === react_app_init_manager_1.ReactRouteInitStatus.ERROR) {
      console.warn("controller" + this.constructor.prototype.name + " init model state failed");
    }

    var view = this.renderView();
    this.isRendingView = false;
    return view;
  };

  return BaseReactController;
}(react_1.Component);

__decorate([(0, react_controller_decorator_1.ReactContext)(react_app_container_1.ReactApplicationReactContext), __metadata("design:type", Object)], BaseReactController.prototype, "appContext", void 0);

__decorate([(0, core_1.Inject)(), __metadata("design:type", react_app_init_manager_1.ReactAppInitManager)], BaseReactController.prototype, "initManager", void 0);

exports.BaseReactController = BaseReactController;

/***/ }),

/***/ 19900:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(5216);

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseReactModel = void 0;

var react_redux_service_1 = __webpack_require__(21094);

var core_1 = __webpack_require__(16134);

var warning_1 = __importDefault(__webpack_require__(6588));

var isPlainObject_1 = __importDefault(__webpack_require__(67937));

var BaseReactModel = /*#__PURE__*/function () {
  function BaseReactModel() {}

  var _proto = BaseReactModel.prototype;

  _proto.getNamespace = function getNamespace() {
    return this._namespace;
  };

  _proto.setNamespace = function setNamespace(namespace) {
    this._namespace = namespace;
  };

  _proto.initialize = function initialize() {
    var initState = this.state || this.getInitState && this.getInitState();

    if (false) { var propType, propValue, prop, _i, _props, props, getType; }

    this.reactReduxService.registerModel(this, initState);
  };

  _proto.setProviderInfo = function setProviderInfo(_ref) {
    var name = _ref.name;

    if (this._namespace) {
      return;
    }

    var providerName = name;

    if (!providerName || typeof providerName !== "string") {
      throw new core_1.RuntimeException("The " + String(name) + ") has unexpected type of \"" + typeof providerName + "\". The component name must be a string,\n       and it will be used as model's namespace. ");
    }

    this._namespace = providerName;
  };

  _proto.setState = function setState(nextState) {
    var action = {
      type: this.getNamespace() + "/__SET_STATE",
      state: nextState
    };
    this.reactReduxService.store.dispatch(action);
  };

  BaseReactModel.isModel = function isModel(obj) {
    return obj instanceof BaseReactModel;
  };

  _createClass(BaseReactModel, [{
    key: "state",
    get: function get() {
      return this.reactReduxService.store.getState()[this.getNamespace()];
    }
  }]);

  return BaseReactModel;
}();

__decorate([(0, core_1.Inject)(), __metadata("design:type", react_redux_service_1.ReactReduxService)], BaseReactModel.prototype, "reactReduxService", void 0);

exports.BaseReactModel = BaseReactModel;

/***/ }),

/***/ 27894:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(84304), exports);

__exportStar(__webpack_require__(11743), exports);

__exportStar(__webpack_require__(48294), exports);

__exportStar(__webpack_require__(98154), exports);

__exportStar(__webpack_require__(66965), exports);

__exportStar(__webpack_require__(19900), exports);

__exportStar(__webpack_require__(23414), exports);

__exportStar(__webpack_require__(85067), exports);

__exportStar(__webpack_require__(2879), exports);

__exportStar(__webpack_require__(47326), exports);

__exportStar(__webpack_require__(81989), exports);

__exportStar(__webpack_require__(98056), exports);

__exportStar(__webpack_require__(30739), exports);

__exportStar(__webpack_require__(12354), exports);

__exportStar(__webpack_require__(73551), exports);

__exportStar(__webpack_require__(82508), exports);

__exportStar(__webpack_require__(50361), exports);

/***/ }),

/***/ 84304:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

__exportStar(__webpack_require__(1996), exports);

__exportStar(__webpack_require__(24212), exports);

__exportStar(__webpack_require__(25414), exports);

__exportStar(__webpack_require__(25766), exports);

/***/ }),

/***/ 1996:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 25414:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 24212:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 25766:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 82508:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ 50361:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MountService = void 0;

var core_1 = __webpack_require__(16134);

var MountService = /*#__PURE__*/function () {
  function MountService() {
    this.mountMap = new Map();
  }

  var _proto = MountService.prototype;

  _proto.setMount = function setMount(mount, components) {
    if (components && components.length) {
      for (var _iterator = _createForOfIteratorHelperLoose(components), _step; !(_step = _iterator()).done;) {
        var component = _step.value;
        this.mountMap.set(component.name, mount);
      }
    }
  };

  _proto.getMount = function getMount(typeOrToken) {
    var componentName;

    if (typeof typeOrToken === "string" || typeof typeOrToken === "symbol") {
      componentName = typeOrToken;
    } else {
      throw new core_1.RuntimeException("Get mount error: type should transform to component name");
    }

    if (componentName) {
      return this.mountMap.get(componentName);
    }
  };

  return MountService;
}();

MountService = __decorate([(0, core_1.Component)()], MountService);
exports.MountService = MountService;

/***/ }),

/***/ 12354:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var react_1 = __importStar(__webpack_require__(2784));

var react_app_container_1 = __webpack_require__(30739);

var routes_renderer_1 = __webpack_require__(1421);

function ReactAppComponent() {
  var appContext = (0, react_1.useContext)(react_app_container_1.ReactApplicationReactContext);

  if (!appContext) {
    throw new Error("React App Context not found.");
  }

  var reactRouterService = appContext.getSync("reactRouterService");
  var routes = reactRouterService.getRoutes() || [];
  return react_1["default"].createElement(routes_renderer_1.RoutesRenderer, {
    routes: routes
  });
}

exports["default"] = ReactAppComponent;

/***/ }),

/***/ 30739:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.renderComponent = exports.ReactAppContainer = exports.ReactApplicationReactContext = void 0;

var react_1 = __importStar(__webpack_require__(2784));

var react_redux_1 = __webpack_require__(66794);

var react_redux_service_1 = __webpack_require__(21094);

var core_1 = __webpack_require__(16134);

var react_app_component_1 = __importDefault(__webpack_require__(12354));

exports.ReactApplicationReactContext = (0, react_1.createContext)(undefined);

function ReactAppContainer(_ref) {
  var appContext = _ref.appContext,
      children = _ref.children,
      err = _ref.err;

  var _ref2 = (0, react_1.useMemo)(function () {
    return [appContext.getSync(react_redux_service_1.ReactReduxService), appContext.getSync("reactRouterComponent"), appContext.getOptionalSync("reactRouterProps")];
  }, []),
      reduxStore = _ref2[0],
      ReactRouterComponent = _ref2[1],
      reactRouterProps = _ref2[2];

  if (!reduxStore) {
    throw new core_1.RuntimeException("ReactReduxService has not registered in context");
  }

  if (!ReactRouterComponent) {
    throw new core_1.RuntimeException("reactRouter has not registered in context");
  }

  children = children || react_1["default"].createElement(react_app_component_1["default"], null);
  return react_1["default"].createElement(exports.ReactApplicationReactContext.Provider, {
    value: appContext
  }, react_1["default"].createElement(react_redux_1.Provider, {
    store: reduxStore.store
  }, react_1["default"].createElement(ReactRouterComponent, Object.assign({}, reactRouterProps || {}), children)));
}

exports.ReactAppContainer = ReactAppContainer;

function renderComponent(props) {
  return react_1["default"].createElement(ReactAppContainer, Object.assign({}, props));
}

exports.renderComponent = renderComponent;

/***/ }),

/***/ 66965:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(98152);

var _inheritsLoose = __webpack_require__(81660);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactAppInitManager = exports.ReactRouteInitStatus = void 0;

var base_react_model_1 = __webpack_require__(19900);

var react_app_init_stage_enum_1 = __webpack_require__(82538);

var ReactRouteInitStatus;

(function (ReactRouteInitStatus) {
  ReactRouteInitStatus[ReactRouteInitStatus["NONE"] = 0] = "NONE";
  ReactRouteInitStatus[ReactRouteInitStatus["LOADING"] = 1] = "LOADING";
  ReactRouteInitStatus[ReactRouteInitStatus["SUCCESS"] = 2] = "SUCCESS";
  ReactRouteInitStatus[ReactRouteInitStatus["ERROR"] = 3] = "ERROR";
})(ReactRouteInitStatus = exports.ReactRouteInitStatus || (exports.ReactRouteInitStatus = {}));

var ReactAppInitManager = /*#__PURE__*/function (_base_react_model_1$B) {
  _inheritsLoose(ReactAppInitManager, _base_react_model_1$B);

  // public initTasks: Record<string, Promise<any>[]> = {};
  function ReactAppInitManager() {
    var _this;

    _this = _base_react_model_1$B.call(this) || this;
    _this.initStage = react_app_init_stage_enum_1.EnumReactAppInitStage.DEFAULT;
    _this.initDelay = true;
    _this.routeControllers = new Map();
    return _this;
  }

  var _proto = ReactAppInitManager.prototype;

  _proto.getInitState = function getInitState() {
    return {};
  } // /**
  //  *  !!impotent: must call resetInitState, when the initial is finished
  //  * @param pathname
  //  * @param task
  //  */
  // addTask(pathname: string, tasks: Promise<any>[]): void {
  //   let initTasks = this.initTasks[pathname];
  //   if (!initTasks) {
  //     initTasks = [];
  //     this.initTasks[pathname] = initTasks;
  //   }
  //   initTasks.push(...tasks);
  // }
  // async waitAllFinished(pathname: string): Promise<{ revalidate: number | undefined }> {
  //   let tasks = [];
  //   const allPaths = Object.keys(this.initTasks);
  //   for (const path of allPaths) {
  //     if (pathname.startsWith(path)) {
  //       tasks.push(...this.initTasks[path]);
  //     }
  //   }
  //   const results = await Promise.all(tasks);
  //   let minRevalidate = Number.MAX_VALUE;
  //   results.forEach((rst) => {
  //     if (rst && typeof rst === "number" && rst < minRevalidate) {
  //       minRevalidate = rst;
  //     }
  //   });
  //   return {
  //     revalidate: minRevalidate === Number.MAX_VALUE ? undefined : minRevalidate,
  //   };
  // }
  ;

  _proto.setInitState = function setInitState(pathnameArg, _ref) {
    var _this$setState;

    var initStatic = _ref.initStatic,
        init = _ref.init,
        revalidate = _ref.revalidate;
    var pathname = typeof pathnameArg === "string" ? pathnameArg : pathnameArg.pathname;
    var index = typeof pathnameArg === "string" ? false : pathnameArg.index;
    var cacheKey = index ? pathname + "/__index" : pathname;
    var nextState = Object.assign({
      pathname: pathname,
      index: index // initStatic: ReactRouteInitStatus.NONE,
      // init: ReactRouteInitStatus.NONE,

    }, this.state[pathname]);

    if (typeof initStatic !== "undefined") {
      nextState.initStatic = initStatic;
    }

    if (typeof init !== "undefined") {
      nextState.init = init;
    }

    if (typeof revalidate !== "undefined") {
      nextState.revalidate = revalidate;
    }

    this.setState((_this$setState = {}, _this$setState[cacheKey] = nextState, _this$setState));
  };

  _proto.getRouteTreeInitState = function getRouteTreeInitState(pathname) {
    var state = this.state;
    var paths = Object.keys(state);
    var mathed = [];

    for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
      var p = _paths[_i];

      if (pathname.startsWith(p)) {
        mathed.push(state[p]);
      }
    }

    return mathed.sort(function (a, b) {
      return a.pathname >= b.pathname ? 1 : -1;
    });
  };

  _proto.getRouteInitState = function getRouteInitState(pathnameArg) {
    var pathname = typeof pathnameArg === "string" ? pathnameArg : pathnameArg.pathname;
    var index = typeof pathnameArg === "string" ? false : pathnameArg.index;
    var cacheKey = index ? pathname + "/__index" : pathname;
    return this.state[cacheKey] || {// initStatic: ReactRouteInitStatus.NONE,
      // init: ReactRouteInitStatus.NONE,
    };
  };

  _proto.resetInitState = function resetInitState(pathnameArg) {
    var pathname = typeof pathnameArg === "string" ? pathnameArg : pathnameArg.pathname;
    var index = typeof pathnameArg === "string" ? false : pathnameArg.index;
    var cacheKey = index ? pathname + "/__index" : pathname;
    delete this.state[cacheKey]; // delete this.initTasks[cacheKey];
  };

  _proto.registerRouteController = function registerRouteController(pathname, ctl) {
    var ctls = this.routeControllers.get(pathname);

    if (!ctls) {
      ctls = [];
      this.routeControllers.set(pathname, ctls);
    }

    ctls.push(ctl);
  };

  _proto.unregisterRouteController = function unregisterRouteController(pathname, ctl) {
    var ctls = this.routeControllers.get(pathname);

    if (!ctls) {
      return;
    }

    var index = ctls.indexOf(ctl);

    if (index < 0) {
      return;
    }

    ctls.splice(index, 1);
  };

  _proto.getRouteControllers = function getRouteControllers(pathname) {
    return this.routeControllers.get(pathname);
  };

  _proto.getAllRouteControllers = function getAllRouteControllers() {
    return this.routeControllers;
  };

  _proto.initControllers = function initControllers(pathname) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      var _this2 = this;

      var initStage, ctls, revalidate, initStaticTasks, initDynamicTasks, initAllDynamicTask, _this$getRouteInitSta, initStatic, init, _iterator, _step, ctl, initStaticTask, results, minRevalidate;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              initStage = this.initStage;
              ctls = this.routeControllers.get(pathname);

              if (ctls === null || ctls === void 0 ? void 0 : ctls.length) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", {
                revalidate: undefined,
                initDynamicCount: 0,
                initStaticCount: 0
              });

            case 4:
              revalidate = undefined;
              _this$getRouteInitSta = this.getRouteInitState(pathname), initStatic = _this$getRouteInitSta.initStatic, init = _this$getRouteInitSta.init;

              if (initStage >= react_app_init_stage_enum_1.EnumReactAppInitStage.STATIC) {
                if (initStatic === undefined || initStatic === ReactRouteInitStatus.NONE || initStatic === ReactRouteInitStatus.ERROR) {
                  initStaticTasks = [];

                  for (_iterator = _createForOfIteratorHelperLoose(ctls); !(_step = _iterator()).done;) {
                    ctl = _step.value;

                    if (ctl.initModelStaticState) {
                      initStaticTask = ctl.initModelStaticState();
                      initStaticTasks.push(initStaticTask);
                    } else {// noop
                    }
                  } // this.addTask(pathname, initStaticTasks);
                  // try {
                  //   const results = await Promise.all(initStaticTasks);
                  //   let minRevalidate = Number.MAX_VALUE;
                  //   results.forEach((rst) => {
                  //     if (rst && typeof rst === "number" && rst < minRevalidate) {
                  //       minRevalidate = rst;
                  //     }
                  //   });
                  //   revalidate = minRevalidate === Number.MAX_VALUE ? undefined : minRevalidate;
                  //   this.setInitState(pathname, {
                  //     initStatic: ReactRouteInitStatus.SUCCESS,
                  //     revalidate,
                  //   });
                  // } catch (e) {
                  //   this.setInitState(pathname, {
                  //     initStatic: ReactRouteInitStatus.ERROR,
                  //   });
                  // }

                } else if (initStatic === ReactRouteInitStatus.SUCCESS) {// noop
                } else if (initStatic === ReactRouteInitStatus.LOADING) {// 数据由外部加载，例如加载预渲染的数据时。noop
                }
              }

              if (initStage >= react_app_init_stage_enum_1.EnumReactAppInitStage.DYNAMIC) {
                if (init === undefined || init === ReactRouteInitStatus.NONE || init === ReactRouteInitStatus.ERROR) {
                  initAllDynamicTask = Promise.all(initStaticTasks || []).then(function () {
                    return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                      var _iterator2, _step2, _ctl, initTask;

                      return _regeneratorRuntime.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              initDynamicTasks = [];

                              for (_iterator2 = _createForOfIteratorHelperLoose(ctls); !(_step2 = _iterator2()).done;) {
                                _ctl = _step2.value;

                                if (_ctl.initModelState) {
                                  initTask = _ctl.initModelState();
                                  initDynamicTasks.push(initTask);
                                } else {// noop
                                }
                              }

                              _context.prev = 2;
                              _context.next = 5;
                              return Promise.all(initDynamicTasks);

                            case 5:
                              this.setInitState(pathname, {
                                init: ReactRouteInitStatus.SUCCESS
                              });
                              _context.next = 11;
                              break;

                            case 8:
                              _context.prev = 8;
                              _context.t0 = _context["catch"](2);
                              this.setInitState(pathname, {
                                init: ReactRouteInitStatus.ERROR
                              });

                            case 11:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, this, [[2, 8]]);
                    }));
                  }); // this.addTask(pathname, [initAllDynamicTask]);
                  // for (const ctl of ctls) {
                  //   if (ctl.initialModelState) {
                  //     const initTask = await ctl.initialModelState({});
                  //     initTasks.push(initTask);
                  //   } else {
                  //     // noop
                  //   }
                  // }
                }
              }

              if (!initStaticTasks) {
                _context2.next = 22;
                break;
              }

              _context2.prev = 9;
              _context2.next = 12;
              return Promise.all(initStaticTasks);

            case 12:
              results = _context2.sent;
              minRevalidate = Number.MAX_VALUE;
              results.forEach(function (rst) {
                if (rst && typeof rst === "number" && rst < minRevalidate) {
                  minRevalidate = rst;
                }
              });
              revalidate = minRevalidate === Number.MAX_VALUE ? undefined : minRevalidate;
              this.setInitState(pathname, {
                initStatic: ReactRouteInitStatus.SUCCESS,
                revalidate: revalidate
              });
              _context2.next = 22;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](9);
              this.setInitState(pathname, {
                initStatic: ReactRouteInitStatus.ERROR
              });

            case 22:
              if (!initAllDynamicTask) {
                _context2.next = 25;
                break;
              }

              _context2.next = 25;
              return initAllDynamicTask;

            case 25:
              return _context2.abrupt("return", {
                revalidate: revalidate,
                initStaticCount: initStaticTasks === null || initStaticTasks === void 0 ? void 0 : initStaticTasks.length,
                initDynamicCount: initDynamicTasks === null || initDynamicTasks === void 0 ? void 0 : initDynamicTasks.length
              });

            case 26:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[9, 19]]);
    }));
  };

  return ReactAppInitManager;
}(base_react_model_1.BaseReactModel);

exports.ReactAppInitManager = ReactAppInitManager;

/***/ }),

/***/ 82538:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EnumReactAppInitStage = void 0;
/**
 * 当前的初始阶段，数值越大，初始化程度越高。
 * 只在服务端时渲染使用，客户端使用固定的默认值。
 */

var EnumReactAppInitStage;

(function (EnumReactAppInitStage) {
  EnumReactAppInitStage[EnumReactAppInitStage["STATIC"] = 0] = "STATIC";
  EnumReactAppInitStage[EnumReactAppInitStage["DYNAMIC"] = 1] = "DYNAMIC";
  EnumReactAppInitStage[EnumReactAppInitStage["DEFAULT"] = 99] = "DEFAULT";
})(EnumReactAppInitStage = exports.EnumReactAppInitStage || (exports.EnumReactAppInitStage = {}));

/***/ }),

/***/ 98056:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactApplicationConfig = void 0;

var config_1 = __webpack_require__(24968);

var ReactApplicationConfig = /*#__PURE__*/function () {
  function ReactApplicationConfig() {
    // === redux
    this.reducers = {};
    this.reduxMiddlewares = [];
    this.storeEnhancer = [];
    this.globalPrefix = "";
  } // public getInitStoreState() {
  //   return this.initStoreState;
  // }


  var _proto = ReactApplicationConfig.prototype;

  _proto.getReducers = function getReducers() {
    return this.reducers;
  };

  _proto.getReducerEnhancer = function getReducerEnhancer() {
    return this.reducerEnhancer;
  };

  _proto.getReduxMiddlewares = function getReduxMiddlewares() {
    return this.reduxMiddlewares;
  };

  _proto.getReduxMiddlewaresEnhancer = function getReduxMiddlewaresEnhancer() {
    return this.reduxMiddlewaresEnhancer;
  };

  _proto.getStoreEnhancer = function getStoreEnhancer() {
    return this.storeEnhancer;
  };

  _proto.setGlobalPrefix = function setGlobalPrefix(prefix) {
    this.globalPrefix = prefix;
  };

  _proto.getGlobalPrefix = function getGlobalPrefix() {
    return this.globalPrefix;
  };

  return ReactApplicationConfig;
}();

__decorate([(0, config_1.Value)(), __metadata("design:type", Object)], ReactApplicationConfig.prototype, "reducers", void 0);

__decorate([(0, config_1.Value)(), __metadata("design:type", Object)], ReactApplicationConfig.prototype, "reducerEnhancer", void 0);

__decorate([(0, config_1.Value)(), __metadata("design:type", Array)], ReactApplicationConfig.prototype, "reduxMiddlewares", void 0);

__decorate([(0, config_1.Value)(), __metadata("design:type", Function)], ReactApplicationConfig.prototype, "reduxMiddlewaresEnhancer", void 0);

__decorate([(0, config_1.Value)(), __metadata("design:type", Array)], ReactApplicationConfig.prototype, "storeEnhancer", void 0);

exports.ReactApplicationConfig = ReactApplicationConfig;

/***/ }),

/***/ 48294:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _regeneratorRuntime = __webpack_require__(98152);

var _inheritsLoose = __webpack_require__(81660);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactApplicationContext = void 0;

var react_application_config_1 = __webpack_require__(98056);

var react_app_container_1 = __webpack_require__(30739);

var react_1 = __importDefault(__webpack_require__(2784));

var react_dom_1 = __importDefault(__webpack_require__(28316));

var react_redux_service_1 = __webpack_require__(21094);

var core_1 = __webpack_require__(16134);

var mount_service_1 = __webpack_require__(50361);

var react_router_service_1 = __webpack_require__(2879);
/**
 * @publicApi
 */


var ReactApplicationContext = /*#__PURE__*/function (_core_1$ApplicationCo) {
  _inheritsLoose(ReactApplicationContext, _core_1$ApplicationCo);

  function ReactApplicationContext(reactApplicationConfiguration, initState, parent) {
    var _this;

    if (initState === void 0) {
      initState = {};
    }

    _this = _core_1$ApplicationCo.call(this, undefined, parent) || this;
    _this.reactApplicationConfiguration = reactApplicationConfiguration;
    _this.initState = initState;
    _this.parent = parent;
    _this.logger = new core_1.Logger(ReactApplicationContext.name, true); // this.reduxStore = new ReactReduxService(this.appConfig, initState);

    return _this;
  }

  var _proto = ReactApplicationContext.prototype;

  _proto.initContext = function initContext() {
    var _super = Object.create(null, {
      initContext: {
        get: function get() {
          return _core_1$ApplicationCo.prototype.initContext;
        }
      }
    });

    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var initState, coreComps, coreWrappers;
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              initState = this.initState;
              _context.next = 3;
              return _super.initContext.call(this);

            case 3:
              coreComps = [// {
              //   name: "applicationConfig",
              //   type: ReactApplicationConfig,
              //   useValue: this.appConfig,
              // },
              {
                name: "reduxStore",
                type: react_redux_service_1.ReactReduxService,
                // useValue: this.reduxStore,
                useFactory: function useFactory(applicationConfig) {
                  return new react_redux_service_1.ReactReduxService(applicationConfig, initState);
                },
                inject: [react_application_config_1.ReactApplicationConfig]
              }].concat(this.dependenciesScanner.scan(this.reactApplicationConfiguration));
              coreWrappers = this.container.addProviders(coreComps);
              _context.next = 7;
              return this.createInstancesOfDependencies(coreWrappers);

            case 7:
              this.reduxStore = this.getSync(react_redux_service_1.ReactReduxService);
              this.reactApplicationConfig = this.getSync(react_application_config_1.ReactApplicationConfig);
              this.reactRouterService = this.getSync(react_router_service_1.ReactRouterService);
              this.mountService = this.getSync(mount_service_1.MountService);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  };

  _proto.init = function init() {
    var _super = Object.create(null, {
      init: {
        get: function get() {
          return _core_1$ApplicationCo.prototype.init;
        }
      }
    });

    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _super.init.call(this);

            case 2:
              this.reactRouterService = this.getSync(react_router_service_1.ReactRouterService);
              _context2.next = 5;
              return this.registerMiddleware();

            case 5:
              // await this.registerRouter();
              // await this.callInitHook()
              // await this.registerRouterHooks();
              // await this.callBootstrapHook()
              this.logger.log("Joy application successfully started");
              return _context2.abrupt("return", this);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
  };

  _proto.registerModule = function registerModule(module) {
    var modules = Array.isArray(module) ? module : [module];
    var wrappers = [];

    for (var _iterator = _createForOfIteratorHelperLoose(modules), _step; !(_step = _iterator()).done;) {
      var md = _step.value;
      var compWrappers = void 0;
      var mount = "";

      var _module = void 0;

      if (md.mount) {
        mount = md.mount;
        _module = md.module;
        compWrappers = _core_1$ApplicationCo.prototype.registerModule.call(this, _module);

        if (compWrappers && compWrappers.length > 0) {
          this.mountService.setMount(mount, compWrappers);
        }
      } else {
        _module = md;
        compWrappers = _core_1$ApplicationCo.prototype.registerModule.call(this, _module);
      }

      if (!compWrappers || compWrappers.length === 0) {
        continue;
      }

      this.registerModuleRouter(mount, md, compWrappers);
      wrappers = wrappers.concat(compWrappers);
    }

    return wrappers;
  };

  _proto.registerModuleRouter = function registerModuleRouter(mount, md, compWrappers) {
    var _this2 = this;

    var addedRoutes;
    compWrappers.forEach(function (wrapper) {
      var routes = _this2.reactRouterService.addRouteProvider(wrapper, mount);

      if (routes && routes.length > 0) {
        if (!addedRoutes) {
          addedRoutes = routes;
        } else {
          var _addedRoutes;

          (_addedRoutes = addedRoutes).push.apply(_addedRoutes, routes);
        }
      }
    });
    return addedRoutes;
  };

  _proto.registerMiddleware = function registerMiddleware() {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
  };

  _proto.setGlobalPrefix = function setGlobalPrefix(prefix) {
    this.reactApplicationConfig.setGlobalPrefix(prefix);
    return this;
  };

  _proto.dispatch = function dispatch(action) {
    return this.reduxStore.dispatch(action);
  };

  _proto.dispatchBatch = function dispatchBatch(actions) {
    return this.reduxStore.dispatchBatch(actions);
  };

  _proto.getState = function getState() {
    return this.reduxStore.store.getState();
  };

  _proto.start = function start(rootComponent, domContainer) {
    // return createApplicationComponent(this);
    var appContent = (0, react_app_container_1.renderComponent)({
      appContext: this,
      children: rootComponent ? react_1["default"].createElement(rootComponent, {
        appContext: this
      }) : undefined
    });

    if (domContainer) {
      if (window === undefined) {
        throw new Error("只能在浏览器上渲染应用dom");
      } // todo 完成在浏览器上渲染
      // @ts-ignore


      react_dom_1["default"].render(appContent, domContainer);
    }

    return appContent;
  };

  return ReactApplicationContext;
}(core_1.ApplicationContext);

exports.ReactApplicationContext = ReactApplicationContext;

/***/ }),

/***/ 73551:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __decorate = this && this.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __metadata = this && this.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactApplicationConfiguration = void 0;

var react_router_1 = __webpack_require__(10289);

var react_router_service_1 = __webpack_require__(2879);

var core_1 = __webpack_require__(16134);

var react_app_init_manager_1 = __webpack_require__(66965);

var mount_service_1 = __webpack_require__(50361);

var react_application_config_1 = __webpack_require__(98056);

var config_1 = __webpack_require__(24968);

var ReactApplicationConfiguration = /*#__PURE__*/function () {
  function ReactApplicationConfiguration() {}

  var _proto = ReactApplicationConfiguration.prototype;

  _proto.reactRouterComponent = function reactRouterComponent() {
    // public reactRouterComponent(): typeof StaticRouter | typeof BrowserRouter | typeof MemoryRouter | typeof HashRouter {
    return react_router_1.MemoryRouter;
  };

  return ReactApplicationConfiguration;
}();

__decorate([core_1.Configuration.Component(), __metadata("design:type", config_1.ConfigConfiguration)], ReactApplicationConfiguration.prototype, "configConfiguration", void 0);

__decorate([core_1.Configuration.Component(), __metadata("design:type", react_application_config_1.ReactApplicationConfig)], ReactApplicationConfiguration.prototype, "reactApplicationConfig", void 0);

__decorate([core_1.Configuration.Component(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", Function)], ReactApplicationConfiguration.prototype, "reactRouterComponent", null);

__decorate([core_1.Configuration.Component(), __metadata("design:type", react_router_service_1.ReactRouterService)], ReactApplicationConfiguration.prototype, "reactRouterService", void 0);

__decorate([core_1.Configuration.Component(), __metadata("design:type", mount_service_1.MountService)], ReactApplicationConfiguration.prototype, "mountService", void 0);

__decorate([core_1.Configuration.Component(), __metadata("design:type", react_app_init_manager_1.ReactAppInitManager)], ReactApplicationConfiguration.prototype, "reactAppInitManager", void 0);

ReactApplicationConfiguration = __decorate([(0, core_1.Configuration)()], ReactApplicationConfiguration);
exports.ReactApplicationConfiguration = ReactApplicationConfiguration;

/***/ }),

/***/ 11743:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isReactComponent = exports.ReactComponent = exports.META_KEY_REACT_COMPONENT = void 0;

var core_1 = __webpack_require__(16134);

exports.META_KEY_REACT_COMPONENT = Symbol("react-component");

function ReactComponent(options) {
  return function (constructor) {
    var _options = Object.assign({
      lazyRegister: true
    }, options);

    Reflect.defineMetadata(exports.META_KEY_REACT_COMPONENT, true, constructor);

    if (typeof (options === null || options === void 0 ? void 0 : options.name) === "symbol") {
      throw new Error("React component name can not be a symbol");
    }

    return (0, core_1.Component)(_options)(constructor);
  };
}

exports.ReactComponent = ReactComponent;

function isReactComponent(clazz) {
  return Reflect.getMetadata(exports.META_KEY_REACT_COMPONENT, clazz);
}

exports.isReactComponent = isReactComponent;

/***/ }),

/***/ 23414:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _inheritsLoose = __webpack_require__(81660);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactContext = exports.getReactControllerMeta = exports.ReactController = exports._ReactController = exports.META_KEY_REACT_CONTROLLER_CONTEXT_PROPS = exports.META_KEY_REACT_CONTROLLER = void 0;

var react_1 = __importStar(__webpack_require__(2784));

var core_1 = __webpack_require__(16134);

var react_component_decorator_1 = __webpack_require__(11743);

var react_router_dom_1 = __webpack_require__(7725);

var react_route_decorator_1 = __webpack_require__(85067);

exports.META_KEY_REACT_CONTROLLER = Symbol("react-controller");
exports.META_KEY_REACT_CONTROLLER_CONTEXT_PROPS = Symbol("react-controller-contexts"); // eslint-disable-next-line @typescript-eslint/ban-types

function _ReactController(options) {
  if (options === void 0) {
    options = {};
  }

  return function (constructor) {
    var ExtReactControllerDeco = /*#__PURE__*/function (_constructor) {
      _inheritsLoose(ExtReactControllerDeco, _constructor);

      function ExtReactControllerDeco() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _constructor.call.apply(_constructor, [this].concat(args)) || this;
        _this.wrapperComponent = constructor;

        if (!_this.hasInitInvoked && typeof _this.init === "function") {
          _this.init();
        }

        return _this;
      }

      ExtReactControllerDeco.toString = function toString() {
        return constructor.toString();
      };

      return ExtReactControllerDeco;
    }(constructor);

    ExtReactControllerDeco.displayName = "RCTL_" + (constructor.displayName || constructor.name); // react-controller is instanced by react, so it's scope must be transient

    var clazzName = constructor.name;
    var name = clazzName.replace(clazzName[0], clazzName[0].toLowerCase());
    options = Object.assign( // { type: ExtReactControllerDeco, useClass: ExtReactControllerDeco },
    {
      name: name
    }, options, {
      scope: core_1.Scope.PROTOTYPE,
      lazyRegister: false
    });
    (0, react_component_decorator_1.ReactComponent)(options)(ExtReactControllerDeco);
    Reflect.defineMetadata(exports.META_KEY_REACT_CONTROLLER, true, ExtReactControllerDeco);
    return ExtReactControllerDeco;
  };
}

exports._ReactController = _ReactController; // eslint-disable-next-line @typescript-eslint/ban-types

function ReactController(options) {
  if (options === void 0) {
    options = {};
  }

  return function (constructor) {
    var ExtReactControllerDeco = /*#__PURE__*/function (_constructor2) {
      _inheritsLoose(ExtReactControllerDeco, _constructor2);

      function ExtReactControllerDeco() {
        var _this2;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this2 = _constructor2.call.apply(_constructor2, [this].concat(args)) || this;
        _this2.wrapperComponent = constructor;

        if (!_this2.hasInitInvoked && typeof _this2.init === "function") {
          _this2.init();
        }

        return _this2;
      }

      var _proto = ExtReactControllerDeco.prototype;

      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState, nextContext) {
        var superRst = true;

        if (typeof _constructor2.prototype.shouldComponentUpdate === "function") {
          superRst = _constructor2.prototype.shouldComponentUpdate.call(this, nextProps);
        }

        if (superRst) {
          this._patch_shouldComponentUpdate(nextProps, nextState, nextContext);

          return true;
        }
      };

      _proto.componentDidMount = function componentDidMount() {
        this._patch_pre_componentDidMount();

        if (typeof _constructor2.prototype.componentDidMount === "function") {
          _constructor2.prototype.componentDidMount.call(this);
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        if (typeof _constructor2.prototype.componentWillUnmount === "function") {
          _constructor2.prototype.componentWillUnmount.call(this);
        }

        this._patch_componentWillUnmount();
      };

      ExtReactControllerDeco.toString = function toString() {
        return constructor.toString();
      };

      return ExtReactControllerDeco;
    }(constructor);

    ExtReactControllerDeco.displayName = "RCTL_" + (constructor.displayName || constructor.name); // react-controller is instanced by react, so it's scope must be transient

    var clazzName = constructor.name;
    var name = clazzName.replace(clazzName[0], clazzName[0].toLowerCase());
    options = Object.assign( // { type: ExtReactControllerDeco, useClass: ExtReactControllerDeco },
    {
      name: name
    }, options, {
      scope: core_1.Scope.PROTOTYPE,
      lazyRegister: false
    });
    (0, react_component_decorator_1.ReactComponent)(options)(ExtReactControllerDeco);
    Reflect.defineMetadata(exports.META_KEY_REACT_CONTROLLER, true, ExtReactControllerDeco);

    var ReactControllerWrapper = function ReactControllerWrapper(props) {
      var _a; // const appContext = useContext(ReactApplicationReactContext);


      var routeContextValue = (0, react_1.useContext)(react_route_decorator_1.ReactRouteContext);
      var contextProps = Reflect.getMetadata(exports.META_KEY_REACT_CONTROLLER_CONTEXT_PROPS, constructor.prototype);
      var contextValues = {};

      if (contextProps === null || contextProps === void 0 ? void 0 : contextProps.length) {
        for (var _iterator = _createForOfIteratorHelperLoose(contextProps), _step; !(_step = _iterator()).done;) {
          var contextProp = _step.value;
          var contextType = contextProp.contextType,
              propKey = contextProp.propKey;
          var value = (0, react_1.useContext)(contextType);
          contextValues[propKey] = value;
        }
      }

      var navigate = (0, react_router_dom_1.useNavigate)();

      if (!routeContextValue) {
        // 如果是没有放在路由组件内，直接渲染Controller，将会导致路由信息为空。
        var defaultPathname = "/";
        routeContextValue = {
          location: {
            pathname: defaultPathname
          },
          match: {
            pathname: defaultPathname,
            pattern: {
              path: defaultPathname,
              end: false
            },
            params: {},
            pathnameBase: ""
          },
          navigate: navigate,
          route: {
            path: defaultPathname,
            isContainer: true
          },
          controllers: []
        };
      }

      return react_1["default"].createElement(ExtReactControllerDeco, Object.assign(Object.assign(Object.assign({
        key: (_a = routeContextValue.match) === null || _a === void 0 ? void 0 : _a.pathname
      }, routeContextValue), props), {
        // __ctx_appContext: appContext,
        __ctx_values: contextValues
      }));
    };

    ReactControllerWrapper.innerController = constructor;
    (0, react_component_decorator_1.ReactComponent)(options)(ReactControllerWrapper);
    Reflect.defineMetadata(exports.META_KEY_REACT_CONTROLLER, true, ReactControllerWrapper);
    return ReactControllerWrapper;
  };
}

exports.ReactController = ReactController;

function getReactControllerMeta(clazz) {
  return Reflect.getMetadata(exports.META_KEY_REACT_CONTROLLER, clazz);
}

exports.getReactControllerMeta = getReactControllerMeta;

function ReactContext(contextType) {
  return function (target, propKey) {
    var contexts = Reflect.getMetadata(exports.META_KEY_REACT_CONTROLLER_CONTEXT_PROPS, target) || [];
    contexts.push({
      contextType: contextType,
      propKey: propKey
    });
    Reflect.defineMetadata(exports.META_KEY_REACT_CONTROLLER_CONTEXT_PROPS, contexts, target);
  };
}

exports.ReactContext = ReactContext;

/***/ }),

/***/ 81989:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactModel = void 0;

var react_component_decorator_1 = __webpack_require__(11743);

function ReactModel(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target) {
    return (0, react_component_decorator_1.ReactComponent)(Object.assign({
      lazyRegister: true
    }, options))(target);
  };
}

exports.ReactModel = ReactModel;

/***/ }),

/***/ 60717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var compose_1 = __importDefault(__webpack_require__(57240));

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState) {
      var store = createStore(reducer, preloadedState);

      var _dispatch = function dispatch() {
        throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return _dispatch.apply(void 0, [action].concat(args));
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = (0, compose_1["default"]).apply(void 0, chain)(store.dispatch);
      return Object.assign(Object.assign({}, store), {
        dispatch: _dispatch
      });
    };
  };
}

exports["default"] = applyMiddleware;

/***/ }),

/***/ 60142:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return dispatch(actionCreator.apply(this, args));
  };
}

function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? "null" : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

exports["default"] = bindActionCreators;

/***/ }),

/***/ 40789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var actionTypes_1 = __importDefault(__webpack_require__(12906));

var isPlainObject_1 = __importDefault(__webpack_require__(67937));

var warning_1 = __importDefault(__webpack_require__(6588));

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || "an action";
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === actionTypes_1["default"].INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";

  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed " + "to combineReducers is an object whose values are reducers.";
  }

  if (!(0, isPlainObject_1["default"])(inputState)) {
    var match = Object.prototype.toString.call(inputState).match(/\s([a-z|A-Z]+)/);
    var matchType = match ? match[1] : "";
    return "The " + argumentName + " has unexpected type of \"" + matchType + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  } // modified for joy, in order to support dynamic load model
  // const unexpectedKeys = Object.keys(inputState).filter(
  //   key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]
  // )
  //
  // unexpectedKeys.forEach(key => {
  //   unexpectedKeyCache[key] = true
  // })
  //
  // if (action && action.type === ActionTypes.REPLACE) return
  //
  // if (unexpectedKeys.length > 0) {
  //   return (
  //     `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` +
  //     `"${unexpectedKeys.join('", "')}" found in ${argumentName}. ` +
  //     `Expected to find one of the known reducer keys instead: ` +
  //     `"${reducerKeys.join('", "')}". Unexpected keys will be ignored.`
  //   )
  // }

}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: actionTypes_1["default"].INIT
    });

    if (typeof initialState === "undefined") {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: actionTypes_1["default"].PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + actionTypes_1["default"].INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}

function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false; // modified for joy， keep the prefetch data even if the model has not registered。

    var nextState = Object.assign({}, state);

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === "undefined") {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

exports["default"] = combineReducers;

/***/ }),

/***/ 57240:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    // infer the argument type so it is usable in inference down the line
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

exports["default"] = compose;

/***/ }),

/***/ 6620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var symbol_observable_1 = __importDefault(__webpack_require__(99952));

var actionTypes_1 = __importDefault(__webpack_require__(12906));

var isPlainObject_1 = __importDefault(__webpack_require__(67937));

function createStore(reducer, preloadedState, enhancer) {
  var _store;

  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error("It looks like you are passing several store enhancers to " + "createStore(). This is not supported. Instead, compose them " + "together to a single function.");
  }

  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error("Expected the enhancer to be a function.");
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== "function") {
    throw new Error("Expected the reducer to be a function.");
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error("You may not call store.getState() while the reducer is executing. " + "The reducer has already received the state as an argument. " + "Pass it down from the top reducer instead of reading it from the store.");
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param listener A callback to be invoked on every dispatch.
   * @returns A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error("Expected the listener to be a function.");
    }

    if (isDispatching) {
      throw new Error("You may not call store.subscribe() while the reducer is executing. " + "If you would like to be notified after the store has been updated, subscribe from a " + "component and invoke store.getState() in the callback to access the latest state. " + "See https://redux.js.org/api/store#subscribelistener for more details.");
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error("You may not unsubscribe from a store listener while the reducer is executing. " + "See https://redux.js.org/api/store#subscribelistener for more details.");
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!(0, isPlainObject_1["default"])(action)) {
      throw new Error("Actions must be plain objects. " + "Use custom middleware for async actions.");
    }

    if (typeof action.type === "undefined") {
      throw new Error('Actions may not have an undefined "type" property. ' + "Have you misspelled a constant?");
    }

    if (isDispatching) {
      throw new Error("Reducers may not dispatch actions.");
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param nextReducer The reducer for the store to use instead.
   * @returns The same store instance with a new reducer in place.
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error("Expected the nextReducer to be a function.");
    } // TODO: do this more elegantly


    currentReducer = nextReducer; // This action has a similar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: actionTypes_1["default"].REPLACE
    }); // change the type of the store by casting it to the new store

    return store;
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new TypeError("Expected the observer to be an object.");
        }

        function observeState() {
          var observerAsObserver = observer;

          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[symbol_observable_1["default"]] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: actionTypes_1["default"].INIT
  });
  var store = (_store = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _store[symbol_observable_1["default"]] = observable, _store);
  return store;
}

exports["default"] = createStore;

/***/ }),

/***/ 74448:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.__DO_NOT_USE__ActionTypes = exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = void 0; // functions

var createStore_1 = __importDefault(__webpack_require__(6620));

exports.createStore = createStore_1["default"];

var combineReducers_1 = __importDefault(__webpack_require__(40789));

exports.combineReducers = combineReducers_1["default"];

var bindActionCreators_1 = __importDefault(__webpack_require__(60142));

exports.bindActionCreators = bindActionCreators_1["default"];

var applyMiddleware_1 = __importDefault(__webpack_require__(60717));

exports.applyMiddleware = applyMiddleware_1["default"];

var compose_1 = __importDefault(__webpack_require__(57240));

exports.compose = compose_1["default"];

var warning_1 = __importDefault(__webpack_require__(6588));

var actionTypes_1 = __importDefault(__webpack_require__(12906));

exports.__DO_NOT_USE__ActionTypes = actionTypes_1["default"];
/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (false) {}

/***/ }),

/***/ 21094:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactReduxService = exports.ACTION_INIT_MODEL = exports.ACTION_MERGE_STATE = void 0;

var index_1 = __webpack_require__(74448); // @ts-ignore


var flatten_1 = __importDefault(__webpack_require__(79172));

var core_1 = __webpack_require__(16134);

var returnSelf = function returnSelf(self) {
  return self;
};

exports.ACTION_MERGE_STATE = "__MERGE_STATE";
exports.ACTION_INIT_MODEL = "__INIT_MODEL";

var noopReduxMiddleware = function noopReduxMiddleware(store) {
  return function (next) {
    return function (action) {
      return next();
    };
  };
};

var ReactReduxService = /*#__PURE__*/function () {
  function ReactReduxService(appConfig, initState) {
    var _this = this;

    // const modelMiddleware = createModelMiddleware(app)
    this.appConfig = appConfig;
    this.models = {};
    this.asyncReducers = {};
    this.preState = {};
    this.stateListenerIdCounter = 1;

    this.storeStateListener = function () {
      var _a;

      var storeState = _this.store.getState();

      var preState = _this.preState;
      var effectListeners = new Map();
      var index = 0;

      for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(_this.models)), _step; !(_step = _iterator()).done;) {
        var namespace = _step.value;
        var registeredModel = _this.models[namespace];

        if (preState[namespace] !== storeState[namespace] && ((_a = registeredModel.listeners) === null || _a === void 0 ? void 0 : _a.length)) {
          for (index = 0; index < registeredModel.listeners.length; index++) {
            var listener = registeredModel.listeners[index];
            var changedModels = effectListeners.get(listener);

            if (!changedModels) {
              changedModels = new Array();
              effectListeners.set(listener, changedModels);
            }

            changedModels.push(namespace);
          }
        }
      }

      if (effectListeners.size > 0) {
        var arr = Array.from(effectListeners);
        arr = arr.sort(function (a, b) {
          return a[0].id - b[0].id;
        });
        arr.forEach(function (item) {
          var handler = item[0].listener;
          var changedModels = item[1];
          handler(changedModels, storeState, preState);
        });
      }

      _this.preState = storeState;
    };

    this.isStateRecording = false;
    this.store = this.createStore({
      reducers: this.createReducer(),
      initialState: initState,
      middlewares: []
    });
    this.preState = this.store.getState();
    this.store.subscribe(this.storeStateListener);
  }

  var _proto = ReactReduxService.prototype;

  _proto.createStore = function createStore(_ref) {
    var reducers = _ref.reducers,
        initialState = _ref.initialState,
        _ref$middlewares = _ref.middlewares,
        middlewares = _ref$middlewares === void 0 ? [] : _ref$middlewares;
    // extra enhancers
    var reduxMiddlewaresEnhancer = this.appConfig.getReduxMiddlewaresEnhancer() || returnSelf;
    var storeEnhancer = this.appConfig.getStoreEnhancer();
    var extraMiddlewares = this.appConfig.getReduxMiddlewares();
    var enhancedMiddlewares = reduxMiddlewaresEnhancer([].concat(middlewares, (0, flatten_1["default"])(extraMiddlewares)));
    var devtools;

    if (false) {}

    var enhancers = [(0, index_1.applyMiddleware).apply(void 0, enhancedMiddlewares),  true && devtools && devtools(window.__REDUX_DEVTOOLS_EXTENSION__OPTIONS)].concat(storeEnhancer).filter(Boolean);
    return (0, index_1.createStore)(reducers, initialState, (0, index_1.compose).apply(void 0, enhancers));
  };

  _proto.createReducer = function createReducer() {
    var reducerEnhancer = this.appConfig.getReducerEnhancer() || returnSelf;
    var extraReducers = this.appConfig.getReducers();
    var combined = (0, index_1.combineReducers)(Object.assign(Object.assign(Object.assign({}, this.asyncReducers), extraReducers), {
      noop: function noop(state) {
        return state || {};
      }
    }));

    if (reducerEnhancer) {
      combined = reducerEnhancer(combined);
    }

    function mergeStateReducer(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (action.type === exports.ACTION_MERGE_STATE) {
        var nextState = Object.assign({}, state);
        var nextSubState = action.state;

        for (var key in nextSubState) {
          nextState[key] = Object.assign(Object.assign({}, nextState[key]), nextSubState[key]);
        }

        return nextState;
      } else if (action.type === exports.ACTION_INIT_MODEL) {
        var initState = action.state;
        var _nextState = undefined;

        for (var _key in initState) {
          if (state[_key] === undefined) {
            if (_nextState === undefined) {
              _nextState = Object.assign({}, state);
            }

            _nextState[_key] = initState[_key];
          }
        }

        return _nextState || state;
      } else {
        return combined(state, action);
      }
    }

    return mergeStateReducer;
  };

  _proto.rmModelStateListener = function rmModelStateListener(modelNameSpaces, listener) {
    var _a;

    var count = 0;

    if (!(modelNameSpaces && modelNameSpaces.length > 0)) {
      return count;
    }

    for (var i = 0; i < modelNameSpaces.length; i++) {
      var registeredModel = this.models[modelNameSpaces[i]];

      if (!((_a = registeredModel === null || registeredModel === void 0 ? void 0 : registeredModel.listeners) === null || _a === void 0 ? void 0 : _a.length)) {
        continue;
      }

      var index = registeredModel.listeners.findIndex(function (it) {
        return it.listener === listener;
      });

      if (index >= 0) {
        count++;
        registeredModel.listeners.splice(index, 1);
      }
    }

    return count;
  };

  _proto.addModelStateListener = function addModelStateListener(modelNameSpaces, listener) {
    if (!(modelNameSpaces && modelNameSpaces.length > 0)) {
      return 0;
    }

    var listenerWrapper = {
      id: this.stateListenerIdCounter++,
      listener: listener
    };

    for (var i = 0; i < modelNameSpaces.length; i++) {
      var registeredModel = this.models[modelNameSpaces[i]];

      if (typeof registeredModel === "undefined" || registeredModel === null) {
        throw new core_1.RuntimeException(modelNameSpaces[i] + " is not existed");
      }

      if (typeof registeredModel.listeners === "undefined" || registeredModel.listeners === null) {
        registeredModel.listeners = [];
      }

      registeredModel.listeners.push(listenerWrapper);
    }

    return listenerWrapper.id;
  }
  /**
   * 注册model
   */
  ;

  _proto.registerModel = function registerModel(model, initState) {
    var _this2 = this;

    var namespace = model.getNamespace();
    var registered = this.models[namespace];

    if (registered) {
      if (registered.modelInstance === model) {
        // 已经注册了相同model，无需重复注册
        return model;
      } else {
        // namespace 需要保持全局唯一
        throw new core_1.RuntimeException("Register model failed, model namespace " + namespace + " is existed");
      }
    } else {
      registered = {
        modelInstance: model
      };
      this.models[namespace] = registered;
    } // set reducers


    var setStateActionType = namespace + "/__SET_STATE";

    this.asyncReducers[namespace] = function (state, action) {
      if (state === void 0) {
        state = initState;
      }

      if (action.type === setStateActionType) {
        if (_this2.isStateRecording) {
          _this2.setStateHistories.push(action);
        }

        var nextState = action.state;
        return Object.assign(Object.assign({}, state), nextState);
      } else {
        return state;
      }
    };

    this.store.replaceReducer(this.createReducer());
    return model;
  };

  _proto.dispatch = function dispatch(action) {
    return this.store.dispatch(action);
  };

  _proto.dispatchBatch = function dispatchBatch(actions) {
    if (!(actions === null || actions === void 0 ? void 0 : actions.length)) {
      return;
    }

    var batchActions = [];
    var mergeState = null;

    for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
      var action = _step2.value;
      var type = action.type;
      var setStateMatch = typeof type === "string" && type.match(/(\w+)\/__SET_STATE/);

      if (setStateMatch) {
        var modelNs = setStateMatch[1];

        if (!mergeState) {
          mergeState = {};
        }

        mergeState[modelNs] = Object.assign({}, mergeState[modelNs], action.state);
      } else {
        if (mergeState) {
          batchActions.push({
            type: exports.ACTION_MERGE_STATE,
            state: mergeState
          });
          mergeState = null;
        }

        batchActions.push(action);
      }
    }

    if (mergeState) {
      batchActions.push({
        type: exports.ACTION_MERGE_STATE,
        state: mergeState
      });
    }

    for (var _i = 0, _batchActions = batchActions; _i < _batchActions.length; _i++) {
      var batchAction = _batchActions[_i];
      this.dispatch(batchAction);
    }
  };

  _proto.startRecordState = function startRecordState() {
    this.isStateRecording = true;
    this.setStateHistories = [];
  };

  _proto.stopRecordState = function stopRecordState() {
    var histories = this.setStateHistories;
    this.setStateHistories = [];
    return histories;
  };

  return ReactReduxService;
}();

exports.ReactReduxService = ReactReduxService;

/***/ }),

/***/ 12906:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split("").join(".");
};

var ActionTypes = {
  INIT: "@@redux/INIT" + /* #__PURE__ */randomString(),
  REPLACE: "@@redux/REPLACE" + /* #__PURE__ */randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
exports["default"] = ActionTypes;

/***/ }),

/***/ 67937:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/**
 * @param obj The object to inspect.
 * @returns True if the argument appears to be a plain object.
 */

function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

exports["default"] = isPlainObject;

/***/ }),

/***/ 99952:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var $$observable = /* #__PURE__ */function () {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

exports["default"] = $$observable;

/***/ }),

/***/ 6588:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/**
 * Prints a warning in the console if it exists.
 *
 * @param message The warning message.
 */

function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

exports["default"] = warning;

/***/ }),

/***/ 47326:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createReactRouteResolver = exports.ReactRouteLoader = void 0;

var react_1 = __importStar(__webpack_require__(2784));

var react_router_1 = __webpack_require__(10289);

var core_1 = __webpack_require__(16134);

var react_app_container_1 = __webpack_require__(30739);

var react_route_decorator_1 = __webpack_require__(85067);

var react_app_init_manager_1 = __webpack_require__(66965);

function isDynamicRoute(routePath) {
  return routePath.indexOf(":") > 0 || routePath.indexOf("*") > 0;
}

var DefaultLoadingComp = function DefaultLoadingComp(_ref) {
  var match = _ref.match,
      location = _ref.location,
      route = _ref.route;
  return null;
};

function getRouteElement(appContext, route) {
  var componentName = route.componentName,
      componentPackage = route.componentPackage,
      componentModule = route.componentModule,
      element = route.element,
      routePath = route.path; // function wrapperComp(Comp: ComponentType<any>) {
  //   let element = null;
  //   // url地址发生后，新地址依然匹配当前路由时，界面重新加载。
  //   if (isDynamicRoute(route.path)) {
  //     function InstComp(props: any) {
  //       return <Comp {...props} />;
  //     }
  //     // return <InstComp route={route} match={match} location={location} navigate={navigate} />;
  //     element = <InstComp />;
  //   } else {
  //     // return <Comp route={route} match={match} location={location} navigate={navigate} />;
  //     element = <Comp />;
  //   }
  //   return element;
  // }

  if (componentName !== undefined) {
    var routeElementResolver = createReactRouteResolver(routePath, componentName, componentPackage);

    var getComponent = function getComponent(pModule) {
      return routeElementResolver(appContext, pModule); // let info = appContext.getProviderDefinition(componentName, componentPackage);
      // if (info === undefined) {
      //   try {
      //     appContext.registerModule(pModule);
      //   } catch (e) {
      //     console.log(e);
      //   }
      //   // try get again
      //   info = appContext.getProviderDefinition(componentName, componentPackage);
      // }
      //
      // if (!info) {
      //   throw new RuntimeException(`Joy can not find the route controller component(providerName:${String(componentName)})`);
      // }
      // const Comp = info.useClass as ComponentType;
      // return wrapperComp(Comp);
    };

    if (typeof componentModule === "function") {
      // dynamic lazy load
      return componentModule().then(function (module) {
        return getComponent(module);
      });
    } else {
      return getComponent(componentModule);
    }
  } else if (componentModule) {
    if (typeof componentModule === "function") {
      return componentModule().then(function (resolvedMod) {
        return wrapperComp(appContext, resolvedMod["default"] || resolvedMod, undefined, routePath);
      });
    } else {
      return wrapperComp(appContext, componentModule["default"] || componentModule, undefined, routePath);
    }
  } else if (element) {
    throw new core_1.RuntimeException("React route \"" + route.path + "\" has element, should not be loaded by ReactRouteLoader, try to render element directly.");
  } else {
    throw new core_1.RuntimeException("React route loader can not load route \"" + route.path + "\".");
  }
}

function ReactRouteLoader(_ref2) {
  var route = _ref2.route,
      element = _ref2.element,
      loading = _ref2.loading;

  var _a;

  var location = (0, react_router_1.useLocation)();
  var navigate = (0, react_router_1.useNavigate)();
  var match = (0, react_router_1.useMatch)({
    path: route.path,
    end: !((_a = route.children) === null || _a === void 0 ? void 0 : _a.length)
  });

  if (!match) {
    throw new core_1.RuntimeException("React route load error: Route \"" + route.path + "\" is not match location: \"" + location.pathname + "\"");
  }

  var matchUrl = match.pathname;
  var appContext = (0, react_1.useContext)(react_app_container_1.ReactApplicationReactContext);

  if (!appContext) {
    throw new Error("react app context is not initialed");
  }

  if (route.catchAllParam) {
    // 特殊处理，填入catchAllParam的值。
    Object.defineProperty(match.params, route.catchAllParam, {
      value: match.params["*"]
    });
  }

  var routeContextValue = (0, react_1.useMemo)(function () {
    var routeContextValue = {
      route: route,
      match: match,
      location: location,
      navigate: navigate,
      controllers: []
    };
    return routeContextValue;
  }, [location, match]);
  var routeElement = (0, react_1.useMemo)(function () {
    var children = element || getRouteElement(appContext, route);
    return children;
  }, [matchUrl]);

  var _ref3 = (0, react_1.useState)({
    isCompLoading: routeElement instanceof Promise,
    routeElement: routeElement
  }),
      loadingState = _ref3[0],
      setLoadingStat = _ref3[1];

  (0, react_1.useEffect)(function () {
    var initManager = appContext.getSync(react_app_init_manager_1.ReactAppInitManager);
    Promise.all([routeElement, initManager.initControllers(matchUrl)]).then(function (_ref4) {
      var ele = _ref4[0],
          ctl = _ref4[1];

      if (loadingState.isCompLoading) {
        setLoadingStat({
          isCompLoading: false,
          routeElement: ele
        });
      }
    });
  }, [matchUrl]);
  var props = {
    match: match,
    location: location,
    route: route
  };
  var LoadingComp = loading || DefaultLoadingComp;

  if (loadingState.isCompLoading) {
    return react_1["default"].createElement(LoadingComp, Object.assign({}, props, {
      match: match,
      location: location
    }));
  }

  return react_1["default"].createElement(react_route_decorator_1.ReactRouteContext.Provider, {
    value: routeContextValue
  }, loadingState.routeElement);
}

exports.ReactRouteLoader = ReactRouteLoader;

function createReactRouteResolver(routePath, componentName, componentPackage) {
  return function (appContext, objModule, props) {
    var info = appContext.getProviderDefinition(componentName, componentPackage);

    if (info === undefined) {
      try {
        appContext.registerModule(objModule);
      } catch (e) {
        console.log(e);
      } // try get again


      info = appContext.getProviderDefinition(componentName, componentPackage);
    }

    if (!info) {
      throw new core_1.RuntimeException("Joy can not find the route controller component(providerName:" + String(componentName) + ")");
    }

    var Comp = info.useClass;
    return react_1["default"].createElement(Comp, Object.assign({}, props));
  };
}

exports.createReactRouteResolver = createReactRouteResolver;

function wrapperComp(appContext, Comp, props, routePath) {
  // let element = null;
  // // url地址发生后，新地址依然匹配当前路由时，界面重新加载。
  // if (isDynamicRoute(routePath)) {
  //   function InstComp(props: any) {
  //     return <Comp {...props} />;
  //   }
  //   element = <InstComp {...props} />;
  // } else {
  //   element = <Comp {...props} />;
  // }
  return react_1["default"].createElement(Comp, Object.assign({}, props));
}

/***/ }),

/***/ 85067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bindRouteFromCompProps = exports.getRouteParamsMeta = exports.RouteParam = exports.getRouteMeta = exports.ReactRouteContainer = exports.ReactRoute = exports.ReactRouteContext = void 0;

var react_1 = __importDefault(__webpack_require__(2784));

var core_1 = __webpack_require__(16134);

var REACT_ROUTE_META = "__joy_route";
var REACT_ROUTE_PARAM_META = "__joy_route_param";
exports.ReactRouteContext = react_1["default"].createContext(null);

function ReactRoute(options) {
  return function (constructor) {
    var injectableMeta = (0, core_1.getComponentMeta)(constructor);

    if (!injectableMeta) {
      throw new Error("@Route() decorator used on " + constructor.name + " class, but " + constructor.name + " is not an injectable component");
    }

    options = Object.assign({
      exact: true
    }, options);
    Reflect.defineMetadata(REACT_ROUTE_META, options, constructor);
    return constructor;
  };
}

exports.ReactRoute = ReactRoute;

function ReactRouteContainer(options) {
  return function (constructor) {
    var injectableMeta = (0, core_1.getComponentMeta)(constructor);

    if (!injectableMeta) {
      throw new Error("@Route() decorator used on " + constructor.name + " class, but " + constructor.name + " is not an injectable component");
    }

    options = Object.assign({}, options, {
      isContainer: true
    });
    Reflect.defineMetadata(REACT_ROUTE_META, options, constructor);
    return constructor;
  };
}

exports.ReactRouteContainer = ReactRouteContainer;

function getRouteMeta(target) {
  return Reflect.getMetadata(REACT_ROUTE_META, target);
}

exports.getRouteMeta = getRouteMeta;

function RouteParam(options) {
  if (options === void 0) {
    options = {};
  }

  return function (target, propKey) {
    var _options = options,
        name = _options.name,
        type = _options.type,
        _options$isOptional = _options.isOptional,
        isOptional = _options$isOptional === void 0 ? false : _options$isOptional,
        restOps = __rest(options, ["name", "type", "isOptional"]);

    var paramName = name || propKey;
    var paramType = type || Reflect.getMetadata("design:type", target, propKey) || String;
    var params = getRouteParamsMeta(target) || [];
    params = [].concat(params, [Object.assign({
      propKey: propKey,
      name: paramName,
      type: paramType,
      isOptional: isOptional
    }, restOps)]);
    Reflect.defineMetadata(REACT_ROUTE_PARAM_META, params, target);
  };
}

exports.RouteParam = RouteParam;

function getRouteParamsMeta(target) {
  return Reflect.getMetadata(REACT_ROUTE_PARAM_META, target) || [];
}

exports.getRouteParamsMeta = getRouteParamsMeta;

function bindRouteFromCompProps(routeCompInstance, props) {
  var _a;

  var parmas = getRouteParamsMeta(routeCompInstance);

  if (!parmas || parmas.length === 0) {
    return undefined;
  }

  var match = props.match;

  if (!match) {
    throw new Error("@RouteParam() decorator Component " + ((_a = Object.getPrototypeOf(routeCompInstance).constructor) === null || _a === void 0 ? void 0 : _a.displayName) + ", which is decorated by @Route(),");
  }

  var matchedParams = match.params || {};

  if (parmas && parmas.length) {
    for (var i = 0; i < parmas.length; i++) {
      var _parmas$i = parmas[i],
          propKey = _parmas$i.propKey,
          name = _parmas$i.name,
          type = _parmas$i.type,
          transform = _parmas$i.transform,
          isOptional = _parmas$i.isOptional;
      var value = matchedParams[name];

      if ((value === undefined || value === null) && isOptional) {
        throw new Error("route param(" + name + ") must not to be null, on property" + propKey);
      }

      var transformedValue = value;
      var strTypeof = typeof type;

      if (transform) {
        transformedValue = transform(value);
      } else {
        if (type === Number || strTypeof === "number") {
          transformedValue = new Number(value).valueOf();
        } else if (type === Boolean || strTypeof === "boolean") {
          transformedValue = new Boolean(value).valueOf();
        } else if (type === String || strTypeof === "string") {
          transformedValue = value;
        } else {
          throw new Error("can't recognise type to route param(" + name + ") type, on property" + propKey);
        }
      } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore no necessary check type


      routeCompInstance[propKey] = transformedValue;
    }
  }

  return parmas;
}

exports.bindRouteFromCompProps = bindRouteFromCompProps;

/***/ }),

/***/ 7725:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
  }
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NavLink = exports.Link = exports.useSearchParams = exports.useLinkClickHandler = exports.HashRouter = exports.BrowserRouter = exports.useOutletContext = exports.useRoutes = exports.useResolvedPath = exports.useParams = exports.useOutlet = exports.useNavigationType = exports.useNavigate = exports.useMatch = exports.useLocation = exports.useInRouterContext = exports.useHref = exports.resolvePath = exports.renderMatches = exports.matchPath = exports.matchRoutes = exports.generatePath = exports.createRoutesFromChildren = exports.Routes = exports.Router = exports.Route = exports.Outlet = exports.Navigate = exports.MemoryRouter = void 0;

var react_router_dom_1 = __webpack_require__(62833);

Object.defineProperty(exports, "createRoutesFromChildren", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.createRoutesFromChildren;
  }
}));
Object.defineProperty(exports, "generatePath", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.generatePath;
  }
}));
Object.defineProperty(exports, "matchPath", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.matchPath;
  }
}));
Object.defineProperty(exports, "matchRoutes", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.matchRoutes;
  }
}));
Object.defineProperty(exports, "MemoryRouter", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.MemoryRouter;
  }
}));
Object.defineProperty(exports, "Navigate", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.Navigate;
  }
}));
Object.defineProperty(exports, "Outlet", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.Outlet;
  }
}));
Object.defineProperty(exports, "renderMatches", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.renderMatches;
  }
}));
Object.defineProperty(exports, "resolvePath", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.resolvePath;
  }
}));
Object.defineProperty(exports, "Route", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.Route;
  }
}));
Object.defineProperty(exports, "Router", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.Router;
  }
}));
Object.defineProperty(exports, "Routes", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.Routes;
  }
}));
Object.defineProperty(exports, "useHref", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useHref;
  }
}));
Object.defineProperty(exports, "useInRouterContext", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useInRouterContext;
  }
}));
Object.defineProperty(exports, "useLocation", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useLocation;
  }
}));
Object.defineProperty(exports, "useMatch", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useMatch;
  }
}));
Object.defineProperty(exports, "useNavigate", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useNavigate;
  }
}));
Object.defineProperty(exports, "useNavigationType", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useNavigationType;
  }
}));
Object.defineProperty(exports, "useOutlet", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useOutlet;
  }
}));
Object.defineProperty(exports, "useOutletContext", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useOutletContext;
  }
}));
Object.defineProperty(exports, "useParams", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useParams;
  }
}));
Object.defineProperty(exports, "useResolvedPath", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useResolvedPath;
  }
}));
Object.defineProperty(exports, "useRoutes", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_1.useRoutes;
  }
}));

var react_router_dom_2 = __webpack_require__(62833);

Object.defineProperty(exports, "BrowserRouter", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.BrowserRouter;
  }
}));
Object.defineProperty(exports, "HashRouter", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.HashRouter;
  }
}));
Object.defineProperty(exports, "Link", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.Link;
  }
}));
Object.defineProperty(exports, "NavLink", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.NavLink;
  }
}));
Object.defineProperty(exports, "useLinkClickHandler", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.useLinkClickHandler;
  }
}));
Object.defineProperty(exports, "useSearchParams", ({
  enumerable: true,
  get: function get() {
    return react_router_dom_2.useSearchParams;
  }
}));

__exportStar(__webpack_require__(1421), exports);

/***/ }),

/***/ 2879:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var _createClass = __webpack_require__(5216);

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReactRouterService = void 0;

var react_router_1 = __webpack_require__(10289);

var core_1 = __webpack_require__(16134);

var react_route_decorator_1 = __webpack_require__(85067);

var route_sorter_1 = __webpack_require__(80098);

var react_1 = __importDefault(__webpack_require__(2784));

var react_route_loader_1 = __webpack_require__(47326);

var ReactRouterService = /*#__PURE__*/function () {
  function ReactRouterService() {
    this.routesMap = new Map(); // store all routes

    this.routeTrees = []; // routes as be formatted as tree

    this.rootRouteNode = new route_sorter_1.RoutePathNode(); // public normalizeRoutePath(path: string): string {
    //   // If the path is `/` we need to append `/index`, otherwise the returned directory root will be bundles instead of pages
    //   if (path === "/") {
    //     path = "/index";
    //   } else if (/^\/index(\/|$)/.test(path)) {
    //     path = `/index${path}`;
    //   }
    //   // Resolve on anything that doesn't start with `/`
    //   if (!path.startsWith("/")) {
    //     path = `/${path}`;
    //   }
    //   // Throw when using ../ etc in the pathname
    //   const resolvedPage = posix.normalize(path);
    //   if (path !== resolvedPage) {
    //     throw new Error(
    //       `Requested and resolved page mismatch: ${path} ${resolvedPage}`
    //     );
    //   }
    //   return path;
    // }
  }

  var _proto = ReactRouterService.prototype;

  _proto.getRoutePathCacheKey = function getRoutePathCacheKey(_ref) {
    var path = _ref.path,
        index = _ref.index;

    if (index) {
      return path + (path.endsWith("/") ? "" : "/") + "$$index";
    } else {
      return path;
    }
  };

  _proto.addRouteCache = function addRouteCache(route) {
    var cacheKey = this.getRoutePathCacheKey(route);
    this.routesMap.set(cacheKey, route);
  };

  _proto.removeRouteCache = function removeRouteCache(route) {
    var cacheKey = this.getRoutePathCacheKey(route);
    this.routesMap["delete"](cacheKey);
  };

  _proto.getRouteCache = function getRouteCache(routePattern) {
    var cacheKey = this.getRoutePathCacheKey(routePattern);
    return this.routesMap.get(cacheKey);
  };

  _proto.getRoutes = function getRoutes() {
    return this.routeTrees;
  };

  _proto.setRoutes = function setRoutes(routes) {
    var _this = this;

    this.routesMap = new Map();
    this.traverseTree(routes, function (r) {
      _this.addRouteCache(r);

      if (!r.element) {
        r.element = _this.createElementWrapper(r);
      } // this.routesMap.set(r.path, r);


      return false;
    });
    this.refreshTree();
  };

  _proto.setCurrentLocation = function setCurrentLocation(location) {
    this.curLocation = location;
  };

  _proto.hasRouteByPath = function hasRouteByPath(route) {
    return this.getRouteCache(route);
  };

  _proto.addRoute = function addRoute(route) {
    var existRoute = this.getRouteCache(route);

    if (existRoute) {
      console.debug("Overriding route path:" + existRoute.path + ", replacing {providerName: " + String(existRoute.componentName) + " with {providerName: " + String(route.componentName) + "}");
    }

    route.element = this.createElementWrapper(route);
    this.addRouteCache(route); // this.routesMap.set(route.path, route);

    this.rootRouteNode.insertRoute(route);
    this.routeTrees = this.rootRouteNode.smooth();
  };

  _proto.createElementWrapper = function createElementWrapper(route) {
    var element = route.element;

    if (element && element.type === react_route_loader_1.ReactRouteLoader) {
      return element;
    }

    return react_1["default"].createElement(react_route_loader_1.ReactRouteLoader, {
      route: route,
      element: element,
      key: route.path
    });
  }
  /**
   * 删除路由
   * @param routePath 匹配的路由路径，和注册的路由路径对比。
   * @param rmChildren 是否同时删除其子路由
   */
  ;

  _proto.removeRoute = function removeRoute(rmRoute, rmChildren) {
    if (rmChildren === void 0) {
      rmChildren = false;
    }

    var removedRoutes = [];

    for (var _iterator = _createForOfIteratorHelperLoose(this.routesMap.values()), _step; !(_step = _iterator()).done;) {
      var _route = _step.value;

      if (rmChildren) {
        if (_route.path.startsWith(rmRoute.path)) {
          if (_route.path === rmRoute.path) {
            if (rmRoute.index && !_route.index) {
              continue;
            }
          }

          removedRoutes.push(_route);
        }
      } else {
        if (_route.path === rmRoute.path) {
          if (rmRoute.index && !_route.index) {
            continue;
          }

          if (rmRoute.isContainer && !_route.isContainer) {
            continue;
          }

          removedRoutes.push(_route);
          break;
        }
      }
    }

    if (!(removedRoutes === null || removedRoutes === void 0 ? void 0 : removedRoutes.length)) {
      return undefined;
    }

    for (var _i = 0, _removedRoutes = removedRoutes; _i < _removedRoutes.length; _i++) {
      var route = _removedRoutes[_i];
      this.removeRouteCache(route);
    } // 重建整个routeTree, 可以优化为：只摘除PathNode中的节点，然后生成树。


    this.refreshTree();
    return removedRoutes;
  };

  _proto.refreshTree = function refreshTree() {
    this.rootRouteNode = new route_sorter_1.RoutePathNode();
    this.rootRouteNode.insertRoutes(Array.from(this.routesMap.values()));
    this.routeTrees = this.rootRouteNode.smooth();
  };

  _proto.filterRoutes = function filterRoutes(predicate) {
    return this._filterRoute(this.routeTrees, predicate);
  };

  _proto._filterRoute = function _filterRoute(routes, predicate, previousValue) {
    if (previousValue === void 0) {
      previousValue = [];
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(routes), _step2; !(_step2 = _iterator2()).done;) {
      var route = _step2.value;

      if (predicate(route)) {
        previousValue.push(route);

        if (route.children) {
          this._filterRoute(route.children, predicate, previousValue);
        }
      }
    }

    return previousValue;
  };

  _proto.find = function find(routes, predicate, previousValue) {
    if (previousValue === void 0) {
      previousValue = [];
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(routes), _step3; !(_step3 = _iterator3()).done;) {
      var route = _step3.value;

      if (predicate(route)) {
        previousValue.push(route);

        if (route.children) {
          this.find(route.children, predicate, previousValue);
        }

        break;
      }
    }

    return previousValue;
  };

  _proto.traverse = function traverse(visitor) {
    this.traverseTree(this.routeTrees, visitor);
  };

  _proto.traverseTree = function traverseTree(routes, visitor) {
    for (var _iterator4 = _createForOfIteratorHelperLoose(routes), _step4; !(_step4 = _iterator4()).done;) {
      var route = _step4.value;

      if (visitor(route)) {
        return true;
      }

      if (route.children) {
        if (this.traverseTree(route.children, visitor)) {
          return true;
        }
      }
    }

    return false;
  };

  _proto.matchRoutes = function matchRoutes(pathname) {
    return (0, react_router_1.matchRoutes)(this.getRoutes(), pathname);
  }
  /**
   * 返回数组，前一个路由是后一个路由的父路由。
   * @param pathname
   */
  ;

  _proto.getMatchedRoutes = function getMatchedRoutes(pathname) {
    var matches = this.matchRoutes(pathname);
    return matches === null || matches === void 0 ? void 0 : matches.map(function (it) {
      return it.route;
    }); // const rst = this.find(this.getRoutes(), (route) => {
    //   let matched: PathMatch | null = matchPath({ path: route.path, end: !route.children?.length }, pathname);
    //   // if (route.path.endsWith("/index")) {
    //   //   const indexPath = route.path.slice(0, -6);
    //   //   matched = matchPath(indexPath, pathname);
    //   // }
    //   // if (!matched) {
    //   //   matched = matchPath(route.path, pathname);
    //   // }
    //   return !!matched;
    // });
    // return rst;
  };

  _proto.mergeRouteExtendState = function mergeRouteExtendState(to, from) {// by default, there is nothing to merge
  };

  _proto.addRouteProvider = function addRouteProvider(provider, basePath) {
    if (!provider.type || provider.type === Object) {
      return;
    }

    var routes = this.scanProvider(provider);

    if (!routes || routes.length === 0) {
      return;
    }

    var addedRoutes = [];

    for (var i = 0; i < routes.length; i++) {
      var route = routes[i];
      var path = route.path;

      if (basePath) {
        path = basePath + path;
      }

      if (path.endsWith("/") && path !== "/") {
        path = path.slice(0, -1);
      }

      route.path = path;
      this.addRoute(route);
      addedRoutes.push(route);
    }

    return addedRoutes;
  };

  _proto.replaceRouteProvider = function replaceRouteProvider(nextProvider, preProviderName) {
    var _this2 = this;

    var nextRoutes = this.scanProvider(nextProvider) || [];
    var preProviders = this.filterRoutes(function (route) {
      return route.componentName === preProviderName;
    });
    var added = [];
    var removed = [];
    var modified = [];
    preProviders.forEach(function (route) {
      var next = nextRoutes.find(function (value) {
        return value.path === route.path;
      }); // let next: T|undefined = undefined
      // for (let i = 0; i < nextRoutes.length; i++) {
      //   if (nextRoutes[i].path === route.path){
      //     next = nextRoutes[i]
      //     this.mergeRouteExtendState(next, route) // merge some extend props
      //     break
      //   }
      // }

      _this2.removeRoute(route);

      if (next) {
        _this2.mergeRouteExtendState(next, route);

        modified.push(next);
      } else {
        removed.push(route);
      }
    });
    nextRoutes.forEach(function (route) {
      _this2.addRoute(route);

      var pre = preProviders.find(function (value) {
        return value.path === route.path;
      });

      if (!pre) {
        added.push(route);
      }
    });
    return {
      added: added,
      removed: removed,
      modified: modified
    };
  };

  _proto.createFromMeta = function createFromMeta(path, providerName, providerPackage, meta, useClass) {
    var hasStaticState = !!useClass.prototype.initModelStaticState;
    var hasState = !!useClass.prototype.initModelState;
    return Object.assign(Object.assign({}, meta), {
      path: path,
      componentName: providerName,
      componentPackage: providerPackage,
      hasStaticState: hasStaticState,
      hasState: hasState
    });
  };

  _proto.scanProvider = function scanProvider(provider) {
    var _this3 = this;

    var _a;

    var name = provider.name,
        providerPackage = provider["package"];
    var clazz;

    if ((0, core_1.isClassComponent)(provider)) {
      clazz = provider.useClass;
    } else {
      clazz = provider.type;
    }

    var routeMeta = (0, react_route_decorator_1.getRouteMeta)(clazz);

    if (!routeMeta) {
      return;
    }

    if (Array.isArray(name)) {
      throw new Error("ReactController component name must not be an array");
    }

    var routes = [];

    if (Array.isArray(routeMeta.path)) {
      (_a = routeMeta.path) === null || _a === void 0 ? void 0 : _a.forEach(function (path) {
        var route = _this3.createFromMeta(path, name, providerPackage, routeMeta, clazz);

        routes.push(route);
      });
    } else {
      var route = this.createFromMeta(routeMeta.path, name, providerPackage, routeMeta, clazz);
      routes.push(route);
    }

    return routes;
  };

  _createClass(ReactRouterService, [{
    key: "location",
    get: function get() {
      return this.curLocation;
    }
  }]);

  return ReactRouterService;
}();

exports.ReactRouterService = ReactRouterService;

/***/ }),

/***/ 80098:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getSortedRoutes = exports.RoutePathNode = void 0;

var RoutePathNode = /*#__PURE__*/function () {
  function RoutePathNode() {
    this.placeholder = true;
    this.children = new Map();
    this.slugName = null;
    this.restSlugName = null;
    this.optionalRestSlugName = null;
  }

  var _proto = RoutePathNode.prototype;

  _proto.insertRoute = function insertRoute(route) {
    var routePath = route.path;

    if (route.index) {
      routePath = routePath + (routePath.endsWith("/") ? "$index" : "/$index");
    }

    this._insert(route, routePath.split("/").filter(Boolean), [], false);
  };

  _proto.insertRoutes = function insertRoutes(routes) {
    for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {
      var route = _step.value;
      this.insertRoute(route);
    }
  };

  _proto.smooth = function smooth() {
    return this._smoosh();
  };

  _proto._smoosh = function _smoosh(prefix) {
    var _this = this;

    if (prefix === void 0) {
      prefix = "/";
    }

    var childrenPaths = Array.from(this.children.keys()).sort();

    if (this.slugName !== null) {
      childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
    }

    if (this.restSlugName !== null) {
      childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
    }

    if (this.optionalRestSlugName !== null) {
      childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
    }

    var routes = [];
    var childrenRoutes = childrenPaths.map(function (c) {
      var childNode = _this.children.get(c);

      return childNode._smoosh("" + prefix + c + "/");
    }).reduce(function (prev, curr) {
      return [].concat(prev, curr);
    }, []);

    if (this.slugName !== null) {
      childrenRoutes.push.apply(childrenRoutes, this.children.get("[]")._smoosh(prefix + ":" + this.slugName + "/"));
    }

    if (this.restSlugName !== null) {
      childrenRoutes.push.apply(childrenRoutes, this.children.get("[...]")._smoosh(prefix + ":" + this.restSlugName + "+/"));
    }

    if (this.optionalRestSlugName !== null) {
      childrenRoutes.push.apply(childrenRoutes, this.children.get("[[...]]")._smoosh(prefix + ":" + this.optionalRestSlugName + "*/"));
    }

    if (!this.placeholder) {
      var r = prefix === "/" ? "/" : prefix.slice(0, -1);

      if (this.optionalRestSlugName != null) {
        throw new Error("You cannot define a route with the same specificity as a optional catch-all route (\"" + r + "\" and \"" + r + ":" + this.optionalRestSlugName + "*\").");
      }

      if (this.route.isContainer) {
        this.route.children = childrenRoutes;
        routes.push(this.route);
      } else {
        var _routes;

        (_routes = routes).push.apply(_routes, [this.route].concat(childrenRoutes));
      }
    } else {
      routes = childrenRoutes;
    }

    return routes;
  };

  _proto._insert = function _insert(route, routePaths, slugNames, isCatchAll) {
    if (routePaths.length === 0) {
      this.placeholder = false;
      this.route = route;
      return;
    }

    if (isCatchAll) {
      throw new Error("Catch-all must be the last part of the URL.");
    } // The next segment in the routePaths list


    var nextSegment = routePaths[0]; // Check if the segment matches `[something]`

    if (nextSegment.startsWith(":")) {
      var isOptional = false; // Strip `：` , leaving only `something`

      var segmentName = nextSegment.slice(1);

      if (segmentName.endsWith("?")) {
        isOptional = true; // Strip optional `?`, leaving only `something`

        segmentName = segmentName.slice(0, -1);
      } else if (segmentName.endsWith("+")) {
        isCatchAll = true;
        segmentName = segmentName.slice(0, -1);
      } else if (segmentName.endsWith("*")) {
        isOptional = true;
        isCatchAll = true;
        segmentName = segmentName.slice(0, -1);
      }

      if (/[\*\?\:]/.test(segmentName)) {
        throw new Error("Segment names may not includes special character ('" + segmentName + "').");
      }

      var handleSlug = function handleSlug(previousSlug, nextSlug) {
        if (previousSlug !== null) {
          // If the specific segment already has a slug but the slug is not `something`
          // This prevents collisions like:
          // pages/[post]/index.js
          // pages/[id]/index.js
          // Because currently multiple dynamic params on the same segment level are not supported
          if (previousSlug !== nextSlug) {
            // TODO: This error seems to be confusing for users, needs an err.sh link, the description can be based on above comment.
            throw new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "').");
          }
        }

        slugNames.forEach(function (slug) {
          if (slug === nextSlug) {
            throw new Error("You cannot have the same slug name \"" + nextSlug + "\" repeat within a single dynamic path");
          }

          if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
            throw new Error("You cannot have the slug names \"" + slug + "\" and \"" + nextSlug + "\" differ only by non-word symbols within a single dynamic path");
          }
        });
        slugNames.push(nextSlug);
      };

      if (isCatchAll) {
        if (isOptional) {
          if (this.restSlugName != null) {
            throw new Error("You cannot use both an required and optional catch-all route at the same level (\":" + this.restSlugName + "+\" and \"" + routePaths[0] + "\" ).");
          }

          handleSlug(this.optionalRestSlugName, segmentName); // slugName is kept as it can only be one particular slugName

          this.optionalRestSlugName = segmentName; // nextSegment is overwritten to [[...]] so that it can later be sorted specifically

          nextSegment = "[[...]]";
        } else {
          if (this.optionalRestSlugName != null) {
            throw new Error("You cannot use both an optional and required catch-all route at the same level (\":" + this.optionalRestSlugName + "*\" and \"" + routePaths[0] + "\").");
          }

          handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName

          this.restSlugName = segmentName; // nextSegment is overwritten to [...] so that it can later be sorted specifically

          nextSegment = "[...]";
        }
      } else {
        if (isOptional) {
          throw new Error("Optional route parameters are not yet supported (\"" + routePaths[0] + "\").");
        }

        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName

        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically

        nextSegment = "[]";
      }
    } // If this RoutePathNode doesn't have the nextSegment yet we create a new child RoutePathNode


    if (!this.children.has(nextSegment)) {
      this.children.set(nextSegment, new RoutePathNode());
    }

    this.children.get(nextSegment)._insert(route, routePaths.slice(1), slugNames, isCatchAll);
  };

  return RoutePathNode;
}();

exports.RoutePathNode = RoutePathNode;

function getSortedRoutes(normalizedPages) {
  // First the RoutePathNode is created, and every RoutePathNode can have only 1 dynamic segment
  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js
  // Only 1 dynamic segment per nesting level
  // So in the case that is test/integration/dynamic-routing it'll be this:
  // pages/[post]/comments.js
  // pages/blog/[post]/comment/[id].js
  // Both are fine because `pages/[post]` and `pages/blog` are on the same level
  // So in this case `RoutePathNode` created here has `this.slugName === 'post'`
  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities
  // Instead what has to be passed through is the upwards path's dynamic names
  var root = new RoutePathNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels

  normalizedPages.forEach(function (pagePath) {
    return root.insertRoute({
      path: pagePath
    });
  }); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority

  return root.smooth().map(function (r) {
    return r.path;
  });
}

exports.getSortedRoutes = getSortedRoutes;

/***/ }),

/***/ 1421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);

  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }

  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RoutesRenderer = void 0;

var react_1 = __importStar(__webpack_require__(2784));

var react_router_1 = __webpack_require__(10289);

function RoutesRenderer(_ref) {
  var routes = _ref.routes,
      locationArg = _ref.location;

  var _a;

  var route = (0, react_1.useContext)(react_router_1.UNSAFE_RouteContext);
  var locationCtxValue = (0, react_1.useContext)(react_router_1.UNSAFE_LocationContext);
  var location = locationArg || locationCtxValue.location;
  var matches = (0, react_1.useMemo)(function () {
    return (0, react_router_1.matchRoutes)(routes, location || locationCtxValue.location);
  }, [location]);

  if (!(matches === null || matches === void 0 ? void 0 : matches.length) && !((_a = route.matches) === null || _a === void 0 ? void 0 : _a.length)) {
    location = Object.assign({}, location, {
      pathname: "/404"
    });
  }

  return react_1["default"].createElement(react_router_1.UNSAFE_LocationContext.Provider, {
    value: {
      location: location,
      navigationType: locationCtxValue.navigationType
    }
  }, (0, react_router_1.useRoutes)(routes, location)); // return useRoutes(routes, location);
}

exports.RoutesRenderer = RoutesRenderer;

/***/ }),

/***/ 99270:
/***/ (function(module) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 11219:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(14948);

var isNativeReflectConstruct = __webpack_require__(78270);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 75155:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(14948);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 78270:
/***/ (function(module) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 14948:
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 46913:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(25047);


/***/ }),

/***/ 5216:
/***/ (function(module) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 81660:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(37464);

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  setPrototypeOf(subClass, superClass);
}

module.exports = _inheritsLoose;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 37464:
/***/ (function(module) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;

/***/ }),

/***/ 98152:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(25047);


/***/ }),

/***/ 79172:
/***/ (function(module) {

module.exports = function flatten(list, depth) {
  depth = (typeof depth == 'number') ? depth : Infinity;

  if (!depth) {
    if (Array.isArray(list)) {
      return list.map(function(i) { return i; });
    }
    return list;
  }

  return _flatten(list, 1);

  function _flatten(list, d) {
    return list.reduce(function (acc, item) {
      if (Array.isArray(item) && d < depth) {
        return acc.concat(_flatten(item, d + 1));
      }
      else {
        return acc.concat(item);
      }
    }, []);
  }
};


/***/ }),

/***/ 99092:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(7725);


/***/ }),

/***/ 47498:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}');

/***/ }),

/***/ 58117:
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}');

/***/ })

}]);